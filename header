./ActionEngineBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./ActionEngineBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./AdvancedSecurityServiceBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./AdvancedSecurityServiceBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./AnalyticsDeviceBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./AnalyticsDeviceBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./DeviceBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./DeviceBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./DeviceIOBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./DeviceIOBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./DisplayBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./DisplayBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./dom.c:    return soap->error;
./dom.c:        return soap->error = SOAP_EOM;
./dom.c:    for (p = soap->local_namespaces; p && p->id; p++)
./dom.c:        return soap->error;
./dom.c:    if (l + 1 < sizeof(soap->msgbuf))
./dom.c:      s = soap->msgbuf;
./dom.c:        return soap->error = SOAP_EOM;
./dom.c:    if (s != soap->msgbuf)
./dom.c:    soap_mode m = soap->mode;
./dom.c:    if ((soap->mode & SOAP_DOM_ASIS))
./dom.c:      soap->mode &= ~SOAP_XML_INDENT;
./dom.c:    soap->mode = m;
./dom.c:  return soap->error;
./dom.c:    if ((soap->mode & SOAP_XML_CANONICAL) && !strncmp(name, "xmlns", 5) && (name[5] == ':' || name[5] == '\0'))
./dom.c:  if (l + 1 < sizeof(soap->msgbuf))
./dom.c:    s = soap->msgbuf;
./dom.c:      return soap->error = SOAP_EOM;
./dom.c:  if (s != soap->msgbuf)
./dom.c:    if (!(soap->mode & SOAP_DOM_ASIS) && !(soap->mode & SOAP_XML_CANONICAL))
./dom.c:            return soap->error;
./dom.c:            return soap->error;
./dom.c:    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "DOM node '%s' start at level=%u\n", tag, soap->level));
./dom.c:    if (!(soap->mode & SOAP_DOM_ASIS))
./dom.c:          return soap->error;
./dom.c:    if (!soap->ns)
./dom.c:      soap->ns = 2;
./dom.c:      return soap->error;
./dom.c:          if (!(soap->mode & SOAP_DOM_ASIS))
./dom.c:                    return soap->error;
./dom.c:              return soap->error;
./dom.c:            return soap->error;
./dom.c:      if (!node->text && !node->code && !node->tail && !node->elts && !(soap->mode & SOAP_XML_CANONICAL))
./dom.c:        soap_mode m = soap->mode;
./dom.c:        soap->mode &= ~SOAP_XML_INDENT;
./dom.c:          return soap->error;
./dom.c:        soap->mode = m;
./dom.c:          return soap->error;
./dom.c:          return soap->error;
./dom.c:            return soap->error;
./dom.c:          return soap->error;
./dom.c:          return soap->error;
./dom.c:          soap_mode m = soap->mode;
./dom.c:          if ((soap->mode & SOAP_DOM_ASIS))
./dom.c:            soap->mode &= ~SOAP_XML_INDENT;
./dom.c:            return soap->error;
./dom.c:          soap->mode = m;
./dom.c:          if (l + 1 < sizeof(soap->msgbuf))
./dom.c:            s = soap->msgbuf;
./dom.c:              return soap->error = SOAP_EOM;
./dom.c:            return soap->error;
./dom.c:          if (s != soap->msgbuf)
./dom.c:  if (!(soap->mode & SOAP_DOM_ASIS) && !(soap->mode & SOAP_XML_CANONICAL))
./dom.c:          return soap->error;
./dom.c:          return soap->error;
./dom.c:      if (!(soap->mode & SOAP_DOM_ASIS))
./dom.c:                return soap->error;
./dom.c:          return soap->error;
./dom.c:        return soap->error;
./dom.c:  soap_mode m = soap->mode;
./dom.c:  soap->mode |= SOAP_C_UTFSTRING;
./dom.c:    if (soap->error != SOAP_NO_TAG)
./dom.c:      soap->mode = m;
./dom.c:    soap->mode = m;
./dom.c:        soap->error = SOAP_EOM;
./dom.c:    soap->error = SOAP_OK;
./dom.c:    soap->peeked = 0;
./dom.c:      soap->error = SOAP_EOM;
./dom.c:  node->nstr = soap_current_namespace_tag(soap, soap->tag);
./dom.c:  node->name = soap_strdup(soap, soap->tag);
./dom.c:  if ((soap->mode & SOAP_DOM_NODE) || (!(soap->mode & SOAP_DOM_TREE) && *soap->id && (!type || strcmp(type, "xsd:anyType"))))
./dom.c:    soap->mode = m;
./dom.c:    if (soap->error == SOAP_TAG_MISMATCH)
./dom.c:      soap->error = SOAP_OK;
./dom.c:    soap->mode |= SOAP_C_UTFSTRING;
./dom.c:  for (tp = soap->attributes; tp; tp = tp->next)
./dom.c:        soap->error = SOAP_EOM;
./dom.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "DOM node '%s' pulled (level=%u)\n", node->name, soap->level));
./dom.c:  if (soap->body)
./dom.c:      if (soap->error != SOAP_NO_TAG)
./dom.c:      soap->peeked = 0;
./dom.c:    soap->mode = m;
./dom.c:        if (soap->error && soap->error != SOAP_NO_TAG)
./dom.c:            soap->error = SOAP_EOM;
./dom.c:    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "DOM node '%s' end (level=%u)\n", node->name, soap->level));
./dom.c:    if (strcmp(soap->tag, node->name))
./dom.c:      soap->error = SOAP_SYNTAX_ERROR;
./dom.c:  soap->mode = m;
./dom.c:  for (tp = soap->attributes; tp; tp = tp->next)
./dom.c:        soap->error = SOAP_EOM;
./dom.c:  struct Namespace *p, *ln = soap->local_namespaces;
./dom.c:        for (np = soap->nlist; np; np = np->next)
./dom.c:        (SOAP_SNPRINTF(soap->tag, sizeof(soap->tag), sizeof(SOAP_DOMID_FORMAT) + 20), SOAP_DOMID_FORMAT, i);
./dom.c:        id = soap->tag;
./dom.c:    for (np = soap->nlist; np; np = np->next)
./dom.c:    soap_strncpy(soap->tag, sizeof(soap->tag), id, n);
./dom.c:    id = soap->tag;
./dom.c:    soap->local_namespaces = NULL; /* do not permit a replacement id, when ns is in table */
./dom.c:    soap->level++;
./dom.c:  soap->local_namespaces = ln;
./dom.c:    soap->level--;
./dom.c:    (SOAP_SNPRINTF(soap->msgbuf, sizeof(soap->msgbuf), strlen(np->id) + 6), "xmlns:%s", np->id);
./dom.c:    if (out_attribute(soap, NULL, soap->msgbuf, ns, isearly))
./dom.c:  for (np = soap->nlist; np; np = np->next)
./dom.c:  for (p = soap->namespaces; p && p->id; p++)
./dom.c:  for (p = soap->namespaces; p && p->id; p++)
./dom.c:  for (p = soap->namespaces; p && p->id; p++)
./dom.c:    elt->soap->error = SOAP_OK;
./dom.c:    elt->soap->error = SOAP_OK;
./dom.c:    elt->soap->error = SOAP_OK;
./dom.c:    elt->soap->error = SOAP_OK;
./dom.c:    att->soap->error = SOAP_OK;
./dom.c:    att->soap->error = SOAP_OK;
./dom.c:    att->soap->error = SOAP_OK;
./dom.c:    att->soap->error = SOAP_OK;
./dom.c:  soap->http_content = "text/xml; charset=utf-8";
./dom.c:   || ((soap->mode & SOAP_IO_LENGTH) && soap_out_xsd__anyType(soap, NULL, 0, in, NULL))
./dom.c:    else if (soap->error == SOAP_NO_DATA || soap->error == 200 || soap->error == 202)
./dom.c:      soap->error = SOAP_OK;
./dom.c:      soap->os = &o;
./dom.c:    std::ostream *os = e.soap->os;
./dom.c:    e.soap->os = &o;
./dom.c:    e.soap->os = os;
./dom.c:    std::istream *is = e.soap->is;
./dom.c:    e.soap->is = &i;
./dom.c:    { /* e.soap->error is now set and app should check */ }
./dom.c:    e.soap->is = is;
./DoorControlBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./DoorControlBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./duration.c:  { soap_strcpy(soap->tmpbuf, sizeof(soap->tmpbuf), "-P");
./duration.c:  { soap_strcpy(soap->tmpbuf, sizeof(soap->tmpbuf), "P");
./duration.c:    (SOAP_SNPRINTF(soap->tmpbuf + k, sizeof(soap->tmpbuf) - k, 21), SOAP_LONG_FORMAT "D", d);
./duration.c:      k = strlen(soap->tmpbuf);
./duration.c:      (SOAP_SNPRINTF(soap->tmpbuf + k, sizeof(soap->tmpbuf) - k, 14), "T%02dH%02dM%02d.%03dS", h, m, s, f);
./duration.c:      (SOAP_SNPRINTF(soap->tmpbuf + k, sizeof(soap->tmpbuf) - k, 10), "T%02dH%02dM%02dS", h, m, s);
./duration.c:    soap_strcpy(soap->tmpbuf + k, sizeof(soap->tmpbuf) - k, "T0S");
./duration.c:  return soap->tmpbuf;
./duration.c:    return soap->error;
./duration.c:      return soap->error = SOAP_TYPE;
./duration.c:	return soap->error = SOAP_TYPE;
./duration.c:	  return soap->error = SOAP_TYPE;
./duration.c:	return soap->error = SOAP_TYPE;
./duration.c:	  return soap->error = SOAP_TYPE;
./duration.c:  return soap->error;
./duration.c:  if (*soap->type
./duration.c:   && soap_match_att(soap, soap->type, type)
./duration.c:   && soap_match_att(soap, soap->type, ":duration"))
./duration.c:  { soap->error = SOAP_TYPE;
./duration.c:  a = (LONG64*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__duration, sizeof(LONG64), NULL, NULL, NULL, NULL);
./duration.c:  if (*soap->href)
./duration.c:    a = (LONG64*)soap_id_forward(soap, soap->href, a, 0, SOAP_TYPE_xsd__duration, 0, sizeof(LONG64), 0, NULL, NULL);
./duration.c:  if (soap->body && soap_element_end_in(soap, tag))
./ImagingBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./ImagingBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./mecevp.c:    return soap->error = SOAP_EOM;
./mecevp.c:    return soap->error;
./mecevp.c:  soap->data[1] = (void*)data;
./mecevp.c:  data->mode = soap->mode;
./mecevp.c:    soap->mode &= ~(SOAP_IO | SOAP_IO_LENGTH | SOAP_ENC_ZLIB | SOAP_XML_DOM);
./mecevp.c:    if (soap->mode & SOAP_XML_CANONICAL)
./mecevp.c:      soap->ns = 0; /* for in c14n, we must have all xmlns bindings available */
./mecevp.c:  else if (soap->ffilterrecv != soap_mec_filterrecv)
./mecevp.c:    data->ffilterrecv = soap->ffilterrecv;
./mecevp.c:    soap->ffilterrecv = soap_mec_filterrecv;
./mecevp.c:  data = (struct soap_mec_data*)soap->data[1];
./mecevp.c:    return soap->error = SOAP_USER_ERROR;
./mecevp.c:    data->ffiltersend = soap->ffiltersend;
./mecevp.c:    soap->ffiltersend = soap_mec_filtersend;
./mecevp.c:    len = 2 * sizeof(soap->buf) + EVP_CIPHER_block_size(data->type);
./mecevp.c:    data->bufidx = soap->buflen - soap->bufidx;
./mecevp.c:    soap_memcpy((void*)data->buf, data->buflen, (const void*)(soap->buf + soap->bufidx), data->bufidx);
./mecevp.c:    soap->bufidx = soap->buflen;
./mecevp.c:  data = (struct soap_mec_data*)soap->data[1];
./mecevp.c:    return soap->error = SOAP_USER_ERROR;
./mecevp.c:    if (soap->ffiltersend == soap_mec_filtersend)
./mecevp.c:      soap->ffiltersend = data->ffiltersend;
./mecevp.c:        return soap->error;
./mecevp.c:  if (soap->ffiltersend == soap_mec_filtersend)
./mecevp.c:    soap->ffiltersend = data->ffiltersend;
./mecevp.c:  if (soap->ffilterrecv == soap_mec_filterrecv)
./mecevp.c:    soap->ffilterrecv = data->ffilterrecv;
./mecevp.c:  soap->mode = data->mode;
./mecevp.c:  soap->data[1] = NULL;
./mecevp.c:    return soap->error = SOAP_USER_ERROR;
./mecevp.c:      return soap->error;
./mecevp.c:      return soap->error;
./mecevp.c:    return soap->error = SOAP_USER_ERROR;
./mecevp.c:        data->buflen += sizeof(soap->buf);
./mecevp.c:      data->buflen += sizeof(soap->buf);
./mecevp.c:      return soap->error;
./mecevp.c:        return soap->error;
./mecevp.c:      return soap->error;
./mecevp.c:      return soap->error = SOAP_SSL_ERROR;
./mecevp.c:      ERR_error_string_n(r, soap->msgbuf, sizeof(soap->msgbuf));
./mecevp.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, " %s: \"%s\";", msg, soap->msgbuf));
./mecevp.c:    return soap_set_receiver_error(soap, msg, soap->msgbuf, SOAP_SSL_ERROR);
./mecevp.c:          return soap->error = SOAP_SSL_ERROR;
./mecevp.c:        return soap->error = SOAP_SSL_ERROR;
./mecevp.c:  struct soap_mec_data *data = (struct soap_mec_data*)soap->data[1];
./mecevp.c:  struct soap_mec_data *data = (struct soap_mec_data*)soap->data[1];
./mecevp.c:    return soap->error;
./MediaBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./MediaBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./onvif.h:  - an int file descriptor, using soap->recvfd = fd
./onvif.h:  - a socket, using soap->socket = (int)...
./onvif.h:  - a C++ stream (istream, stringstream), using soap->is = (istream*)...
./onvif.h:  - a C string, using soap->is = (const char*)...
./onvif.h:  - any input, using the soap->frecv() callback
./onvif.h:  - an int file descriptor, using soap->sendfd = (int)...
./onvif.h:  - a socket, using soap->socket = (int)...
./onvif.h:  - a C++ stream (ostream, stringstream), using soap->os = (ostream*)...
./onvif.h:  - a C string, using soap->os = (const char**)...
./onvif.h:  - any output, using the soap->fsend() callback
./onvif.h:  - soap->encodingStyle = NULL; to remove SOAP 1.1/1.2 encodingStyle
./PACSBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./PACSBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./PTZBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./PTZBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./PullPointSubscriptionBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./PullPointSubscriptionBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./ReceiverBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./ReceiverBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./RecordingBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./RecordingBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./RemoteDiscoveryBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./RemoteDiscoveryBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./ReplayBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./ReplayBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./RuleEngineBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./RuleEngineBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./SearchBinding.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./SearchBinding.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./smdevp.c:    soap->sendfd = open("object.xml", O_CREAT | O_WRONLY, 0600); // a file to save object to
./smdevp.c:    close(soap->sendfd);
./smdevp.c:    soap->recvfd = open("object.xml", O_RDONLY);
./smdevp.c:    close(soap->recvfd);
./smdevp.c:    return soap->error = SOAP_EOM;
./smdevp.c:  soap->data[0] = (void*)data;
./smdevp.c:  data->fsend = soap->fsend;
./smdevp.c:  data->frecv = soap->frecv;
./smdevp.c:  soap->fsend = soap_smd_send;
./smdevp.c:  soap->frecv = soap_smd_recv;
./smdevp.c:  data->mode = soap->mode;
./smdevp.c:  soap->mode &= ~(SOAP_IO | SOAP_IO_LENGTH | SOAP_ENC_ZLIB | SOAP_XML_DOM);
./smdevp.c:  if (soap->mode & SOAP_XML_CANONICAL)
./smdevp.c:    soap->ns = 0; /* for in c14n, we must have all xmlns bindings available */
./smdevp.c:    soap->ns = 2; /* we don't want leading whitespace in serialized XML */
./smdevp.c:  data = (struct soap_smd_data*)soap->data[0];
./smdevp.c:    if (soap->error)
./smdevp.c:      return soap->error;
./smdevp.c:    return soap->error = SOAP_USER_ERROR;
./smdevp.c:  soap->fsend = data->fsend;
./smdevp.c:  soap->frecv = data->frecv;
./smdevp.c:  soap->mode = data->mode;
./smdevp.c:  soap->data[0] = NULL;
./smdevp.c:      ERR_error_string_n(r, soap->msgbuf, sizeof(soap->msgbuf));
./smdevp.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "-- SMD Error (%d) %s: %s\n", ok, msg, soap->msgbuf));
./smdevp.c:    return soap_set_receiver_error(soap, msg, soap->msgbuf, SOAP_SSL_ERROR);
./smdevp.c:  if (((struct soap_smd_data*)soap->data[0])->alg & SOAP_SMD_PASSTHRU)
./smdevp.c:    err = ((struct soap_smd_data*)soap->data[0])->fsend(soap, buf, len);
./smdevp.c:  return soap_smd_update(soap, (struct soap_smd_data*)soap->data[0], buf, len);
./smdevp.c:  size_t ret = ((struct soap_smd_data*)soap->data[0])->frecv(soap, buf, len);
./smdevp.c:  if (ret && soap_smd_update(soap, (struct soap_smd_data*)soap->data[0], buf, ret))
./smdevp.h:@brief The smdevp engine context data, which is hooked up to soap->data[0]
./smdevp.h:  soap_mode mode;       /**< to preserve soap->mode value */
./soapC.c:	soap->part = SOAP_IN_HEADER;
./soapC.c:	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
./soapC.c:	soap->part = SOAP_END_HEADER;
./soapC.c:	return soap->header == NULL;
./soapC.c:	if (soap->version && soap->header)
./soapC.c:	{	soap->part = SOAP_IN_HEADER;
./soapC.c:		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
./soapC.c:			return soap->error;
./soapC.c:		soap->part = SOAP_END_HEADER;
./soapC.c:	if (soap->version && soap->header)
./soapC.c:		soap_serialize_SOAP_ENV__Header(soap, soap->header);
./soapC.c:	if (soap->header == NULL)
./soapC.c:	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
./soapC.c:			soap_default_SOAP_ENV__Header(soap, soap->header);
./soapC.c:	if (soap->fault == NULL)
./soapC.c:	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
./soapC.c:		if (soap->fault == NULL)
./soapC.c:		soap_default_SOAP_ENV__Fault(soap, soap->fault);
./soapC.c:	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
./soapC.c:	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
./soapC.c:		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
./soapC.c:	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
./soapC.c:	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
./soapC.c:		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
./soapC.c:	if (soap->fault)
./soapC.c:		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
./soapC.c:	if (soap->fault)
./soapC.c:		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
./soapC.c:	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
./soapC.c:	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
./soapC.c:		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
./soapC.c:	return (const char**)(void*)&soap->fault->faultcode;
./soapC.c:	if (soap->version == 2)
./soapC.c:	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
./soapC.c:		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
./soapC.c:			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
./soapC.c:		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
./soapC.c:	return (const char**)(void*)&soap->fault->faultcode;
./soapC.c:	if (soap->version == 2)
./soapC.c:	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
./soapC.c:			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
./soapC.c:	return soap->fault->faultcode;
./soapC.c:	if (soap->version == 2)
./soapC.c:		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
./soapC.c:	return (const char**)(void*)&soap->fault->faultstring;
./soapC.c:	if (soap->version == 2)
./soapC.c:	{	if (soap->fault->SOAP_ENV__Detail == NULL)
./soapC.c:		{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
./soapC.c:			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
./soapC.c:		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
./soapC.c:	if (soap->fault->detail == NULL)
./soapC.c:	{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
./soapC.c:		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
./soapC.c:	return (const char**)(void*)&soap->fault->detail->__any;
./soapC.c:	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
./soapC.c:		return soap->fault->SOAP_ENV__Detail->__any;
./soapC.c:	if (soap->fault->detail)
./soapC.c:		return soap->fault->detail->__any;
./soapC.c:	if (soap->version == 1)
./soapC.c:				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
./soapC.c:	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
./soapC.c:		soap->error = SOAP_OK;
./soapC.c:	return soap->error;
./soapC.c:	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
./soapC.c:		*type = soap_lookup_type(soap, soap->href);
./soapC.c:	{	const char *t = soap->type;
./soapC.c:			t = soap->tag;
./soapC.c:		t = soap->tag;
./soapC.c:	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
./soapC.c:		if (soap->mustUnderstand && !soap->other && !soap->fignore)
./soapC.c:			return soap->error = SOAP_MUSTUNDERSTAND;
./soapC.c:		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
./soapC.c:		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
./soapC.c:			return soap->error = SOAP_TAG_MISMATCH;
./soapC.c:		if (!*soap->id || !soap_getelement(soap, &t))
./soapC.c:		{	soap->peeked = 0;
./soapC.c:			if (soap->fignore)
./soapC.c:				soap->error = soap->fignore(soap, soap->tag);
./soapC.c:				soap->error = SOAP_OK;
./soapC.c:			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
./soapC.c:			if (!soap->error && soap->body)
./soapC.c:			{	soap->level++;
./soapC.c:					return soap->error;
./soapC.c:	return soap->error;
./soapC.c:	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
./soapC.c:			for (pp = soap->pht[i]; pp; pp = pp->next)
./soapC.c:						return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_LENGTH;
./soapC.c:	{	soap->error = SOAP_LENGTH;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum ns5__KeyStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__KeyStatus, sizeof(enum ns5__KeyStatus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum ns5__KeyStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__KeyStatus, SOAP_TYPE_ns5__KeyStatus, sizeof(enum ns5__KeyStatus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum ns4__DoorMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DoorMode, sizeof(enum ns4__DoorMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum ns4__DoorMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__DoorMode, SOAP_TYPE_ns4__DoorMode, sizeof(enum ns4__DoorMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum ns4__DoorFaultState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DoorFaultState, sizeof(enum ns4__DoorFaultState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum ns4__DoorFaultState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__DoorFaultState, SOAP_TYPE_ns4__DoorFaultState, sizeof(enum ns4__DoorFaultState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum ns4__DoorTamperState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DoorTamperState, sizeof(enum ns4__DoorTamperState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum ns4__DoorTamperState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__DoorTamperState, SOAP_TYPE_ns4__DoorTamperState, sizeof(enum ns4__DoorTamperState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum ns4__DoorAlarmState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DoorAlarmState, sizeof(enum ns4__DoorAlarmState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum ns4__DoorAlarmState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__DoorAlarmState, SOAP_TYPE_ns4__DoorAlarmState, sizeof(enum ns4__DoorAlarmState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum ns4__LockPhysicalState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__LockPhysicalState, sizeof(enum ns4__LockPhysicalState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum ns4__LockPhysicalState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__LockPhysicalState, SOAP_TYPE_ns4__LockPhysicalState, sizeof(enum ns4__LockPhysicalState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum ns4__DoorPhysicalState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DoorPhysicalState, sizeof(enum ns4__DoorPhysicalState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum ns4__DoorPhysicalState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__DoorPhysicalState, SOAP_TYPE_ns4__DoorPhysicalState, sizeof(enum ns4__DoorPhysicalState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum ns2__DenyReason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DenyReason, sizeof(enum ns2__DenyReason), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum ns2__DenyReason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DenyReason, SOAP_TYPE_ns2__DenyReason, sizeof(enum ns2__DenyReason), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum ns2__Decision *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Decision, sizeof(enum ns2__Decision), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum ns2__Decision *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Decision, SOAP_TYPE_ns2__Decision, sizeof(enum ns2__Decision), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum ns1__FileSuffixType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FileSuffixType, sizeof(enum ns1__FileSuffixType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum ns1__FileSuffixType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FileSuffixType, SOAP_TYPE_ns1__FileSuffixType, sizeof(enum ns1__FileSuffixType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum ns1__HttpAuthenticationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HttpAuthenticationMethodType, sizeof(enum ns1__HttpAuthenticationMethodType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum ns1__HttpAuthenticationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HttpAuthenticationMethodType, SOAP_TYPE_ns1__HttpAuthenticationMethodType, sizeof(enum ns1__HttpAuthenticationMethodType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum ns1__HttpProtocolType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HttpProtocolType, sizeof(enum ns1__HttpProtocolType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum ns1__HttpProtocolType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HttpProtocolType, SOAP_TYPE_ns1__HttpProtocolType, sizeof(enum ns1__HttpProtocolType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum ns1__EMailAuthenticationMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EMailAuthenticationMode, sizeof(enum ns1__EMailAuthenticationMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum ns1__EMailAuthenticationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EMailAuthenticationMode, SOAP_TYPE_ns1__EMailAuthenticationMode, sizeof(enum ns1__EMailAuthenticationMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum ns1__AddressFormatType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AddressFormatType, sizeof(enum ns1__AddressFormatType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum ns1__AddressFormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AddressFormatType, SOAP_TYPE_ns1__AddressFormatType, sizeof(enum ns1__AddressFormatType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum timg__ImagingPresetType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_timg__ImagingPresetType, sizeof(enum timg__ImagingPresetType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum timg__ImagingPresetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_timg__ImagingPresetType, SOAP_TYPE_timg__ImagingPresetType, sizeof(enum timg__ImagingPresetType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tmd__ParityBit *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__ParityBit, sizeof(enum tmd__ParityBit), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tmd__ParityBit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__ParityBit, SOAP_TYPE_tmd__ParityBit, sizeof(enum tmd__ParityBit), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tmd__SerialPortType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__SerialPortType, sizeof(enum tmd__SerialPortType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tmd__SerialPortType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__SerialPortType, SOAP_TYPE_tmd__SerialPortType, sizeof(enum tmd__SerialPortType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__MoveStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__MoveStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveStatus, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__OSDType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDType, sizeof(enum tt__OSDType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__OSDType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDType, SOAP_TYPE_tt__OSDType, sizeof(enum tt__OSDType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__ModeOfOperation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ModeOfOperation, sizeof(enum tt__ModeOfOperation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__ModeOfOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ModeOfOperation, SOAP_TYPE_tt__ModeOfOperation, sizeof(enum tt__ModeOfOperation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__TrackType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackType, sizeof(enum tt__TrackType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__TrackType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackType, SOAP_TYPE_tt__TrackType, sizeof(enum tt__TrackType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__RecordingStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingStatus, sizeof(enum tt__RecordingStatus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__RecordingStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingStatus, SOAP_TYPE_tt__RecordingStatus, sizeof(enum tt__RecordingStatus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__SearchState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchState, sizeof(enum tt__SearchState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__SearchState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchState, SOAP_TYPE_tt__SearchState, sizeof(enum tt__SearchState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__ReceiverState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverState, sizeof(enum tt__ReceiverState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__ReceiverState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverState, SOAP_TYPE_tt__ReceiverState, sizeof(enum tt__ReceiverState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__ReceiverMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverMode, sizeof(enum tt__ReceiverMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__ReceiverMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverMode, SOAP_TYPE_tt__ReceiverMode, sizeof(enum tt__ReceiverMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__Direction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Direction, sizeof(enum tt__Direction), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__Direction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Direction, SOAP_TYPE_tt__Direction, sizeof(enum tt__Direction), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__PropertyOperation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PropertyOperation, sizeof(enum tt__PropertyOperation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__PropertyOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PropertyOperation, SOAP_TYPE_tt__PropertyOperation, sizeof(enum tt__PropertyOperation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__DefoggingMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DefoggingMode, sizeof(enum tt__DefoggingMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__DefoggingMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DefoggingMode, SOAP_TYPE_tt__DefoggingMode, sizeof(enum tt__DefoggingMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__ToneCompensationMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensationMode, sizeof(enum tt__ToneCompensationMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__ToneCompensationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensationMode, SOAP_TYPE_tt__ToneCompensationMode, sizeof(enum tt__ToneCompensationMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__IrCutFilterAutoBoundaryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoBoundaryType, sizeof(enum tt__IrCutFilterAutoBoundaryType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__IrCutFilterAutoBoundaryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoBoundaryType, SOAP_TYPE_tt__IrCutFilterAutoBoundaryType, sizeof(enum tt__IrCutFilterAutoBoundaryType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__ImageStabilizationMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationMode, sizeof(enum tt__ImageStabilizationMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__ImageStabilizationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationMode, SOAP_TYPE_tt__ImageStabilizationMode, sizeof(enum tt__ImageStabilizationMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__IrCutFilterMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterMode, sizeof(enum tt__IrCutFilterMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__IrCutFilterMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterMode, SOAP_TYPE_tt__IrCutFilterMode, sizeof(enum tt__IrCutFilterMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__WhiteBalanceMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceMode, sizeof(enum tt__WhiteBalanceMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__WhiteBalanceMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceMode, SOAP_TYPE_tt__WhiteBalanceMode, sizeof(enum tt__WhiteBalanceMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__Enabled *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Enabled, sizeof(enum tt__Enabled), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__Enabled *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Enabled, SOAP_TYPE_tt__Enabled, sizeof(enum tt__Enabled), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__ExposureMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureMode, sizeof(enum tt__ExposureMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__ExposureMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureMode, SOAP_TYPE_tt__ExposureMode, sizeof(enum tt__ExposureMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__ExposurePriority *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposurePriority, sizeof(enum tt__ExposurePriority), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__ExposurePriority *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposurePriority, SOAP_TYPE_tt__ExposurePriority, sizeof(enum tt__ExposurePriority), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__BacklightCompensationMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationMode, sizeof(enum tt__BacklightCompensationMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__BacklightCompensationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationMode, SOAP_TYPE_tt__BacklightCompensationMode, sizeof(enum tt__BacklightCompensationMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__WideDynamicMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicMode, sizeof(enum tt__WideDynamicMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__WideDynamicMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicMode, SOAP_TYPE_tt__WideDynamicMode, sizeof(enum tt__WideDynamicMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__AutoFocusMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AutoFocusMode, sizeof(enum tt__AutoFocusMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__AutoFocusMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AutoFocusMode, SOAP_TYPE_tt__AutoFocusMode, sizeof(enum tt__AutoFocusMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__PTZPresetTourOperation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourOperation, sizeof(enum tt__PTZPresetTourOperation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__PTZPresetTourOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourOperation, SOAP_TYPE_tt__PTZPresetTourOperation, sizeof(enum tt__PTZPresetTourOperation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__PTZPresetTourDirection *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourDirection, sizeof(enum tt__PTZPresetTourDirection), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__PTZPresetTourDirection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourDirection, SOAP_TYPE_tt__PTZPresetTourDirection, sizeof(enum tt__PTZPresetTourDirection), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__PTZPresetTourState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourState, sizeof(enum tt__PTZPresetTourState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__PTZPresetTourState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourState, SOAP_TYPE_tt__PTZPresetTourState, sizeof(enum tt__PTZPresetTourState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__ReverseMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReverseMode, sizeof(enum tt__ReverseMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__ReverseMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReverseMode, SOAP_TYPE_tt__ReverseMode, sizeof(enum tt__ReverseMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__EFlipMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlipMode, sizeof(enum tt__EFlipMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__EFlipMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlipMode, SOAP_TYPE_tt__EFlipMode, sizeof(enum tt__EFlipMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__DigitalIdleState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DigitalIdleState, sizeof(enum tt__DigitalIdleState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__DigitalIdleState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DigitalIdleState, SOAP_TYPE_tt__DigitalIdleState, sizeof(enum tt__DigitalIdleState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__RelayMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayMode, sizeof(enum tt__RelayMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__RelayMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayMode, SOAP_TYPE_tt__RelayMode, sizeof(enum tt__RelayMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__RelayIdleState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayIdleState, sizeof(enum tt__RelayIdleState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__RelayIdleState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayIdleState, SOAP_TYPE_tt__RelayIdleState, sizeof(enum tt__RelayIdleState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__RelayLogicalState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayLogicalState, sizeof(enum tt__RelayLogicalState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__RelayLogicalState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayLogicalState, SOAP_TYPE_tt__RelayLogicalState, sizeof(enum tt__RelayLogicalState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__UserLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__UserLevel, sizeof(enum tt__UserLevel), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__UserLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__UserLevel, SOAP_TYPE_tt__UserLevel, sizeof(enum tt__UserLevel), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__Entity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Entity, sizeof(enum tt__Entity), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__Entity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Entity, SOAP_TYPE_tt__Entity, sizeof(enum tt__Entity), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__SetDateTimeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SetDateTimeType, sizeof(enum tt__SetDateTimeType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__SetDateTimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SetDateTimeType, SOAP_TYPE_tt__SetDateTimeType, sizeof(enum tt__SetDateTimeType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__FactoryDefaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FactoryDefaultType, sizeof(enum tt__FactoryDefaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__FactoryDefaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FactoryDefaultType, SOAP_TYPE_tt__FactoryDefaultType, sizeof(enum tt__FactoryDefaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__SystemLogType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogType, sizeof(enum tt__SystemLogType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__SystemLogType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogType, SOAP_TYPE_tt__SystemLogType, sizeof(enum tt__SystemLogType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__CapabilityCategory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__CapabilityCategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilityCategory, SOAP_TYPE_tt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__Dot11AuthAndMangementSuite *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, sizeof(enum tt__Dot11AuthAndMangementSuite), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__Dot11AuthAndMangementSuite *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, sizeof(enum tt__Dot11AuthAndMangementSuite), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__Dot11SignalStrength *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SignalStrength, sizeof(enum tt__Dot11SignalStrength), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__Dot11SignalStrength *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SignalStrength, SOAP_TYPE_tt__Dot11SignalStrength, sizeof(enum tt__Dot11SignalStrength), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__Dot11Cipher *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Cipher, sizeof(enum tt__Dot11Cipher), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__Dot11Cipher *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Cipher, SOAP_TYPE_tt__Dot11Cipher, sizeof(enum tt__Dot11Cipher), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__Dot11SecurityMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityMode, sizeof(enum tt__Dot11SecurityMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__Dot11SecurityMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityMode, SOAP_TYPE_tt__Dot11SecurityMode, sizeof(enum tt__Dot11SecurityMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__Dot11StationMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11StationMode, sizeof(enum tt__Dot11StationMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__Dot11StationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11StationMode, SOAP_TYPE_tt__Dot11StationMode, sizeof(enum tt__Dot11StationMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__DynamicDNSType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSType, sizeof(enum tt__DynamicDNSType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__DynamicDNSType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSType, SOAP_TYPE_tt__DynamicDNSType, sizeof(enum tt__DynamicDNSType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__IPAddressFilterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilterType, sizeof(enum tt__IPAddressFilterType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__IPAddressFilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilterType, SOAP_TYPE_tt__IPAddressFilterType, sizeof(enum tt__IPAddressFilterType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__IPType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPType, sizeof(enum tt__IPType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__IPType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPType, SOAP_TYPE_tt__IPType, sizeof(enum tt__IPType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__NetworkHostType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHostType, sizeof(enum tt__NetworkHostType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__NetworkHostType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHostType, SOAP_TYPE_tt__NetworkHostType, sizeof(enum tt__NetworkHostType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__NetworkProtocolType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocolType, sizeof(enum tt__NetworkProtocolType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__NetworkProtocolType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocolType, SOAP_TYPE_tt__NetworkProtocolType, sizeof(enum tt__NetworkProtocolType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__IPv6DHCPConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__IPv6DHCPConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6DHCPConfiguration, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__Duplex *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Duplex, sizeof(enum tt__Duplex), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__Duplex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Duplex, SOAP_TYPE_tt__Duplex, sizeof(enum tt__Duplex), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__DiscoveryMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DiscoveryMode, sizeof(enum tt__DiscoveryMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__DiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DiscoveryMode, SOAP_TYPE_tt__DiscoveryMode, sizeof(enum tt__DiscoveryMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__ScopeDefinition *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ScopeDefinition, sizeof(enum tt__ScopeDefinition), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__ScopeDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ScopeDefinition, SOAP_TYPE_tt__ScopeDefinition, sizeof(enum tt__ScopeDefinition), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__TransportProtocol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TransportProtocol, sizeof(enum tt__TransportProtocol), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__TransportProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TransportProtocol, SOAP_TYPE_tt__TransportProtocol, sizeof(enum tt__TransportProtocol), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__StreamType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StreamType, sizeof(enum tt__StreamType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__StreamType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StreamType, SOAP_TYPE_tt__StreamType, sizeof(enum tt__StreamType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__MetadataCompressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataCompressionType, sizeof(enum tt__MetadataCompressionType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__MetadataCompressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataCompressionType, SOAP_TYPE_tt__MetadataCompressionType, sizeof(enum tt__MetadataCompressionType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__AudioEncodingMimeNames *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncodingMimeNames, sizeof(enum tt__AudioEncodingMimeNames), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__AudioEncodingMimeNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncodingMimeNames, SOAP_TYPE_tt__AudioEncodingMimeNames, sizeof(enum tt__AudioEncodingMimeNames), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__AudioEncoding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoding, sizeof(enum tt__AudioEncoding), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__AudioEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoding, SOAP_TYPE_tt__AudioEncoding, sizeof(enum tt__AudioEncoding), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__VideoEncodingProfiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncodingProfiles, sizeof(enum tt__VideoEncodingProfiles), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__VideoEncodingProfiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncodingProfiles, SOAP_TYPE_tt__VideoEncodingProfiles, sizeof(enum tt__VideoEncodingProfiles), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__VideoEncodingMimeNames *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncodingMimeNames, sizeof(enum tt__VideoEncodingMimeNames), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__VideoEncodingMimeNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncodingMimeNames, SOAP_TYPE_tt__VideoEncodingMimeNames, sizeof(enum tt__VideoEncodingMimeNames), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__H264Profile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__H264Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Profile, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__Mpeg4Profile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__Mpeg4Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Profile, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__VideoEncoding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoding, sizeof(enum tt__VideoEncoding), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__VideoEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoding, SOAP_TYPE_tt__VideoEncoding, sizeof(enum tt__VideoEncoding), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__SceneOrientationOption *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SceneOrientationOption, sizeof(enum tt__SceneOrientationOption), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__SceneOrientationOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SceneOrientationOption, SOAP_TYPE_tt__SceneOrientationOption, sizeof(enum tt__SceneOrientationOption), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__SceneOrientationMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SceneOrientationMode, sizeof(enum tt__SceneOrientationMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__SceneOrientationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SceneOrientationMode, SOAP_TYPE_tt__SceneOrientationMode, sizeof(enum tt__SceneOrientationMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tt__RotateMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateMode, sizeof(enum tt__RotateMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tt__RotateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateMode, SOAP_TYPE_tt__RotateMode, sizeof(enum tt__RotateMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum tds__StorageType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__StorageType, sizeof(enum tds__StorageType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum tds__StorageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__StorageType, SOAP_TYPE_tds__StorageType, sizeof(enum tds__StorageType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
./soapC.c:	{	soap->error = SOAP_TYPE;
./soapC.c:	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum saml2__DecisionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__DecisionType, sizeof(enum saml2__DecisionType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum saml2__DecisionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__DecisionType, SOAP_TYPE_saml2__DecisionType, sizeof(enum saml2__DecisionType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum saml1__DecisionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__DecisionType, sizeof(enum saml1__DecisionType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum saml1__DecisionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__DecisionType, SOAP_TYPE_saml1__DecisionType, sizeof(enum saml1__DecisionType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum wsc__FaultCodeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__FaultCodeType, sizeof(enum wsc__FaultCodeType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum wsc__FaultCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__FaultCodeType, SOAP_TYPE_wsc__FaultCodeType, sizeof(enum wsc__FaultCodeType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum wsse__FaultcodeEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum wsse__FaultcodeEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsse__FaultcodeEnum, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum wsu__tTimestampFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum wsu__tTimestampFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsu__tTimestampFault, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum _wsa5__IsReferenceParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum _wsa5__IsReferenceParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa5__IsReferenceParameter, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum wsa5__FaultCodesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum wsa5__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__FaultCodesType, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum wsa5__RelationshipType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum wsa5__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__RelationshipType, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum wsdd__FaultCodeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__FaultCodeType, sizeof(enum wsdd__FaultCodeType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum wsdd__FaultCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__FaultCodeType, SOAP_TYPE_wsdd__FaultCodeType, sizeof(enum wsdd__FaultCodeType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum wsa__FaultSubcodeValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__FaultSubcodeValues, sizeof(enum wsa__FaultSubcodeValues), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum wsa__FaultSubcodeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__FaultSubcodeValues, SOAP_TYPE_wsa__FaultSubcodeValues, sizeof(enum wsa__FaultSubcodeValues), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error = SOAP_TYPE;
./soapC.c:	a = (enum wsa__RelationshipTypeValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__RelationshipTypeValues, sizeof(enum wsa__RelationshipTypeValues), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:	{	a = (enum wsa__RelationshipTypeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__RelationshipTypeValues, SOAP_TYPE_wsa__RelationshipTypeValues, sizeof(enum wsa__RelationshipTypeValues), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tse__GetMetadataSearchResults && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tse__FindMetadata && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tse__EndSearch && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tse__GetSearchState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tse__GetPTZPositionSearchResults && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tse__FindPTZPosition && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tse__GetEventSearchResults && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tse__FindEvents && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tse__GetRecordingSearchResults && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tse__FindRecordings && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tse__GetMediaAttributes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tse__GetRecordingInformation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tse__GetRecordingSummary && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tse__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trv__GetReceiverState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trv__SetReceiverMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trv__ConfigureReceiver && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trv__DeleteReceiver && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trv__CreateReceiver && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trv__GetReceiver && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trv__GetReceivers && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trv__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__DeleteOSD && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__CreateOSD && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__SetOSD && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetOSDOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetOSD && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetOSDs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__SetVideoSourceMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetVideoSourceModes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetSnapshotUri && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__SetSynchronizationPoint && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__StopMulticastStreaming && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__StartMulticastStreaming && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetStreamUri && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetGuaranteedNumberOfVideoEncoderInstances && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetAudioDecoderConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetAudioOutputConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetMetadataConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetAudioEncoderConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetAudioSourceConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetVideoEncoderConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetVideoSourceConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__SetAudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__SetAudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__SetMetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__SetVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__SetAudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__SetAudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__SetVideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__SetVideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetCompatibleAudioDecoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetCompatibleAudioOutputConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetCompatibleMetadataConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetCompatibleVideoAnalyticsConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetCompatibleAudioSourceConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetCompatibleAudioEncoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetCompatibleVideoSourceConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetCompatibleVideoEncoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetAudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetAudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetMetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetAudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetAudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetVideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetVideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetAudioDecoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetAudioOutputConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetMetadataConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetVideoAnalyticsConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetAudioEncoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetAudioSourceConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetVideoEncoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetVideoSourceConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__DeleteProfile && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__RemoveAudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__RemoveAudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__RemoveMetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__RemoveVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__RemovePTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__RemoveAudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__RemoveAudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__RemoveVideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__RemoveVideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__AddAudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__AddAudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__AddMetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__AddVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__AddPTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__AddAudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__AddAudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__AddVideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__AddVideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetProfiles && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetProfile && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__CreateProfile && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetAudioOutputs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetAudioSources && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetVideoSources && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trt__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trp__SetReplayConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trp__GetReplayConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trp__GetReplayUri && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trp__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__GetExportRecordedDataState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__StopExportRecordedData && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__ExportRecordedData && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__GetRecordingJobState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__SetRecordingJobMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__GetRecordingJobConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__SetRecordingJobConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__GetRecordingJobs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__DeleteRecordingJob && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__CreateRecordingJob && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__SetTrackConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__GetTrackConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__DeleteTrack && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__CreateTrack && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__GetRecordingOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__GetRecordingConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__SetRecordingConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__GetRecordings && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__DeleteRecording && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__CreateRecording && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_trc__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__GetCompatibleConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__RemovePresetTour && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__OperatePresetTour && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__ModifyPresetTour && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__CreatePresetTour && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__GetPresetTourOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__GetPresetTour && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__GetPresetTours && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__Stop && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__AbsoluteMove && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__SendAuxiliaryCommand && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__RelativeMove && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__ContinuousMove && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__SetHomePosition && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__GotoHomePosition && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__GetConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__SetConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__GetNode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__GetNodes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__GetConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__GetStatus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__GotoPreset && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__RemovePreset && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__SetPreset && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__GetPresets && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__GetConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tptz__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__SendReceiveSerialCommand && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetSerialPortConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__SetSerialPortConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetSerialPortConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetSerialPorts && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__SetDigitalInputConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetDigitalInputConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetDigitalInputs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetRelayOutputState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__SetRelayOutputSettings && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetRelayOutputs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetAudioOutputConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetAudioSourceConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetVideoOutputConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetVideoSourceConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__SetAudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__SetAudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__SetVideoOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__SetVideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetAudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetAudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetVideoOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetVideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetVideoOutputs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetVideoSources && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetAudioOutputs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetAudioSources && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetRelayOutputOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tmd__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tls__DeletePaneConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tls__CreatePaneConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tls__SetPaneConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tls__SetPaneConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tls__GetPaneConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tls__GetPaneConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tls__GetDisplayOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tls__SetLayout && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tls__GetLayout && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tls__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_timg__SetCurrentPreset && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_timg__GetCurrentPreset && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_timg__GetPresets && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_timg__GetMoveOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_timg__GetStatus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_timg__Stop && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_timg__Move && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_timg__GetOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_timg__SetImagingSettings && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_timg__GetImagingSettings && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_timg__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsnt__ResumeSubscription && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsnt__PauseSubscription && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsnt__Unsubscribe && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsnt__Renew && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsnt__CreatePullPoint && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsnt__Notify && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsnt__DestroyPullPoint && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsnt__GetMessages && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsnt__Notify && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsnt__GetCurrentMessage && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsnt__Subscribe && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsnt__Unsubscribe && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsnt__Renew && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tev__GetEventProperties && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tev__CreatePullPointSubscription && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tev__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tev__SetSynchronizationPoint && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tev__Seek && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tev__PullMessages && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__DeleteGeoLocation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetGeoLocation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetGeoLocation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__DeleteStorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetStorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetStorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__CreateStorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetStorageConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__StartSystemRestore && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__StartFirmwareUpgrade && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetSystemUris && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__ScanAvailableDot11Networks && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDot11Status && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDot11Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__DeleteDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDot1XConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__CreateDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__LoadCACertificates && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetCertificateInformation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__LoadCertificateWithPrivateKey && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetCACertificates && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SendAuxiliaryCommand && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetRelayOutputState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetRelayOutputSettings && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetRelayOutputs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetClientCertificateMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetClientCertificateMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__LoadCertificates && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetPkcs10Request && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__DeleteCertificates && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetCertificatesStatus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetCertificatesStatus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetCertificates && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__CreateCertificate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetAccessPolicy && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetAccessPolicy && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__RemoveIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__AddIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetNetworkDefaultGateway && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetNetworkDefaultGateway && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetNetworkProtocols && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetNetworkProtocols && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetNetworkInterfaces && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetNetworkInterfaces && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetDynamicDNS && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDynamicDNS && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetNTP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetNTP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetDNS && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDNS && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetHostnameFromDHCP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetHostname && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetHostname && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetDPAddresses && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetWsdlUrl && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetUser && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__DeleteUsers && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__CreateUsers && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetUsers && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetRemoteUser && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetRemoteUser && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetEndpointReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDPAddresses && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetRemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetRemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__RemoveScopes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__AddScopes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetScopes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetScopes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetSystemSupportInformation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetSystemLog && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetSystemBackup && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__RestoreSystem && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SystemReboot && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__UpgradeSystemFirmware && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetSystemFactoryDefault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetSystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetSystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDeviceInformation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetServices && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__DeleteGeoLocation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetGeoLocation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetGeoLocation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__DeleteStorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetStorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetStorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__CreateStorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetStorageConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__StartSystemRestore && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__StartFirmwareUpgrade && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetSystemUris && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__ScanAvailableDot11Networks && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDot11Status && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDot11Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__DeleteDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDot1XConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__CreateDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__LoadCACertificates && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetCertificateInformation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__LoadCertificateWithPrivateKey && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetCACertificates && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SendAuxiliaryCommand && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetRelayOutputState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetRelayOutputSettings && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetRelayOutputs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetClientCertificateMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetClientCertificateMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__LoadCertificates && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetPkcs10Request && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__DeleteCertificates && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetCertificatesStatus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetCertificatesStatus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetCertificates && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__CreateCertificate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetAccessPolicy && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetAccessPolicy && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__RemoveIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__AddIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetNetworkDefaultGateway && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetNetworkDefaultGateway && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetNetworkProtocols && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetNetworkProtocols && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetNetworkInterfaces && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetNetworkInterfaces && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetDynamicDNS && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDynamicDNS && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetNTP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetNTP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetDNS && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDNS && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetHostnameFromDHCP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetHostname && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetHostname && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetDPAddresses && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetWsdlUrl && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetUser && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__DeleteUsers && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__CreateUsers && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetUsers && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetRemoteUser && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetRemoteUser && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetEndpointReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDPAddresses && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetRemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetRemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__RemoveScopes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__AddScopes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetScopes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetScopes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetSystemSupportInformation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetSystemLog && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetSystemBackup && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__RestoreSystem && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SystemReboot && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__UpgradeSystemFirmware && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetSystemFactoryDefault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetSystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__SetSystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetDeviceInformation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tds__GetServices && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tdn__Probe && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tdn__Probe > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tdn__Bye && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tdn__Bye > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tdn__Hello && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tdn__Hello > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tan__ModifyAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tan__GetAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tan__DeleteAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tan__CreateAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tan__GetSupportedAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tan__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tan__ModifyRules && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tan__GetRuleOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tan__GetRules && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tan__DeleteRules && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tan__CreateRules && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tan__GetSupportedRules && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tad__GetAnalyticsState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tad__DeleteAnalyticsEngineInputs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tad__CreateAnalyticsEngineInputs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tad__GetVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tad__GetAnalyticsDeviceStreamUri && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tad__GetAnalyticsEngineInputs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tad__GetAnalyticsEngineInput && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tad__SetAnalyticsEngineInput && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tad__SetVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tad__GetAnalyticsEngines && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tad__GetAnalyticsEngine && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tad__GetAnalyticsEngineControls && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tad__GetAnalyticsEngineControl && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tad__SetAnalyticsEngineControl && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tad__CreateAnalyticsEngineControl && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tad__DeleteAnalyticsEngineControl && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_tad__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__DeleteNetworkInterfaceDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetNetworkInterfaceDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__SetNetworkInterfaceDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__DeleteDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetAllDot1XConfigurations && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__AddDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetAssignedCertPathValidationPolicies && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__ReplaceCertPathValidationPolicyAssignment && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__RemoveCertPathValidationPolicyAssignment && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__AddCertPathValidationPolicyAssignment && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetClientAuthenticationRequired && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__SetClientAuthenticationRequired && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetAssignedServerCertificates && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__ReplaceServerCertificateAssignment && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__RemoveServerCertificateAssignment && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__AddServerCertificateAssignment && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__DeleteCertPathValidationPolicy && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetAllCertPathValidationPolicies && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetCertPathValidationPolicy && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__CreateCertPathValidationPolicy && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__DeleteCRL && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetAllCRLs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetCRL && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__UploadCRL && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__DeletePassphrase && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetAllPassphrases && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__UploadPassphrase && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__DeleteCertificationPath && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetAllCertificationPaths && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetCertificationPath && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__CreateCertificationPath && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__DeleteCertificate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetAllCertificates && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetCertificate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__UploadCertificate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__CreateSelfSignedCertificate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__CreatePKCS10CSR && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__DeleteKey && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetAllKeys && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetPrivateKeyStatus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetKeyStatus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__UploadCertificateWithPrivateKeyInPKCS12 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__UploadKeyPairInPKCS8 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__CreateRSAKeyPair && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns5__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns4__DoubleLockDoor && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns4__LockOpenReleaseDoor && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns4__LockOpenDoor && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns4__LockDownReleaseDoor && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns4__LockDownDoor && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns4__BlockDoor && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns4__UnlockDoor && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns4__LockDoor && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns4__AccessDoor && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns4__GetDoorState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns4__GetDoorInfo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns4__GetDoorInfoList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns4__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns2__ExternalAuthorization && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns2__DisableAccessPoint && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns2__EnableAccessPoint && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns2__GetAccessPointState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns2__GetAreaInfo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns2__GetAreaInfoList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns2__GetAccessPointInfo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns2__GetAccessPointInfoList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns2__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns1__ModifyActionTriggers && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns1__DeleteActionTriggers && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns1__CreateActionTriggers && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns1__GetActionTriggers && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns1__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns1__ModifyActions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns1__DeleteActions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns1__CreateActions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns1__GetActions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ns1__GetSupportedActions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns4__DoorInfoBase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DoorInfoBase, sizeof(struct ns4__DoorInfoBase), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns4__DoorInfoBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__DoorInfoBase, SOAP_TYPE_ns4__DoorInfoBase, sizeof(struct ns4__DoorInfoBase), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns2__AreaInfoBase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AreaInfoBase, sizeof(struct ns2__AreaInfoBase), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns2__AreaInfoBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AreaInfoBase, SOAP_TYPE_ns2__AreaInfoBase, sizeof(struct ns2__AreaInfoBase), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns2__AccessPointInfoBase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AccessPointInfoBase, sizeof(struct ns2__AccessPointInfoBase), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_AreaFrom && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_AreaTo && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_EntityType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Entity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || !a->Entity))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns2__AccessPointInfoBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AccessPointInfoBase, SOAP_TYPE_ns2__AccessPointInfoBase, sizeof(struct ns2__AccessPointInfoBase), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsrfr__ResourceUnavailableFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnavailableFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsrfr__ResourceUnavailableFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnavailableFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsrfr__ResourceUnavailableFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_Description, sizeof(struct _wsrfr__ResourceUnavailableFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnavailableFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnavailableFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsrfr__ResourceUnavailableFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType, sizeof(struct wsrfr__ResourceUnavailableFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsrfr__ResourceUnavailableFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType, sizeof(struct wsrfr__ResourceUnavailableFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsrfr__ResourceUnknownFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnknownFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsrfr__ResourceUnknownFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnknownFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsrfr__ResourceUnknownFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_Description, sizeof(struct _wsrfr__ResourceUnknownFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsrfr__ResourceUnknownFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnknownFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsrfr__ResourceUnknownFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnknownFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsrfr__ResourceUnknownFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, sizeof(struct wsrfr__ResourceUnknownFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsrfr__ResourceUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, sizeof(struct wsrfr__ResourceUnknownFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct wstop__TopicType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicType, sizeof(struct wstop__TopicType), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MessagePattern && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wstop:Topic", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wstop__TopicType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicType, SOAP_TYPE_wstop__TopicType, sizeof(struct wstop__TopicType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wstop__TopicNamespaceType_Topic *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MessagePattern && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wstop:Topic", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wstop__TopicNamespaceType_Topic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wstop__TopicNamespaceType_Topic, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct wstop__TopicNamespaceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicNamespaceType, sizeof(struct wstop__TopicNamespaceType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wstop:Topic", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wstop__TopicNamespaceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicNamespaceType, SOAP_TYPE_wstop__TopicNamespaceType, sizeof(struct wstop__TopicNamespaceType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__ResumeFailedFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__ResumeFailedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__ResumeFailedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description, sizeof(struct _wsnt__ResumeFailedFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__ResumeFailedFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__ResumeFailedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__ResumeFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(struct wsnt__ResumeFailedFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__ResumeFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__ResumeFailedFaultType, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(struct wsnt__ResumeFailedFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__PauseFailedFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__PauseFailedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__PauseFailedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_Description, sizeof(struct _wsnt__PauseFailedFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__PauseFailedFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__PauseFailedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__PauseFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(struct wsnt__PauseFailedFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__PauseFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__PauseFailedFaultType, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(struct wsnt__PauseFailedFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__UnableToDestroySubscriptionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(struct wsnt__UnableToDestroySubscriptionFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__UnableToDestroySubscriptionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(struct wsnt__UnableToDestroySubscriptionFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__UnacceptableTerminationTimeFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableTerminationTimeFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MinimumTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaximumTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0 || soap_flag_MinimumTime > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__UnacceptableTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableTerminationTimeFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__UnableToCreatePullPointFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(struct wsnt__UnableToCreatePullPointFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__UnableToCreatePullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(struct wsnt__UnableToCreatePullPointFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__UnableToDestroyPullPointFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(struct wsnt__UnableToDestroyPullPointFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__UnableToDestroyPullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(struct wsnt__UnableToDestroyPullPointFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__UnableToGetMessagesFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(struct wsnt__UnableToGetMessagesFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__UnableToGetMessagesFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(struct wsnt__UnableToGetMessagesFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__NoCurrentMessageOnTopicFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(struct wsnt__NoCurrentMessageOnTopicFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__NoCurrentMessageOnTopicFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(struct wsnt__NoCurrentMessageOnTopicFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__UnacceptableInitialTerminationTimeFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableInitialTerminationTimeFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MinimumTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaximumTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0 || soap_flag_MinimumTime > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__UnacceptableInitialTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableInitialTerminationTimeFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__NotifyMessageNotSupportedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(struct wsnt__NotifyMessageNotSupportedFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__NotifyMessageNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(struct wsnt__NotifyMessageNotSupportedFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct wsnt__UnsupportedPolicyRequestFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(struct wsnt__UnsupportedPolicyRequestFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:UnsupportedPolicy", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__UnsupportedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(struct wsnt__UnsupportedPolicyRequestFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct wsnt__UnrecognizedPolicyRequestFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:UnrecognizedPolicy", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__UnrecognizedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__InvalidMessageContentExpressionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(struct wsnt__InvalidMessageContentExpressionFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__InvalidMessageContentExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(struct wsnt__InvalidMessageContentExpressionFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__MultipleTopicsSpecifiedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__MultipleTopicsSpecifiedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__TopicNotSupportedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__TopicNotSupportedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(struct wsnt__TopicNotSupportedFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__TopicNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(struct wsnt__TopicNotSupportedFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__InvalidTopicExpressionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(struct wsnt__InvalidTopicExpressionFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__InvalidTopicExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(struct wsnt__InvalidTopicExpressionFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__TopicExpressionDialectUnknownFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__TopicExpressionDialectUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__InvalidFilterFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__InvalidFilterFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__InvalidFilterFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct wsnt__InvalidFilterFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(struct wsnt__InvalidFilterFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:UnknownFilter", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0 || a->__sizeUnknownFilter < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__InvalidFilterFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidFilterFaultType, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(struct wsnt__InvalidFilterFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__SubscribeCreationFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(struct wsnt__SubscribeCreationFailedFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__SubscribeCreationFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(struct wsnt__SubscribeCreationFailedFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct tt__OSDReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDReference, sizeof(struct tt__OSDReference), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AudioEncoder2Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoder2Configuration, sizeof(struct tt__AudioEncoder2Configuration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Encoding && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SampleRate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->Encoding || soap_flag_Bitrate > 0 || soap_flag_SampleRate > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AudioEncoder2Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoder2Configuration, SOAP_TYPE_tt__AudioEncoder2Configuration, sizeof(struct tt__AudioEncoder2Configuration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__VideoEncoder2Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoder2Configuration, sizeof(struct tt__VideoEncoder2Configuration), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Encoding && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RateControl && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Quality && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->Encoding || !a->Resolution || soap_flag_Quality > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__VideoEncoder2Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoder2Configuration, SOAP_TYPE_tt__VideoEncoder2Configuration, sizeof(struct tt__VideoEncoder2Configuration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__DeleteNetworkInterfaceDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DeleteNetworkInterfaceDot1XConfigurationResponse, sizeof(struct _ns5__DeleteNetworkInterfaceDot1XConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RebootNeeded && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__DeleteNetworkInterfaceDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DeleteNetworkInterfaceDot1XConfigurationResponse, SOAP_TYPE__ns5__DeleteNetworkInterfaceDot1XConfigurationResponse, sizeof(struct _ns5__DeleteNetworkInterfaceDot1XConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__DeleteNetworkInterfaceDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DeleteNetworkInterfaceDot1XConfiguration, sizeof(struct _ns5__DeleteNetworkInterfaceDot1XConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__DeleteNetworkInterfaceDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DeleteNetworkInterfaceDot1XConfiguration, SOAP_TYPE__ns5__DeleteNetworkInterfaceDot1XConfiguration, sizeof(struct _ns5__DeleteNetworkInterfaceDot1XConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetNetworkInterfaceDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetNetworkInterfaceDot1XConfigurationResponse, sizeof(struct _ns5__GetNetworkInterfaceDot1XConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Dot1XID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetNetworkInterfaceDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetNetworkInterfaceDot1XConfigurationResponse, SOAP_TYPE__ns5__GetNetworkInterfaceDot1XConfigurationResponse, sizeof(struct _ns5__GetNetworkInterfaceDot1XConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetNetworkInterfaceDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetNetworkInterfaceDot1XConfiguration, sizeof(struct _ns5__GetNetworkInterfaceDot1XConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__GetNetworkInterfaceDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetNetworkInterfaceDot1XConfiguration, SOAP_TYPE__ns5__GetNetworkInterfaceDot1XConfiguration, sizeof(struct _ns5__GetNetworkInterfaceDot1XConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__SetNetworkInterfaceDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__SetNetworkInterfaceDot1XConfigurationResponse, sizeof(struct _ns5__SetNetworkInterfaceDot1XConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RebootNeeded && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__SetNetworkInterfaceDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__SetNetworkInterfaceDot1XConfigurationResponse, SOAP_TYPE__ns5__SetNetworkInterfaceDot1XConfigurationResponse, sizeof(struct _ns5__SetNetworkInterfaceDot1XConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__SetNetworkInterfaceDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__SetNetworkInterfaceDot1XConfiguration, sizeof(struct _ns5__SetNetworkInterfaceDot1XConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Dot1XID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->token || !a->Dot1XID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__SetNetworkInterfaceDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__SetNetworkInterfaceDot1XConfiguration, SOAP_TYPE__ns5__SetNetworkInterfaceDot1XConfiguration, sizeof(struct _ns5__SetNetworkInterfaceDot1XConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__DeleteDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DeleteDot1XConfigurationResponse, sizeof(struct _ns5__DeleteDot1XConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__DeleteDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DeleteDot1XConfigurationResponse, SOAP_TYPE__ns5__DeleteDot1XConfigurationResponse, sizeof(struct _ns5__DeleteDot1XConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__DeleteDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DeleteDot1XConfiguration, sizeof(struct _ns5__DeleteDot1XConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Dot1XID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Dot1XID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__DeleteDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DeleteDot1XConfiguration, SOAP_TYPE__ns5__DeleteDot1XConfiguration, sizeof(struct _ns5__DeleteDot1XConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetDot1XConfigurationResponse, sizeof(struct _ns5__GetDot1XConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Dot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Dot1XConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__GetDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetDot1XConfigurationResponse, SOAP_TYPE__ns5__GetDot1XConfigurationResponse, sizeof(struct _ns5__GetDot1XConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetDot1XConfiguration, sizeof(struct _ns5__GetDot1XConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Dot1XID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Dot1XID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__GetDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetDot1XConfiguration, SOAP_TYPE__ns5__GetDot1XConfiguration, sizeof(struct _ns5__GetDot1XConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns5__GetAllDot1XConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAllDot1XConfigurationsResponse, sizeof(struct _ns5__GetAllDot1XConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:Configuration", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAllDot1XConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAllDot1XConfigurationsResponse, SOAP_TYPE__ns5__GetAllDot1XConfigurationsResponse, sizeof(struct _ns5__GetAllDot1XConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetAllDot1XConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAllDot1XConfigurations, sizeof(struct _ns5__GetAllDot1XConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAllDot1XConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAllDot1XConfigurations, SOAP_TYPE__ns5__GetAllDot1XConfigurations, sizeof(struct _ns5__GetAllDot1XConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__AddDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__AddDot1XConfigurationResponse, sizeof(struct _ns5__AddDot1XConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Dot1XID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Dot1XID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__AddDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__AddDot1XConfigurationResponse, SOAP_TYPE__ns5__AddDot1XConfigurationResponse, sizeof(struct _ns5__AddDot1XConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__AddDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__AddDot1XConfiguration, sizeof(struct _ns5__AddDot1XConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Dot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Dot1XConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__AddDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__AddDot1XConfiguration, SOAP_TYPE__ns5__AddDot1XConfiguration, sizeof(struct _ns5__AddDot1XConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetAssignedCertPathValidationPoliciesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAssignedCertPathValidationPoliciesResponse, sizeof(struct _ns5__GetAssignedCertPathValidationPoliciesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:CertPathValidationPolicyID", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAssignedCertPathValidationPoliciesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAssignedCertPathValidationPoliciesResponse, SOAP_TYPE__ns5__GetAssignedCertPathValidationPoliciesResponse, sizeof(struct _ns5__GetAssignedCertPathValidationPoliciesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetAssignedCertPathValidationPolicies *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAssignedCertPathValidationPolicies, sizeof(struct _ns5__GetAssignedCertPathValidationPolicies), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAssignedCertPathValidationPolicies *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAssignedCertPathValidationPolicies, SOAP_TYPE__ns5__GetAssignedCertPathValidationPolicies, sizeof(struct _ns5__GetAssignedCertPathValidationPolicies), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__ReplaceCertPathValidationPolicyAssignmentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__ReplaceCertPathValidationPolicyAssignmentResponse, sizeof(struct _ns5__ReplaceCertPathValidationPolicyAssignmentResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__ReplaceCertPathValidationPolicyAssignmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__ReplaceCertPathValidationPolicyAssignmentResponse, SOAP_TYPE__ns5__ReplaceCertPathValidationPolicyAssignmentResponse, sizeof(struct _ns5__ReplaceCertPathValidationPolicyAssignmentResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__ReplaceCertPathValidationPolicyAssignment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__ReplaceCertPathValidationPolicyAssignment, sizeof(struct _ns5__ReplaceCertPathValidationPolicyAssignment), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_OldCertPathValidationPolicyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_NewCertPathValidationPolicyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->OldCertPathValidationPolicyID || !a->NewCertPathValidationPolicyID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__ReplaceCertPathValidationPolicyAssignment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__ReplaceCertPathValidationPolicyAssignment, SOAP_TYPE__ns5__ReplaceCertPathValidationPolicyAssignment, sizeof(struct _ns5__ReplaceCertPathValidationPolicyAssignment), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__RemoveCertPathValidationPolicyAssignmentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__RemoveCertPathValidationPolicyAssignmentResponse, sizeof(struct _ns5__RemoveCertPathValidationPolicyAssignmentResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__RemoveCertPathValidationPolicyAssignmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__RemoveCertPathValidationPolicyAssignmentResponse, SOAP_TYPE__ns5__RemoveCertPathValidationPolicyAssignmentResponse, sizeof(struct _ns5__RemoveCertPathValidationPolicyAssignmentResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__RemoveCertPathValidationPolicyAssignment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__RemoveCertPathValidationPolicyAssignment, sizeof(struct _ns5__RemoveCertPathValidationPolicyAssignment), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertPathValidationPolicyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertPathValidationPolicyID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__RemoveCertPathValidationPolicyAssignment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__RemoveCertPathValidationPolicyAssignment, SOAP_TYPE__ns5__RemoveCertPathValidationPolicyAssignment, sizeof(struct _ns5__RemoveCertPathValidationPolicyAssignment), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__AddCertPathValidationPolicyAssignmentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__AddCertPathValidationPolicyAssignmentResponse, sizeof(struct _ns5__AddCertPathValidationPolicyAssignmentResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__AddCertPathValidationPolicyAssignmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__AddCertPathValidationPolicyAssignmentResponse, SOAP_TYPE__ns5__AddCertPathValidationPolicyAssignmentResponse, sizeof(struct _ns5__AddCertPathValidationPolicyAssignmentResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__AddCertPathValidationPolicyAssignment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__AddCertPathValidationPolicyAssignment, sizeof(struct _ns5__AddCertPathValidationPolicyAssignment), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertPathValidationPolicyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertPathValidationPolicyID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__AddCertPathValidationPolicyAssignment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__AddCertPathValidationPolicyAssignment, SOAP_TYPE__ns5__AddCertPathValidationPolicyAssignment, sizeof(struct _ns5__AddCertPathValidationPolicyAssignment), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetClientAuthenticationRequiredResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetClientAuthenticationRequiredResponse, sizeof(struct _ns5__GetClientAuthenticationRequiredResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_clientAuthenticationRequired && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_clientAuthenticationRequired > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__GetClientAuthenticationRequiredResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetClientAuthenticationRequiredResponse, SOAP_TYPE__ns5__GetClientAuthenticationRequiredResponse, sizeof(struct _ns5__GetClientAuthenticationRequiredResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetClientAuthenticationRequired *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetClientAuthenticationRequired, sizeof(struct _ns5__GetClientAuthenticationRequired), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetClientAuthenticationRequired *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetClientAuthenticationRequired, SOAP_TYPE__ns5__GetClientAuthenticationRequired, sizeof(struct _ns5__GetClientAuthenticationRequired), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__SetClientAuthenticationRequiredResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__SetClientAuthenticationRequiredResponse, sizeof(struct _ns5__SetClientAuthenticationRequiredResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__SetClientAuthenticationRequiredResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__SetClientAuthenticationRequiredResponse, SOAP_TYPE__ns5__SetClientAuthenticationRequiredResponse, sizeof(struct _ns5__SetClientAuthenticationRequiredResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__SetClientAuthenticationRequired *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__SetClientAuthenticationRequired, sizeof(struct _ns5__SetClientAuthenticationRequired), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_clientAuthenticationRequired && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_clientAuthenticationRequired > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__SetClientAuthenticationRequired *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__SetClientAuthenticationRequired, SOAP_TYPE__ns5__SetClientAuthenticationRequired, sizeof(struct _ns5__SetClientAuthenticationRequired), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__DeleteCertPathValidationPolicyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DeleteCertPathValidationPolicyResponse, sizeof(struct _ns5__DeleteCertPathValidationPolicyResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__DeleteCertPathValidationPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DeleteCertPathValidationPolicyResponse, SOAP_TYPE__ns5__DeleteCertPathValidationPolicyResponse, sizeof(struct _ns5__DeleteCertPathValidationPolicyResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__DeleteCertPathValidationPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DeleteCertPathValidationPolicy, sizeof(struct _ns5__DeleteCertPathValidationPolicy), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertPathValidationPolicyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertPathValidationPolicyID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__DeleteCertPathValidationPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DeleteCertPathValidationPolicy, SOAP_TYPE__ns5__DeleteCertPathValidationPolicy, sizeof(struct _ns5__DeleteCertPathValidationPolicy), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns5__GetAllCertPathValidationPoliciesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAllCertPathValidationPoliciesResponse, sizeof(struct _ns5__GetAllCertPathValidationPoliciesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:CertPathValidationPolicy", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAllCertPathValidationPoliciesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAllCertPathValidationPoliciesResponse, SOAP_TYPE__ns5__GetAllCertPathValidationPoliciesResponse, sizeof(struct _ns5__GetAllCertPathValidationPoliciesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetAllCertPathValidationPolicies *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAllCertPathValidationPolicies, sizeof(struct _ns5__GetAllCertPathValidationPolicies), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAllCertPathValidationPolicies *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAllCertPathValidationPolicies, SOAP_TYPE__ns5__GetAllCertPathValidationPolicies, sizeof(struct _ns5__GetAllCertPathValidationPolicies), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetCertPathValidationPolicyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetCertPathValidationPolicyResponse, sizeof(struct _ns5__GetCertPathValidationPolicyResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertPathValidationPolicy && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertPathValidationPolicy))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__GetCertPathValidationPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetCertPathValidationPolicyResponse, SOAP_TYPE__ns5__GetCertPathValidationPolicyResponse, sizeof(struct _ns5__GetCertPathValidationPolicyResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetCertPathValidationPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetCertPathValidationPolicy, sizeof(struct _ns5__GetCertPathValidationPolicy), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertPathValidationPolicyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertPathValidationPolicyID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__GetCertPathValidationPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetCertPathValidationPolicy, SOAP_TYPE__ns5__GetCertPathValidationPolicy, sizeof(struct _ns5__GetCertPathValidationPolicy), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__CreateCertPathValidationPolicyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__CreateCertPathValidationPolicyResponse, sizeof(struct _ns5__CreateCertPathValidationPolicyResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertPathValidationPolicyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertPathValidationPolicyID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__CreateCertPathValidationPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__CreateCertPathValidationPolicyResponse, SOAP_TYPE__ns5__CreateCertPathValidationPolicyResponse, sizeof(struct _ns5__CreateCertPathValidationPolicyResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns5__CreateCertPathValidationPolicy_anyParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__CreateCertPathValidationPolicy_anyParameters, sizeof(struct _ns5__CreateCertPathValidationPolicy_anyParameters), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__CreateCertPathValidationPolicy_anyParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__CreateCertPathValidationPolicy_anyParameters, SOAP_TYPE__ns5__CreateCertPathValidationPolicy_anyParameters, sizeof(struct _ns5__CreateCertPathValidationPolicy_anyParameters), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__CreateCertPathValidationPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__CreateCertPathValidationPolicy, sizeof(struct _ns5__CreateCertPathValidationPolicy), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Parameters && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:TrustAnchor", 1, NULL))
./soapC.c:			if (soap_flag_anyParameters && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Parameters || a->__sizeTrustAnchor < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__CreateCertPathValidationPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__CreateCertPathValidationPolicy, SOAP_TYPE__ns5__CreateCertPathValidationPolicy, sizeof(struct _ns5__CreateCertPathValidationPolicy), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__DeleteCRLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DeleteCRLResponse, sizeof(struct _ns5__DeleteCRLResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__DeleteCRLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DeleteCRLResponse, SOAP_TYPE__ns5__DeleteCRLResponse, sizeof(struct _ns5__DeleteCRLResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__DeleteCRL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DeleteCRL, sizeof(struct _ns5__DeleteCRL), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CrlID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CrlID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__DeleteCRL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DeleteCRL, SOAP_TYPE__ns5__DeleteCRL, sizeof(struct _ns5__DeleteCRL), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns5__GetAllCRLsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAllCRLsResponse, sizeof(struct _ns5__GetAllCRLsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:Crl", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAllCRLsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAllCRLsResponse, SOAP_TYPE__ns5__GetAllCRLsResponse, sizeof(struct _ns5__GetAllCRLsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetAllCRLs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAllCRLs, sizeof(struct _ns5__GetAllCRLs), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAllCRLs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAllCRLs, SOAP_TYPE__ns5__GetAllCRLs, sizeof(struct _ns5__GetAllCRLs), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetCRLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetCRLResponse, sizeof(struct _ns5__GetCRLResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Crl && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Crl))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__GetCRLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetCRLResponse, SOAP_TYPE__ns5__GetCRLResponse, sizeof(struct _ns5__GetCRLResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetCRL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetCRL, sizeof(struct _ns5__GetCRL), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CrlID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CrlID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__GetCRL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetCRL, SOAP_TYPE__ns5__GetCRL, sizeof(struct _ns5__GetCRL), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__UploadCRLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__UploadCRLResponse, sizeof(struct _ns5__UploadCRLResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CrlID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CrlID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__UploadCRLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__UploadCRLResponse, SOAP_TYPE__ns5__UploadCRLResponse, sizeof(struct _ns5__UploadCRLResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns5__UploadCRL_anyParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__UploadCRL_anyParameters, sizeof(struct _ns5__UploadCRL_anyParameters), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__UploadCRL_anyParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__UploadCRL_anyParameters, SOAP_TYPE__ns5__UploadCRL_anyParameters, sizeof(struct _ns5__UploadCRL_anyParameters), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__UploadCRL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__UploadCRL, sizeof(struct _ns5__UploadCRL), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Crl && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_anyParameters && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Crl > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__UploadCRL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__UploadCRL, SOAP_TYPE__ns5__UploadCRL, sizeof(struct _ns5__UploadCRL), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetAssignedServerCertificatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAssignedServerCertificatesResponse, sizeof(struct _ns5__GetAssignedServerCertificatesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:CertificationPathID", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAssignedServerCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAssignedServerCertificatesResponse, SOAP_TYPE__ns5__GetAssignedServerCertificatesResponse, sizeof(struct _ns5__GetAssignedServerCertificatesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetAssignedServerCertificates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAssignedServerCertificates, sizeof(struct _ns5__GetAssignedServerCertificates), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAssignedServerCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAssignedServerCertificates, SOAP_TYPE__ns5__GetAssignedServerCertificates, sizeof(struct _ns5__GetAssignedServerCertificates), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__ReplaceServerCertificateAssignmentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__ReplaceServerCertificateAssignmentResponse, sizeof(struct _ns5__ReplaceServerCertificateAssignmentResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__ReplaceServerCertificateAssignmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__ReplaceServerCertificateAssignmentResponse, SOAP_TYPE__ns5__ReplaceServerCertificateAssignmentResponse, sizeof(struct _ns5__ReplaceServerCertificateAssignmentResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__ReplaceServerCertificateAssignment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__ReplaceServerCertificateAssignment, sizeof(struct _ns5__ReplaceServerCertificateAssignment), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_OldCertificationPathID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_NewCertificationPathID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->OldCertificationPathID || !a->NewCertificationPathID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__ReplaceServerCertificateAssignment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__ReplaceServerCertificateAssignment, SOAP_TYPE__ns5__ReplaceServerCertificateAssignment, sizeof(struct _ns5__ReplaceServerCertificateAssignment), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__RemoveServerCertificateAssignmentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__RemoveServerCertificateAssignmentResponse, sizeof(struct _ns5__RemoveServerCertificateAssignmentResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__RemoveServerCertificateAssignmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__RemoveServerCertificateAssignmentResponse, SOAP_TYPE__ns5__RemoveServerCertificateAssignmentResponse, sizeof(struct _ns5__RemoveServerCertificateAssignmentResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__RemoveServerCertificateAssignment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__RemoveServerCertificateAssignment, sizeof(struct _ns5__RemoveServerCertificateAssignment), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificationPathID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificationPathID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__RemoveServerCertificateAssignment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__RemoveServerCertificateAssignment, SOAP_TYPE__ns5__RemoveServerCertificateAssignment, sizeof(struct _ns5__RemoveServerCertificateAssignment), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__AddServerCertificateAssignmentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__AddServerCertificateAssignmentResponse, sizeof(struct _ns5__AddServerCertificateAssignmentResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__AddServerCertificateAssignmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__AddServerCertificateAssignmentResponse, SOAP_TYPE__ns5__AddServerCertificateAssignmentResponse, sizeof(struct _ns5__AddServerCertificateAssignmentResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__AddServerCertificateAssignment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__AddServerCertificateAssignment, sizeof(struct _ns5__AddServerCertificateAssignment), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificationPathID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificationPathID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__AddServerCertificateAssignment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__AddServerCertificateAssignment, SOAP_TYPE__ns5__AddServerCertificateAssignment, sizeof(struct _ns5__AddServerCertificateAssignment), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__DeletePassphraseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DeletePassphraseResponse, sizeof(struct _ns5__DeletePassphraseResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__DeletePassphraseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DeletePassphraseResponse, SOAP_TYPE__ns5__DeletePassphraseResponse, sizeof(struct _ns5__DeletePassphraseResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__DeletePassphrase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DeletePassphrase, sizeof(struct _ns5__DeletePassphrase), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PassphraseID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PassphraseID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__DeletePassphrase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DeletePassphrase, SOAP_TYPE__ns5__DeletePassphrase, sizeof(struct _ns5__DeletePassphrase), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns5__GetAllPassphrasesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAllPassphrasesResponse, sizeof(struct _ns5__GetAllPassphrasesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:PassphraseAttribute", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAllPassphrasesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAllPassphrasesResponse, SOAP_TYPE__ns5__GetAllPassphrasesResponse, sizeof(struct _ns5__GetAllPassphrasesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetAllPassphrases *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAllPassphrases, sizeof(struct _ns5__GetAllPassphrases), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAllPassphrases *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAllPassphrases, SOAP_TYPE__ns5__GetAllPassphrases, sizeof(struct _ns5__GetAllPassphrases), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__UploadPassphraseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__UploadPassphraseResponse, sizeof(struct _ns5__UploadPassphraseResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PassphraseID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PassphraseID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__UploadPassphraseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__UploadPassphraseResponse, SOAP_TYPE__ns5__UploadPassphraseResponse, sizeof(struct _ns5__UploadPassphraseResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__UploadPassphrase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__UploadPassphrase, sizeof(struct _ns5__UploadPassphrase), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Passphrase && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PassphraseAlias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Passphrase))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__UploadPassphrase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__UploadPassphrase, SOAP_TYPE__ns5__UploadPassphrase, sizeof(struct _ns5__UploadPassphrase), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__DeleteCertificationPathResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DeleteCertificationPathResponse, sizeof(struct _ns5__DeleteCertificationPathResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__DeleteCertificationPathResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DeleteCertificationPathResponse, SOAP_TYPE__ns5__DeleteCertificationPathResponse, sizeof(struct _ns5__DeleteCertificationPathResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__DeleteCertificationPath *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DeleteCertificationPath, sizeof(struct _ns5__DeleteCertificationPath), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificationPathID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificationPathID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__DeleteCertificationPath *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DeleteCertificationPath, SOAP_TYPE__ns5__DeleteCertificationPath, sizeof(struct _ns5__DeleteCertificationPath), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetAllCertificationPathsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAllCertificationPathsResponse, sizeof(struct _ns5__GetAllCertificationPathsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:CertificationPathID", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAllCertificationPathsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAllCertificationPathsResponse, SOAP_TYPE__ns5__GetAllCertificationPathsResponse, sizeof(struct _ns5__GetAllCertificationPathsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetAllCertificationPaths *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAllCertificationPaths, sizeof(struct _ns5__GetAllCertificationPaths), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAllCertificationPaths *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAllCertificationPaths, SOAP_TYPE__ns5__GetAllCertificationPaths, sizeof(struct _ns5__GetAllCertificationPaths), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetCertificationPathResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetCertificationPathResponse, sizeof(struct _ns5__GetCertificationPathResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificationPath && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificationPath))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__GetCertificationPathResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetCertificationPathResponse, SOAP_TYPE__ns5__GetCertificationPathResponse, sizeof(struct _ns5__GetCertificationPathResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetCertificationPath *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetCertificationPath, sizeof(struct _ns5__GetCertificationPath), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificationPathID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificationPathID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__GetCertificationPath *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetCertificationPath, SOAP_TYPE__ns5__GetCertificationPath, sizeof(struct _ns5__GetCertificationPath), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__CreateCertificationPathResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__CreateCertificationPathResponse, sizeof(struct _ns5__CreateCertificationPathResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificationPathID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificationPathID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__CreateCertificationPathResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__CreateCertificationPathResponse, SOAP_TYPE__ns5__CreateCertificationPathResponse, sizeof(struct _ns5__CreateCertificationPathResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__CreateCertificationPath *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__CreateCertificationPath, sizeof(struct _ns5__CreateCertificationPath), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificateIDs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateIDs))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__CreateCertificationPath *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__CreateCertificationPath, SOAP_TYPE__ns5__CreateCertificationPath, sizeof(struct _ns5__CreateCertificationPath), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__DeleteCertificateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DeleteCertificateResponse, sizeof(struct _ns5__DeleteCertificateResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__DeleteCertificateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DeleteCertificateResponse, SOAP_TYPE__ns5__DeleteCertificateResponse, sizeof(struct _ns5__DeleteCertificateResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__DeleteCertificate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DeleteCertificate, sizeof(struct _ns5__DeleteCertificate), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__DeleteCertificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DeleteCertificate, SOAP_TYPE__ns5__DeleteCertificate, sizeof(struct _ns5__DeleteCertificate), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns5__GetAllCertificatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAllCertificatesResponse, sizeof(struct _ns5__GetAllCertificatesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:Certificate", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAllCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAllCertificatesResponse, SOAP_TYPE__ns5__GetAllCertificatesResponse, sizeof(struct _ns5__GetAllCertificatesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetAllCertificates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAllCertificates, sizeof(struct _ns5__GetAllCertificates), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAllCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAllCertificates, SOAP_TYPE__ns5__GetAllCertificates, sizeof(struct _ns5__GetAllCertificates), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetCertificateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetCertificateResponse, sizeof(struct _ns5__GetCertificateResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Certificate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Certificate))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__GetCertificateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetCertificateResponse, SOAP_TYPE__ns5__GetCertificateResponse, sizeof(struct _ns5__GetCertificateResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetCertificate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetCertificate, sizeof(struct _ns5__GetCertificate), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__GetCertificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetCertificate, SOAP_TYPE__ns5__GetCertificate, sizeof(struct _ns5__GetCertificate), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__UploadCertificateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__UploadCertificateResponse, sizeof(struct _ns5__UploadCertificateResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_KeyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID || !a->KeyID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__UploadCertificateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__UploadCertificateResponse, SOAP_TYPE__ns5__UploadCertificateResponse, sizeof(struct _ns5__UploadCertificateResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__UploadCertificate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__UploadCertificate, sizeof(struct _ns5__UploadCertificate), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Certificate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_KeyAlias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PrivateKeyRequired && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Certificate > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__UploadCertificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__UploadCertificate, SOAP_TYPE__ns5__UploadCertificate, sizeof(struct _ns5__UploadCertificate), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__CreateSelfSignedCertificateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__CreateSelfSignedCertificateResponse, sizeof(struct _ns5__CreateSelfSignedCertificateResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__CreateSelfSignedCertificateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__CreateSelfSignedCertificateResponse, SOAP_TYPE__ns5__CreateSelfSignedCertificateResponse, sizeof(struct _ns5__CreateSelfSignedCertificateResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns5__CreateSelfSignedCertificate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__CreateSelfSignedCertificate, sizeof(struct _ns5__CreateSelfSignedCertificate), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_X509Version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Subject && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_KeyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_notValidBefore && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_notValidAfter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SignatureAlgorithm && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:Extension", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Subject || !a->KeyID || !a->SignatureAlgorithm))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__CreateSelfSignedCertificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__CreateSelfSignedCertificate, SOAP_TYPE__ns5__CreateSelfSignedCertificate, sizeof(struct _ns5__CreateSelfSignedCertificate), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__CreatePKCS10CSRResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__CreatePKCS10CSRResponse, sizeof(struct _ns5__CreatePKCS10CSRResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PKCS10CSR && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PKCS10CSR > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__CreatePKCS10CSRResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__CreatePKCS10CSRResponse, SOAP_TYPE__ns5__CreatePKCS10CSRResponse, sizeof(struct _ns5__CreatePKCS10CSRResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__CreatePKCS10CSR *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__CreatePKCS10CSR, sizeof(struct _ns5__CreatePKCS10CSR), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Subject && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_KeyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:CSRAttribute", 1, NULL))
./soapC.c:			if (soap_flag_SignatureAlgorithm && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Subject || !a->KeyID || !a->SignatureAlgorithm))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__CreatePKCS10CSR *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__CreatePKCS10CSR, SOAP_TYPE__ns5__CreatePKCS10CSR, sizeof(struct _ns5__CreatePKCS10CSR), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__DeleteKeyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DeleteKeyResponse, sizeof(struct _ns5__DeleteKeyResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__DeleteKeyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DeleteKeyResponse, SOAP_TYPE__ns5__DeleteKeyResponse, sizeof(struct _ns5__DeleteKeyResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__DeleteKey *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DeleteKey, sizeof(struct _ns5__DeleteKey), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_KeyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->KeyID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__DeleteKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DeleteKey, SOAP_TYPE__ns5__DeleteKey, sizeof(struct _ns5__DeleteKey), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns5__GetAllKeysResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAllKeysResponse, sizeof(struct _ns5__GetAllKeysResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:KeyAttribute", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAllKeysResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAllKeysResponse, SOAP_TYPE__ns5__GetAllKeysResponse, sizeof(struct _ns5__GetAllKeysResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetAllKeys *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetAllKeys, sizeof(struct _ns5__GetAllKeys), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetAllKeys *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetAllKeys, SOAP_TYPE__ns5__GetAllKeys, sizeof(struct _ns5__GetAllKeys), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetPrivateKeyStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetPrivateKeyStatusResponse, sizeof(struct _ns5__GetPrivateKeyStatusResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_hasPrivateKey && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_hasPrivateKey > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__GetPrivateKeyStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetPrivateKeyStatusResponse, SOAP_TYPE__ns5__GetPrivateKeyStatusResponse, sizeof(struct _ns5__GetPrivateKeyStatusResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetPrivateKeyStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetPrivateKeyStatus, sizeof(struct _ns5__GetPrivateKeyStatus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_KeyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->KeyID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__GetPrivateKeyStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetPrivateKeyStatus, SOAP_TYPE__ns5__GetPrivateKeyStatus, sizeof(struct _ns5__GetPrivateKeyStatus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetKeyStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetKeyStatusResponse, sizeof(struct _ns5__GetKeyStatusResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_KeyStatus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->KeyStatus))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__GetKeyStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetKeyStatusResponse, SOAP_TYPE__ns5__GetKeyStatusResponse, sizeof(struct _ns5__GetKeyStatusResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetKeyStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetKeyStatus, sizeof(struct _ns5__GetKeyStatus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_KeyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->KeyID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__GetKeyStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetKeyStatus, SOAP_TYPE__ns5__GetKeyStatus, sizeof(struct _ns5__GetKeyStatus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__UploadCertificateWithPrivateKeyInPKCS12Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__UploadCertificateWithPrivateKeyInPKCS12Response, sizeof(struct _ns5__UploadCertificateWithPrivateKeyInPKCS12Response), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificationPathID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_KeyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificationPathID || !a->KeyID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__UploadCertificateWithPrivateKeyInPKCS12Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__UploadCertificateWithPrivateKeyInPKCS12Response, SOAP_TYPE__ns5__UploadCertificateWithPrivateKeyInPKCS12Response, sizeof(struct _ns5__UploadCertificateWithPrivateKeyInPKCS12Response), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__UploadCertificateWithPrivateKeyInPKCS12 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__UploadCertificateWithPrivateKeyInPKCS12, sizeof(struct _ns5__UploadCertificateWithPrivateKeyInPKCS12), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertWithPrivateKey && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CertificationPathAlias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_KeyAlias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_IgnoreAdditionalCertificates && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_IntegrityPassphraseID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_EncryptionPassphraseID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Passphrase && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertWithPrivateKey > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__UploadCertificateWithPrivateKeyInPKCS12 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__UploadCertificateWithPrivateKeyInPKCS12, SOAP_TYPE__ns5__UploadCertificateWithPrivateKeyInPKCS12, sizeof(struct _ns5__UploadCertificateWithPrivateKeyInPKCS12), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__UploadKeyPairInPKCS8Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__UploadKeyPairInPKCS8Response, sizeof(struct _ns5__UploadKeyPairInPKCS8Response), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_KeyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->KeyID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__UploadKeyPairInPKCS8Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__UploadKeyPairInPKCS8Response, SOAP_TYPE__ns5__UploadKeyPairInPKCS8Response, sizeof(struct _ns5__UploadKeyPairInPKCS8Response), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__UploadKeyPairInPKCS8 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__UploadKeyPairInPKCS8, sizeof(struct _ns5__UploadKeyPairInPKCS8), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_KeyPair && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_EncryptionPassphraseID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_EncryptionPassphrase && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_KeyPair > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__UploadKeyPairInPKCS8 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__UploadKeyPairInPKCS8, SOAP_TYPE__ns5__UploadKeyPairInPKCS8, sizeof(struct _ns5__UploadKeyPairInPKCS8), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__CreateRSAKeyPairResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__CreateRSAKeyPairResponse, sizeof(struct _ns5__CreateRSAKeyPairResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_KeyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_EstimatedCreationTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->KeyID || soap_flag_EstimatedCreationTime > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__CreateRSAKeyPairResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__CreateRSAKeyPairResponse, SOAP_TYPE__ns5__CreateRSAKeyPairResponse, sizeof(struct _ns5__CreateRSAKeyPairResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__CreateRSAKeyPair *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__CreateRSAKeyPair, sizeof(struct _ns5__CreateRSAKeyPair), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_KeyLength && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->KeyLength))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__CreateRSAKeyPair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__CreateRSAKeyPair, SOAP_TYPE__ns5__CreateRSAKeyPair, sizeof(struct _ns5__CreateRSAKeyPair), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetServiceCapabilitiesResponse, sizeof(struct _ns5__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns5__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetServiceCapabilitiesResponse, SOAP_TYPE__ns5__GetServiceCapabilitiesResponse, sizeof(struct _ns5__GetServiceCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns5__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetServiceCapabilities, sizeof(struct _ns5__GetServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetServiceCapabilities, SOAP_TYPE__ns5__GetServiceCapabilities, sizeof(struct _ns5__GetServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns5__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Capabilities, sizeof(struct ns5__Capabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_KeystoreCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_TLSServerCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Dot1XCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->KeystoreCapabilities || !a->TLSServerCapabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns5__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Capabilities, SOAP_TYPE_ns5__Capabilities, sizeof(struct ns5__Capabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns5__TLSServerCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__TLSServerCapabilities, sizeof(struct ns5__TLSServerCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns5__TLSServerCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__TLSServerCapabilities, SOAP_TYPE_ns5__TLSServerCapabilities, sizeof(struct ns5__TLSServerCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns5__KeystoreCapabilities_anyElement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__KeystoreCapabilities_anyElement, sizeof(struct _ns5__KeystoreCapabilities_anyElement), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__KeystoreCapabilities_anyElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__KeystoreCapabilities_anyElement, SOAP_TYPE__ns5__KeystoreCapabilities_anyElement, sizeof(struct _ns5__KeystoreCapabilities_anyElement), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns5__KeystoreCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__KeystoreCapabilities, sizeof(struct ns5__KeystoreCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:SignatureAlgorithms", 1, NULL))
./soapC.c:			if (soap_flag_anyElement && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns5__KeystoreCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__KeystoreCapabilities, SOAP_TYPE_ns5__KeystoreCapabilities, sizeof(struct ns5__KeystoreCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns5__CertPathValidationPolicy_anyParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__CertPathValidationPolicy_anyParameters, sizeof(struct _ns5__CertPathValidationPolicy_anyParameters), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__CertPathValidationPolicy_anyParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__CertPathValidationPolicy_anyParameters, SOAP_TYPE__ns5__CertPathValidationPolicy_anyParameters, sizeof(struct _ns5__CertPathValidationPolicy_anyParameters), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns5__CertPathValidationPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CertPathValidationPolicy, sizeof(struct ns5__CertPathValidationPolicy), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertPathValidationPolicyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Parameters && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:TrustAnchor", 1, NULL))
./soapC.c:			if (soap_flag_anyParameters && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertPathValidationPolicyID || !a->Parameters || a->__sizeTrustAnchor < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns5__CertPathValidationPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CertPathValidationPolicy, SOAP_TYPE_ns5__CertPathValidationPolicy, sizeof(struct ns5__CertPathValidationPolicy), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns5__TrustAnchor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__TrustAnchor, sizeof(struct ns5__TrustAnchor), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns5__TrustAnchor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__TrustAnchor, SOAP_TYPE_ns5__TrustAnchor, sizeof(struct ns5__TrustAnchor), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns5__CertPathValidationParameters_anyParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__CertPathValidationParameters_anyParameters, sizeof(struct _ns5__CertPathValidationParameters_anyParameters), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__CertPathValidationParameters_anyParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__CertPathValidationParameters_anyParameters, SOAP_TYPE__ns5__CertPathValidationParameters_anyParameters, sizeof(struct _ns5__CertPathValidationParameters_anyParameters), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns5__CertPathValidationParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CertPathValidationParameters, sizeof(struct ns5__CertPathValidationParameters), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RequireTLSWWWClientAuthExtendedKeyUsage && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_UseDeltaCRLs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_anyParameters && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns5__CertPathValidationParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CertPathValidationParameters, SOAP_TYPE_ns5__CertPathValidationParameters, sizeof(struct ns5__CertPathValidationParameters), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns5__CRL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CRL, sizeof(struct ns5__CRL), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CRLID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_CRLContent && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CRLID || !a->Alias || soap_flag_CRLContent > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns5__CRL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CRL, SOAP_TYPE_ns5__CRL, sizeof(struct ns5__CRL), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns5__Dot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Dot1XConfiguration, sizeof(struct ns5__Dot1XConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Dot1XID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Outer && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Outer))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns5__Dot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Dot1XConfiguration, SOAP_TYPE_ns5__Dot1XConfiguration, sizeof(struct ns5__Dot1XConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns5__Dot1XStageExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Dot1XStageExtension, sizeof(struct ns5__Dot1XStageExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns5__Dot1XStageExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Dot1XStageExtension, SOAP_TYPE_ns5__Dot1XStageExtension, sizeof(struct ns5__Dot1XStageExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns5__Dot1XStage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Dot1XStage, sizeof(struct ns5__Dot1XStage), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Identity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_CertificationPathID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PassphraseID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Inner && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns5__Dot1XStage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Dot1XStage, SOAP_TYPE_ns5__Dot1XStage, sizeof(struct ns5__Dot1XStage), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns5__Dot1XCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Dot1XCapabilities, sizeof(struct ns5__Dot1XCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns5__Dot1XCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Dot1XCapabilities, SOAP_TYPE_ns5__Dot1XCapabilities, sizeof(struct ns5__Dot1XCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns5__PassphraseAttribute *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__PassphraseAttribute, sizeof(struct ns5__PassphraseAttribute), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PassphraseID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PassphraseID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns5__PassphraseAttribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__PassphraseAttribute, SOAP_TYPE_ns5__PassphraseAttribute, sizeof(struct ns5__PassphraseAttribute), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns5__CertificationPath_anyElement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__CertificationPath_anyElement, sizeof(struct _ns5__CertificationPath_anyElement), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__CertificationPath_anyElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__CertificationPath_anyElement, SOAP_TYPE__ns5__CertificationPath_anyElement, sizeof(struct _ns5__CertificationPath_anyElement), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns5__CertificationPath *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CertificationPath, sizeof(struct ns5__CertificationPath), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:CertificateID", 1, NULL))
./soapC.c:			if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_anyElement && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeCertificateID < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns5__CertificationPath *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CertificationPath, SOAP_TYPE_ns5__CertificationPath, sizeof(struct ns5__CertificationPath), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns5__CertificateIDs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CertificateIDs, sizeof(struct ns5__CertificateIDs), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:CertificateID", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeCertificateID < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns5__CertificateIDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CertificateIDs, SOAP_TYPE_ns5__CertificateIDs, sizeof(struct ns5__CertificateIDs), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns5__X509Certificate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__X509Certificate, sizeof(struct ns5__X509Certificate), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_KeyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_CertificateContent && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID || !a->KeyID || soap_flag_CertificateContent > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns5__X509Certificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__X509Certificate, SOAP_TYPE_ns5__X509Certificate, sizeof(struct ns5__X509Certificate), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns5__CSRAttribute_anyAttribute *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__CSRAttribute_anyAttribute, sizeof(struct _ns5__CSRAttribute_anyAttribute), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__CSRAttribute_anyAttribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__CSRAttribute_anyAttribute, SOAP_TYPE__ns5__CSRAttribute_anyAttribute, sizeof(struct _ns5__CSRAttribute_anyAttribute), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns5__X509v3Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__X509v3Extension, sizeof(struct ns5__X509v3Extension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_extnOID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_critical && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_extnValue && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->extnOID || soap_flag_extnValue > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns5__X509v3Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__X509v3Extension, SOAP_TYPE_ns5__X509v3Extension, sizeof(struct ns5__X509v3Extension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns5__CSRAttribute *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CSRAttribute, sizeof(struct ns5__CSRAttribute), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_union_CSRAttribute && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns5__CSRAttribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CSRAttribute, SOAP_TYPE_ns5__CSRAttribute, sizeof(struct ns5__CSRAttribute), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns5__BasicRequestAttribute *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__BasicRequestAttribute, sizeof(struct ns5__BasicRequestAttribute), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_OID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->OID || soap_flag_value > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns5__BasicRequestAttribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__BasicRequestAttribute, SOAP_TYPE_ns5__BasicRequestAttribute, sizeof(struct ns5__BasicRequestAttribute), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns5__AlgorithmIdentifier_anyParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__AlgorithmIdentifier_anyParameters, sizeof(struct _ns5__AlgorithmIdentifier_anyParameters), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__AlgorithmIdentifier_anyParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__AlgorithmIdentifier_anyParameters, SOAP_TYPE__ns5__AlgorithmIdentifier_anyParameters, sizeof(struct _ns5__AlgorithmIdentifier_anyParameters), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns5__AlgorithmIdentifier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__AlgorithmIdentifier, sizeof(struct ns5__AlgorithmIdentifier), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_algorithm && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_parameters && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_anyParameters && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->algorithm))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns5__AlgorithmIdentifier *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__AlgorithmIdentifier, SOAP_TYPE_ns5__AlgorithmIdentifier, sizeof(struct ns5__AlgorithmIdentifier), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns5__DistinguishedName_anyAttribute *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DistinguishedName_anyAttribute, sizeof(struct _ns5__DistinguishedName_anyAttribute), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__DistinguishedName_anyAttribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DistinguishedName_anyAttribute, SOAP_TYPE__ns5__DistinguishedName_anyAttribute, sizeof(struct _ns5__DistinguishedName_anyAttribute), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns5__DistinguishedName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__DistinguishedName, sizeof(struct ns5__DistinguishedName), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:Country", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:Organization", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:OrganizationalUnit", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:DistinguishedNameQualifier", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:StateOrProvinceName", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:CommonName", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:SerialNumber", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:Locality", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:Title", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:Surname", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:GivenName", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:Initials", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:Pseudonym", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:GenerationQualifier", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:GenericAttribute", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:MultiValuedRDN", 1, NULL))
./soapC.c:			if (soap_flag_anyAttribute && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns5__DistinguishedName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__DistinguishedName, SOAP_TYPE_ns5__DistinguishedName, sizeof(struct ns5__DistinguishedName), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns5__MultiValuedRDN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__MultiValuedRDN, sizeof(struct ns5__MultiValuedRDN), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:Attribute", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns5__MultiValuedRDN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__MultiValuedRDN, SOAP_TYPE_ns5__MultiValuedRDN, sizeof(struct ns5__MultiValuedRDN), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns5__DNAttributeTypeAndValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__DNAttributeTypeAndValue, sizeof(struct ns5__DNAttributeTypeAndValue), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Type || !a->Value))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns5__DNAttributeTypeAndValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__DNAttributeTypeAndValue, SOAP_TYPE_ns5__DNAttributeTypeAndValue, sizeof(struct ns5__DNAttributeTypeAndValue), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns5__KeyAttribute_Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__KeyAttribute_Extension, sizeof(struct _ns5__KeyAttribute_Extension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns5__KeyAttribute_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__KeyAttribute_Extension, SOAP_TYPE__ns5__KeyAttribute_Extension, sizeof(struct _ns5__KeyAttribute_Extension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns5__KeyAttribute *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__KeyAttribute, sizeof(struct ns5__KeyAttribute), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_KeyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_hasPrivateKey && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_KeyStatus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_externallyGenerated && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_securelyStored && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->KeyID || !a->KeyStatus))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns5__KeyAttribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__KeyAttribute, SOAP_TYPE_ns5__KeyAttribute, sizeof(struct ns5__KeyAttribute), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__DoubleLockDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__DoubleLockDoorResponse, sizeof(struct _ns4__DoubleLockDoorResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns4__DoubleLockDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__DoubleLockDoorResponse, SOAP_TYPE__ns4__DoubleLockDoorResponse, sizeof(struct _ns4__DoubleLockDoorResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__DoubleLockDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__DoubleLockDoor, sizeof(struct _ns4__DoubleLockDoor), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns4__DoubleLockDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__DoubleLockDoor, SOAP_TYPE__ns4__DoubleLockDoor, sizeof(struct _ns4__DoubleLockDoor), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__LockOpenReleaseDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__LockOpenReleaseDoorResponse, sizeof(struct _ns4__LockOpenReleaseDoorResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns4__LockOpenReleaseDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__LockOpenReleaseDoorResponse, SOAP_TYPE__ns4__LockOpenReleaseDoorResponse, sizeof(struct _ns4__LockOpenReleaseDoorResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__LockOpenReleaseDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__LockOpenReleaseDoor, sizeof(struct _ns4__LockOpenReleaseDoor), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns4__LockOpenReleaseDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__LockOpenReleaseDoor, SOAP_TYPE__ns4__LockOpenReleaseDoor, sizeof(struct _ns4__LockOpenReleaseDoor), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__LockOpenDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__LockOpenDoorResponse, sizeof(struct _ns4__LockOpenDoorResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns4__LockOpenDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__LockOpenDoorResponse, SOAP_TYPE__ns4__LockOpenDoorResponse, sizeof(struct _ns4__LockOpenDoorResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__LockOpenDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__LockOpenDoor, sizeof(struct _ns4__LockOpenDoor), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns4__LockOpenDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__LockOpenDoor, SOAP_TYPE__ns4__LockOpenDoor, sizeof(struct _ns4__LockOpenDoor), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__LockDownReleaseDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__LockDownReleaseDoorResponse, sizeof(struct _ns4__LockDownReleaseDoorResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns4__LockDownReleaseDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__LockDownReleaseDoorResponse, SOAP_TYPE__ns4__LockDownReleaseDoorResponse, sizeof(struct _ns4__LockDownReleaseDoorResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__LockDownReleaseDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__LockDownReleaseDoor, sizeof(struct _ns4__LockDownReleaseDoor), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns4__LockDownReleaseDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__LockDownReleaseDoor, SOAP_TYPE__ns4__LockDownReleaseDoor, sizeof(struct _ns4__LockDownReleaseDoor), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__LockDownDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__LockDownDoorResponse, sizeof(struct _ns4__LockDownDoorResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns4__LockDownDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__LockDownDoorResponse, SOAP_TYPE__ns4__LockDownDoorResponse, sizeof(struct _ns4__LockDownDoorResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__LockDownDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__LockDownDoor, sizeof(struct _ns4__LockDownDoor), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns4__LockDownDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__LockDownDoor, SOAP_TYPE__ns4__LockDownDoor, sizeof(struct _ns4__LockDownDoor), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__BlockDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__BlockDoorResponse, sizeof(struct _ns4__BlockDoorResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns4__BlockDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__BlockDoorResponse, SOAP_TYPE__ns4__BlockDoorResponse, sizeof(struct _ns4__BlockDoorResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__BlockDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__BlockDoor, sizeof(struct _ns4__BlockDoor), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns4__BlockDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__BlockDoor, SOAP_TYPE__ns4__BlockDoor, sizeof(struct _ns4__BlockDoor), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__UnlockDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__UnlockDoorResponse, sizeof(struct _ns4__UnlockDoorResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns4__UnlockDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__UnlockDoorResponse, SOAP_TYPE__ns4__UnlockDoorResponse, sizeof(struct _ns4__UnlockDoorResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__UnlockDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__UnlockDoor, sizeof(struct _ns4__UnlockDoor), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns4__UnlockDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__UnlockDoor, SOAP_TYPE__ns4__UnlockDoor, sizeof(struct _ns4__UnlockDoor), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__LockDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__LockDoorResponse, sizeof(struct _ns4__LockDoorResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns4__LockDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__LockDoorResponse, SOAP_TYPE__ns4__LockDoorResponse, sizeof(struct _ns4__LockDoorResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__LockDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__LockDoor, sizeof(struct _ns4__LockDoor), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns4__LockDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__LockDoor, SOAP_TYPE__ns4__LockDoor, sizeof(struct _ns4__LockDoor), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__AccessDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__AccessDoorResponse, sizeof(struct _ns4__AccessDoorResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns4__AccessDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__AccessDoorResponse, SOAP_TYPE__ns4__AccessDoorResponse, sizeof(struct _ns4__AccessDoorResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__AccessDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__AccessDoor, sizeof(struct _ns4__AccessDoor), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseExtendedTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AccessTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_OpenTooLongTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_PreAlarmTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns4__AccessDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__AccessDoor, SOAP_TYPE__ns4__AccessDoor, sizeof(struct _ns4__AccessDoor), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__GetDoorStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetDoorStateResponse, sizeof(struct _ns4__GetDoorStateResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_DoorState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->DoorState))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns4__GetDoorStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetDoorStateResponse, SOAP_TYPE__ns4__GetDoorStateResponse, sizeof(struct _ns4__GetDoorStateResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__GetDoorState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetDoorState, sizeof(struct _ns4__GetDoorState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns4__GetDoorState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetDoorState, SOAP_TYPE__ns4__GetDoorState, sizeof(struct _ns4__GetDoorState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns4__GetDoorInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetDoorInfoResponse, sizeof(struct _ns4__GetDoorInfoResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:DoorInfo", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns4__GetDoorInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetDoorInfoResponse, SOAP_TYPE__ns4__GetDoorInfoResponse, sizeof(struct _ns4__GetDoorInfoResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__GetDoorInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetDoorInfo, sizeof(struct _ns4__GetDoorInfo), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:Token", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeToken < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns4__GetDoorInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetDoorInfo, SOAP_TYPE__ns4__GetDoorInfo, sizeof(struct _ns4__GetDoorInfo), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns4__DoorInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DoorInfo, sizeof(struct ns4__DoorInfo), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || !a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns4__DoorInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__DoorInfo, SOAP_TYPE_ns4__DoorInfo, sizeof(struct ns4__DoorInfo), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns4__GetDoorInfoListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetDoorInfoListResponse, sizeof(struct _ns4__GetDoorInfoListResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_NextStartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:DoorInfo", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns4__GetDoorInfoListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetDoorInfoListResponse, SOAP_TYPE__ns4__GetDoorInfoListResponse, sizeof(struct _ns4__GetDoorInfoListResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__GetDoorInfoList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetDoorInfoList, sizeof(struct _ns4__GetDoorInfoList), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Limit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_StartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns4__GetDoorInfoList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetDoorInfoList, SOAP_TYPE__ns4__GetDoorInfoList, sizeof(struct _ns4__GetDoorInfoList), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetServiceCapabilitiesResponse, sizeof(struct _ns4__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns4__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetServiceCapabilitiesResponse, SOAP_TYPE__ns4__GetServiceCapabilitiesResponse, sizeof(struct _ns4__GetServiceCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns4__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetServiceCapabilities, sizeof(struct _ns4__GetServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns4__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetServiceCapabilities, SOAP_TYPE__ns4__GetServiceCapabilities, sizeof(struct _ns4__GetServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns4__AccessDoorExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__AccessDoorExtension, sizeof(struct ns4__AccessDoorExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns4__AccessDoorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__AccessDoorExtension, SOAP_TYPE_ns4__AccessDoorExtension, sizeof(struct ns4__AccessDoorExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns4__DoorFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DoorFault, sizeof(struct ns4__DoorFault), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Reason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns4__DoorFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__DoorFault, SOAP_TYPE_ns4__DoorFault, sizeof(struct ns4__DoorFault), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns4__DoorTamper *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DoorTamper, sizeof(struct ns4__DoorTamper), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Reason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns4__DoorTamper *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__DoorTamper, SOAP_TYPE_ns4__DoorTamper, sizeof(struct ns4__DoorTamper), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns4__DoorState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DoorState, sizeof(struct ns4__DoorState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_DoorPhysicalState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_LockPhysicalState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DoubleLockPhysicalState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Alarm && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Tamper && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Fault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DoorMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DoorMode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns4__DoorState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__DoorState, SOAP_TYPE_ns4__DoorState, sizeof(struct ns4__DoorState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns4__DoorCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DoorCapabilities, sizeof(struct ns4__DoorCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns4__DoorCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__DoorCapabilities, SOAP_TYPE_ns4__DoorCapabilities, sizeof(struct ns4__DoorCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns4__ServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ServiceCapabilities, sizeof(struct ns4__ServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns4__ServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ServiceCapabilities, SOAP_TYPE_ns4__ServiceCapabilities, sizeof(struct ns4__ServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns3__Attribute *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__Attribute, sizeof(struct ns3__Attribute), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns3__Attribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__Attribute, SOAP_TYPE_ns3__Attribute, sizeof(struct ns3__Attribute), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns3__DataEntity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__DataEntity, sizeof(struct ns3__DataEntity), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns3__DataEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__DataEntity, SOAP_TYPE_ns3__DataEntity, sizeof(struct ns3__DataEntity), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns2__ExternalAuthorizationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ExternalAuthorizationResponse, sizeof(struct _ns2__ExternalAuthorizationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns2__ExternalAuthorizationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__ExternalAuthorizationResponse, SOAP_TYPE__ns2__ExternalAuthorizationResponse, sizeof(struct _ns2__ExternalAuthorizationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns2__ExternalAuthorization *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ExternalAuthorization, sizeof(struct _ns2__ExternalAuthorization), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AccessPointToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_CredentialToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Reason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Decision && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->AccessPointToken || soap_flag_Decision > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns2__ExternalAuthorization *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__ExternalAuthorization, SOAP_TYPE__ns2__ExternalAuthorization, sizeof(struct _ns2__ExternalAuthorization), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns2__DisableAccessPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__DisableAccessPointResponse, sizeof(struct _ns2__DisableAccessPointResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns2__DisableAccessPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__DisableAccessPointResponse, SOAP_TYPE__ns2__DisableAccessPointResponse, sizeof(struct _ns2__DisableAccessPointResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns2__DisableAccessPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__DisableAccessPoint, sizeof(struct _ns2__DisableAccessPoint), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns2__DisableAccessPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__DisableAccessPoint, SOAP_TYPE__ns2__DisableAccessPoint, sizeof(struct _ns2__DisableAccessPoint), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns2__EnableAccessPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__EnableAccessPointResponse, sizeof(struct _ns2__EnableAccessPointResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns2__EnableAccessPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__EnableAccessPointResponse, SOAP_TYPE__ns2__EnableAccessPointResponse, sizeof(struct _ns2__EnableAccessPointResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns2__EnableAccessPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__EnableAccessPoint, sizeof(struct _ns2__EnableAccessPoint), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns2__EnableAccessPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__EnableAccessPoint, SOAP_TYPE__ns2__EnableAccessPoint, sizeof(struct _ns2__EnableAccessPoint), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns2__GetAccessPointStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetAccessPointStateResponse, sizeof(struct _ns2__GetAccessPointStateResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AccessPointState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->AccessPointState))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns2__GetAccessPointStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetAccessPointStateResponse, SOAP_TYPE__ns2__GetAccessPointStateResponse, sizeof(struct _ns2__GetAccessPointStateResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns2__GetAccessPointState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetAccessPointState, sizeof(struct _ns2__GetAccessPointState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns2__GetAccessPointState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetAccessPointState, SOAP_TYPE__ns2__GetAccessPointState, sizeof(struct _ns2__GetAccessPointState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns2__GetAreaInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetAreaInfoResponse, sizeof(struct _ns2__GetAreaInfoResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:AreaInfo", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns2__GetAreaInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetAreaInfoResponse, SOAP_TYPE__ns2__GetAreaInfoResponse, sizeof(struct _ns2__GetAreaInfoResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns2__GetAreaInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetAreaInfo, sizeof(struct _ns2__GetAreaInfo), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Token", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeToken < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns2__GetAreaInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetAreaInfo, SOAP_TYPE__ns2__GetAreaInfo, sizeof(struct _ns2__GetAreaInfo), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns2__AreaInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AreaInfo, sizeof(struct ns2__AreaInfo), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns2__AreaInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AreaInfo, SOAP_TYPE_ns2__AreaInfo, sizeof(struct ns2__AreaInfo), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns2__GetAreaInfoListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetAreaInfoListResponse, sizeof(struct _ns2__GetAreaInfoListResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_NextStartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:AreaInfo", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns2__GetAreaInfoListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetAreaInfoListResponse, SOAP_TYPE__ns2__GetAreaInfoListResponse, sizeof(struct _ns2__GetAreaInfoListResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns2__GetAreaInfoList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetAreaInfoList, sizeof(struct _ns2__GetAreaInfoList), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Limit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_StartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns2__GetAreaInfoList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetAreaInfoList, SOAP_TYPE__ns2__GetAreaInfoList, sizeof(struct _ns2__GetAreaInfoList), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns2__GetAccessPointInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetAccessPointInfoResponse, sizeof(struct _ns2__GetAccessPointInfoResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:AccessPointInfo", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns2__GetAccessPointInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetAccessPointInfoResponse, SOAP_TYPE__ns2__GetAccessPointInfoResponse, sizeof(struct _ns2__GetAccessPointInfoResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns2__GetAccessPointInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetAccessPointInfo, sizeof(struct _ns2__GetAccessPointInfo), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Token", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeToken < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns2__GetAccessPointInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetAccessPointInfo, SOAP_TYPE__ns2__GetAccessPointInfo, sizeof(struct _ns2__GetAccessPointInfo), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns2__AccessPointInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AccessPointInfo, sizeof(struct ns2__AccessPointInfo), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_AreaFrom && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_AreaTo && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_EntityType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Entity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || !a->Entity || !a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns2__AccessPointInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AccessPointInfo, SOAP_TYPE_ns2__AccessPointInfo, sizeof(struct ns2__AccessPointInfo), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns2__GetAccessPointInfoListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetAccessPointInfoListResponse, sizeof(struct _ns2__GetAccessPointInfoListResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_NextStartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:AccessPointInfo", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns2__GetAccessPointInfoListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetAccessPointInfoListResponse, SOAP_TYPE__ns2__GetAccessPointInfoListResponse, sizeof(struct _ns2__GetAccessPointInfoListResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns2__GetAccessPointInfoList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetAccessPointInfoList, sizeof(struct _ns2__GetAccessPointInfoList), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Limit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_StartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns2__GetAccessPointInfoList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetAccessPointInfoList, SOAP_TYPE__ns2__GetAccessPointInfoList, sizeof(struct _ns2__GetAccessPointInfoList), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns2__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetServiceCapabilitiesResponse, sizeof(struct _ns2__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns2__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetServiceCapabilitiesResponse, SOAP_TYPE__ns2__GetServiceCapabilitiesResponse, sizeof(struct _ns2__GetServiceCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns2__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetServiceCapabilities, sizeof(struct _ns2__GetServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns2__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetServiceCapabilities, SOAP_TYPE__ns2__GetServiceCapabilities, sizeof(struct _ns2__GetServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns2__AccessPointState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AccessPointState, sizeof(struct ns2__AccessPointState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns2__AccessPointState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AccessPointState, SOAP_TYPE_ns2__AccessPointState, sizeof(struct ns2__AccessPointState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns2__AccessPointCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AccessPointCapabilities, sizeof(struct ns2__AccessPointCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns2__AccessPointCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AccessPointCapabilities, SOAP_TYPE_ns2__AccessPointCapabilities, sizeof(struct ns2__AccessPointCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns2__ServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ServiceCapabilities, sizeof(struct ns2__ServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns2__ServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ServiceCapabilities, SOAP_TYPE_ns2__ServiceCapabilities, sizeof(struct ns2__ServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns1__DeleteActionTriggersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteActionTriggersResponse, sizeof(struct _ns1__DeleteActionTriggersResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns1__DeleteActionTriggersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteActionTriggersResponse, SOAP_TYPE__ns1__DeleteActionTriggersResponse, sizeof(struct _ns1__DeleteActionTriggersResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns1__DeleteActionTriggers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteActionTriggers, sizeof(struct _ns1__DeleteActionTriggers), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Token", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeToken < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns1__DeleteActionTriggers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteActionTriggers, SOAP_TYPE__ns1__DeleteActionTriggers, sizeof(struct _ns1__DeleteActionTriggers), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns1__ModifyActionTriggersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ModifyActionTriggersResponse, sizeof(struct _ns1__ModifyActionTriggersResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns1__ModifyActionTriggersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ModifyActionTriggersResponse, SOAP_TYPE__ns1__ModifyActionTriggersResponse, sizeof(struct _ns1__ModifyActionTriggersResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns1__ModifyActionTriggers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ModifyActionTriggers, sizeof(struct _ns1__ModifyActionTriggers), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:ActionTrigger", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeActionTrigger < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns1__ModifyActionTriggers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ModifyActionTriggers, SOAP_TYPE__ns1__ModifyActionTriggers, sizeof(struct _ns1__ModifyActionTriggers), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns1__CreateActionTriggersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateActionTriggersResponse, sizeof(struct _ns1__CreateActionTriggersResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:ActionTrigger", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns1__CreateActionTriggersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateActionTriggersResponse, SOAP_TYPE__ns1__CreateActionTriggersResponse, sizeof(struct _ns1__CreateActionTriggersResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns1__CreateActionTriggers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateActionTriggers, sizeof(struct _ns1__CreateActionTriggers), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:ActionTrigger", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeActionTrigger < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns1__CreateActionTriggers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateActionTriggers, SOAP_TYPE__ns1__CreateActionTriggers, sizeof(struct _ns1__CreateActionTriggers), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns1__GetActionTriggersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetActionTriggersResponse, sizeof(struct _ns1__GetActionTriggersResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:ActionTrigger", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns1__GetActionTriggersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetActionTriggersResponse, SOAP_TYPE__ns1__GetActionTriggersResponse, sizeof(struct _ns1__GetActionTriggersResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns1__GetActionTriggers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetActionTriggers, sizeof(struct _ns1__GetActionTriggers), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns1__GetActionTriggers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetActionTriggers, SOAP_TYPE__ns1__GetActionTriggers, sizeof(struct _ns1__GetActionTriggers), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns1__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetServiceCapabilitiesResponse, sizeof(struct _ns1__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns1__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetServiceCapabilitiesResponse, SOAP_TYPE__ns1__GetServiceCapabilitiesResponse, sizeof(struct _ns1__GetServiceCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns1__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetServiceCapabilities, sizeof(struct _ns1__GetServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns1__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetServiceCapabilities, SOAP_TYPE__ns1__GetServiceCapabilities, sizeof(struct _ns1__GetServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns1__ModifyActionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ModifyActionsResponse, sizeof(struct _ns1__ModifyActionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns1__ModifyActionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ModifyActionsResponse, SOAP_TYPE__ns1__ModifyActionsResponse, sizeof(struct _ns1__ModifyActionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns1__ModifyActions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ModifyActions, sizeof(struct _ns1__ModifyActions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Action", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAction < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns1__ModifyActions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ModifyActions, SOAP_TYPE__ns1__ModifyActions, sizeof(struct _ns1__ModifyActions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns1__DeleteActionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteActionsResponse, sizeof(struct _ns1__DeleteActionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns1__DeleteActionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteActionsResponse, SOAP_TYPE__ns1__DeleteActionsResponse, sizeof(struct _ns1__DeleteActionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns1__DeleteActions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteActions, sizeof(struct _ns1__DeleteActions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Token", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeToken < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns1__DeleteActions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteActions, SOAP_TYPE__ns1__DeleteActions, sizeof(struct _ns1__DeleteActions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns1__CreateActionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateActionsResponse, sizeof(struct _ns1__CreateActionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Action", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns1__CreateActionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateActionsResponse, SOAP_TYPE__ns1__CreateActionsResponse, sizeof(struct _ns1__CreateActionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns1__CreateActions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateActions, sizeof(struct _ns1__CreateActions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Action", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAction < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns1__CreateActions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateActions, SOAP_TYPE__ns1__CreateActions, sizeof(struct _ns1__CreateActions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _ns1__GetActionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetActionsResponse, sizeof(struct _ns1__GetActionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Action", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns1__GetActionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetActionsResponse, SOAP_TYPE__ns1__GetActionsResponse, sizeof(struct _ns1__GetActionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns1__GetActions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetActions, sizeof(struct _ns1__GetActions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns1__GetActions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetActions, SOAP_TYPE__ns1__GetActions, sizeof(struct _ns1__GetActions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns1__GetSupportedActionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSupportedActionsResponse, sizeof(struct _ns1__GetSupportedActionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SupportedActions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SupportedActions))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _ns1__GetSupportedActionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSupportedActionsResponse, SOAP_TYPE__ns1__GetSupportedActionsResponse, sizeof(struct _ns1__GetSupportedActionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _ns1__GetSupportedActions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSupportedActions, sizeof(struct _ns1__GetSupportedActions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _ns1__GetSupportedActions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSupportedActions, SOAP_TYPE__ns1__GetSupportedActions, sizeof(struct _ns1__GetSupportedActions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__RecordingActionConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RecordingActionConfiguration, sizeof(struct ns1__RecordingActionConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordConfig && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordConfig))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__RecordingActionConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RecordingActionConfiguration, SOAP_TYPE_ns1__RecordingActionConfiguration, sizeof(struct ns1__RecordingActionConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__TriggeredRecordingConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TriggeredRecordingConfiguration, sizeof(struct ns1__TriggeredRecordingConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PreRecordDuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_PostRecordDuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RecordDuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RecordFrameRate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_DoRecordAudio && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PreRecordDuration > 0 || soap_flag_PostRecordDuration > 0 || soap_flag_RecordDuration > 0 || soap_flag_DoRecordAudio > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__TriggeredRecordingConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TriggeredRecordingConfiguration, SOAP_TYPE_ns1__TriggeredRecordingConfiguration, sizeof(struct ns1__TriggeredRecordingConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__SMSMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SMSMessage, sizeof(struct ns1__SMSMessage), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Text))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__SMSMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SMSMessage, SOAP_TYPE_ns1__SMSMessage, sizeof(struct ns1__SMSMessage), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__SMSSenderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SMSSenderConfiguration, sizeof(struct ns1__SMSSenderConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_EMail && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->EMail))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__SMSSenderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SMSSenderConfiguration, SOAP_TYPE_ns1__SMSSenderConfiguration, sizeof(struct ns1__SMSSenderConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__SMSProviderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SMSProviderConfiguration, sizeof(struct ns1__SMSProviderConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProviderURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_User && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProviderURL || !a->User))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__SMSProviderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SMSProviderConfiguration, SOAP_TYPE_ns1__SMSProviderConfiguration, sizeof(struct ns1__SMSProviderConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__FtpContentConfigurationUploadFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FtpContentConfigurationUploadFile, sizeof(struct ns1__FtpContentConfigurationUploadFile), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_sourceFileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_destinationFileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->sourceFileName || !a->destinationFileName))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__FtpContentConfigurationUploadFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FtpContentConfigurationUploadFile, SOAP_TYPE_ns1__FtpContentConfigurationUploadFile, sizeof(struct ns1__FtpContentConfigurationUploadFile), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__FtpContentConfigurationUploadImages *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FtpContentConfigurationUploadImages, sizeof(struct ns1__FtpContentConfigurationUploadImages), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_HowLong && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SampleInterval && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_FileName && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HowLong > 0 || soap_flag_SampleInterval > 0 || !a->FileName))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__FtpContentConfigurationUploadImages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FtpContentConfigurationUploadImages, SOAP_TYPE_ns1__FtpContentConfigurationUploadImages, sizeof(struct ns1__FtpContentConfigurationUploadImages), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__FtpFileNameConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FtpFileNameConfigurations, sizeof(struct ns1__FtpFileNameConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__FtpFileNameConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FtpFileNameConfigurations, SOAP_TYPE_ns1__FtpFileNameConfigurations, sizeof(struct ns1__FtpFileNameConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__FtpContentConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FtpContentConfiguration, sizeof(struct ns1__FtpContentConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_union_FtpContentConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_FtpContentConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__FtpContentConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FtpContentConfiguration, SOAP_TYPE_ns1__FtpContentConfiguration, sizeof(struct ns1__FtpContentConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__FtpContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FtpContent, sizeof(struct ns1__FtpContent), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_FtpContentConfig && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->FtpContentConfig))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__FtpContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FtpContent, SOAP_TYPE_ns1__FtpContent, sizeof(struct ns1__FtpContent), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__FtpAuthenticationConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FtpAuthenticationConfigurationExtension, sizeof(struct ns1__FtpAuthenticationConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__FtpAuthenticationConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FtpAuthenticationConfigurationExtension, SOAP_TYPE_ns1__FtpAuthenticationConfigurationExtension, sizeof(struct ns1__FtpAuthenticationConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__FtpDestinationConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FtpDestinationConfigurationExtension, sizeof(struct ns1__FtpDestinationConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__FtpDestinationConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FtpDestinationConfigurationExtension, SOAP_TYPE_ns1__FtpDestinationConfigurationExtension, sizeof(struct ns1__FtpDestinationConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns1__FtpAuthenticationConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FtpAuthenticationConfiguration, sizeof(struct ns1__FtpAuthenticationConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_User && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__FtpAuthenticationConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FtpAuthenticationConfiguration, SOAP_TYPE_ns1__FtpAuthenticationConfiguration, sizeof(struct ns1__FtpAuthenticationConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__FtpHostAddress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FtpHostAddress, sizeof(struct ns1__FtpHostAddress), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Value))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__FtpHostAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FtpHostAddress, SOAP_TYPE_ns1__FtpHostAddress, sizeof(struct ns1__FtpHostAddress), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__FtpHostConfigurationsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FtpHostConfigurationsExtension, sizeof(struct ns1__FtpHostConfigurationsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__FtpHostConfigurationsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FtpHostConfigurationsExtension, SOAP_TYPE_ns1__FtpHostConfigurationsExtension, sizeof(struct ns1__FtpHostConfigurationsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns1__FtpDestinationConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FtpDestinationConfiguration, sizeof(struct ns1__FtpDestinationConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_HostAddress && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_UploadPath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_FtpAuthentication && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->HostAddress || !a->UploadPath || !a->FtpAuthentication))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__FtpDestinationConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FtpDestinationConfiguration, SOAP_TYPE_ns1__FtpDestinationConfiguration, sizeof(struct ns1__FtpDestinationConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns1__FtpHostConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FtpHostConfigurations, sizeof(struct ns1__FtpHostConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:FtpDestination", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeFtpDestination < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__FtpHostConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FtpHostConfigurations, SOAP_TYPE_ns1__FtpHostConfigurations, sizeof(struct ns1__FtpHostConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__PostBodyConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PostBodyConfiguration, sizeof(struct ns1__PostBodyConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__PostBodyConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PostBodyConfiguration, SOAP_TYPE_ns1__PostBodyConfiguration, sizeof(struct ns1__PostBodyConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__PostContentConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PostContentConfiguration, sizeof(struct ns1__PostContentConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_MediaReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_PostBody && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PostBody))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__PostContentConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PostContentConfiguration, SOAP_TYPE_ns1__PostContentConfiguration, sizeof(struct ns1__PostContentConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__HttpAuthenticationConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HttpAuthenticationConfigurationExtension, sizeof(struct ns1__HttpAuthenticationConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__HttpAuthenticationConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HttpAuthenticationConfigurationExtension, SOAP_TYPE_ns1__HttpAuthenticationConfigurationExtension, sizeof(struct ns1__HttpAuthenticationConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__HttpDestinationConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HttpDestinationConfigurationExtension, sizeof(struct ns1__HttpDestinationConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__HttpDestinationConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HttpDestinationConfigurationExtension, SOAP_TYPE_ns1__HttpDestinationConfigurationExtension, sizeof(struct ns1__HttpDestinationConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns1__HttpAuthenticationConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HttpAuthenticationConfiguration, sizeof(struct ns1__HttpAuthenticationConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_User && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__HttpAuthenticationConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HttpAuthenticationConfiguration, SOAP_TYPE_ns1__HttpAuthenticationConfiguration, sizeof(struct ns1__HttpAuthenticationConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__HttpHostAddress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HttpHostAddress, sizeof(struct ns1__HttpHostAddress), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Value))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__HttpHostAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HttpHostAddress, SOAP_TYPE_ns1__HttpHostAddress, sizeof(struct ns1__HttpHostAddress), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__HttpHostConfigurationsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HttpHostConfigurationsExtension, sizeof(struct ns1__HttpHostConfigurationsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__HttpHostConfigurationsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HttpHostConfigurationsExtension, SOAP_TYPE_ns1__HttpHostConfigurationsExtension, sizeof(struct ns1__HttpHostConfigurationsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns1__HttpDestinationConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HttpDestinationConfiguration, sizeof(struct ns1__HttpDestinationConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_HostAddress && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_HttpAuthentication && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->HostAddress))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__HttpDestinationConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HttpDestinationConfiguration, SOAP_TYPE_ns1__HttpDestinationConfiguration, sizeof(struct ns1__HttpDestinationConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns1__HttpHostConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HttpHostConfigurations, sizeof(struct ns1__HttpHostConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:HttpDestination", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeHttpDestination < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__HttpHostConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HttpHostConfigurations, SOAP_TYPE_ns1__HttpHostConfigurations, sizeof(struct ns1__HttpHostConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__MediaSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MediaSource, sizeof(struct ns1__MediaSource), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__MediaSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MediaSource, SOAP_TYPE_ns1__MediaSource, sizeof(struct ns1__MediaSource), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__EMailBodyTextConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EMailBodyTextConfiguration, sizeof(struct ns1__EMailBodyTextConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__EMailBodyTextConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EMailBodyTextConfiguration, SOAP_TYPE_ns1__EMailBodyTextConfiguration, sizeof(struct ns1__EMailBodyTextConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__EMailAttachmentConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EMailAttachmentConfigurationExtension, sizeof(struct ns1__EMailAttachmentConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__EMailAttachmentConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EMailAttachmentConfigurationExtension, SOAP_TYPE_ns1__EMailAttachmentConfigurationExtension, sizeof(struct ns1__EMailAttachmentConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__EMailAttachmentConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EMailAttachmentConfiguration, sizeof(struct ns1__EMailAttachmentConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_FileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_doSuffix && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__EMailAttachmentConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EMailAttachmentConfiguration, SOAP_TYPE_ns1__EMailAttachmentConfiguration, sizeof(struct ns1__EMailAttachmentConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__EMailReceiverConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EMailReceiverConfigurationExtension, sizeof(struct ns1__EMailReceiverConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__EMailReceiverConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EMailReceiverConfigurationExtension, SOAP_TYPE_ns1__EMailReceiverConfigurationExtension, sizeof(struct ns1__EMailReceiverConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__EMailReceiverConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EMailReceiverConfiguration, sizeof(struct ns1__EMailReceiverConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:TO", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:CC", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeTO < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__EMailReceiverConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EMailReceiverConfiguration, SOAP_TYPE_ns1__EMailReceiverConfiguration, sizeof(struct ns1__EMailReceiverConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__UserCredentialsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UserCredentialsExtension, sizeof(struct ns1__UserCredentialsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__UserCredentialsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UserCredentialsExtension, SOAP_TYPE_ns1__UserCredentialsExtension, sizeof(struct ns1__UserCredentialsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns1__UserCredentials *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UserCredentials, sizeof(struct ns1__UserCredentials), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_password && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->username))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__UserCredentials *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UserCredentials, SOAP_TYPE_ns1__UserCredentials, sizeof(struct ns1__UserCredentials), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__HostAddress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HostAddress, sizeof(struct ns1__HostAddress), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Value))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__HostAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HostAddress, SOAP_TYPE_ns1__HostAddress, sizeof(struct ns1__HostAddress), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__AuthenticationConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AuthenticationConfig, sizeof(struct ns1__AuthenticationConfig), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_User && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->User))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__AuthenticationConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AuthenticationConfig, SOAP_TYPE_ns1__AuthenticationConfig, sizeof(struct ns1__AuthenticationConfig), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__POPConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__POPConfig, sizeof(struct ns1__POPConfig), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_HostAddress && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->HostAddress))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__POPConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__POPConfig, SOAP_TYPE_ns1__POPConfig, sizeof(struct ns1__POPConfig), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__SMTPConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SMTPConfig, sizeof(struct ns1__SMTPConfig), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_HostAddress && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->HostAddress))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__SMTPConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SMTPConfig, SOAP_TYPE_ns1__SMTPConfig, sizeof(struct ns1__SMTPConfig), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__EMailServerConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EMailServerConfiguration, sizeof(struct ns1__EMailServerConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SMTPConfig && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_POPConfig && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AuthenticationConfig && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SMTPConfig || !a->POPConfig || !a->AuthenticationConfig))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__EMailServerConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EMailServerConfiguration, SOAP_TYPE_ns1__EMailServerConfiguration, sizeof(struct ns1__EMailServerConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__onvif_USCOREaction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__onvif_USCOREaction, sizeof(struct ns1__onvif_USCOREaction), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:ActionDescription", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeActionDescription < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__onvif_USCOREaction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__onvif_USCOREaction, SOAP_TYPE_ns1__onvif_USCOREaction, sizeof(struct ns1__onvif_USCOREaction), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__ActionTrigger *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ActionTrigger, sizeof(struct ns1__ActionTrigger), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__ActionTrigger *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ActionTrigger, SOAP_TYPE_ns1__ActionTrigger, sizeof(struct ns1__ActionTrigger), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__ActionTriggerConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ActionTriggerConfigurationExtension, sizeof(struct ns1__ActionTriggerConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__ActionTriggerConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ActionTriggerConfigurationExtension, SOAP_TYPE_ns1__ActionTriggerConfigurationExtension, sizeof(struct ns1__ActionTriggerConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns1__ActionTriggerConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ActionTriggerConfiguration, sizeof(struct ns1__ActionTriggerConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_TopicExpression && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ContentExpression && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:ActionToken", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->TopicExpression))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__ActionTriggerConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ActionTriggerConfiguration, SOAP_TYPE_ns1__ActionTriggerConfiguration, sizeof(struct ns1__ActionTriggerConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__Action *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Action, sizeof(struct ns1__Action), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__Action *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Action, SOAP_TYPE_ns1__Action, sizeof(struct ns1__Action), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__ActionConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ActionConfiguration, sizeof(struct ns1__ActionConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Parameters && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Parameters))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__ActionConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ActionConfiguration, SOAP_TYPE_ns1__ActionConfiguration, sizeof(struct ns1__ActionConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__ActionEngineCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ActionEngineCapabilitiesExtension, sizeof(struct ns1__ActionEngineCapabilitiesExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__ActionEngineCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ActionEngineCapabilitiesExtension, SOAP_TYPE_ns1__ActionEngineCapabilitiesExtension, sizeof(struct ns1__ActionEngineCapabilitiesExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__ActionTypeLimits *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ActionTypeLimits, sizeof(struct ns1__ActionTypeLimits), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__ActionTypeLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ActionTypeLimits, SOAP_TYPE_ns1__ActionTypeLimits, sizeof(struct ns1__ActionTypeLimits), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns1__ActionEngineCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ActionEngineCapabilities, sizeof(struct ns1__ActionEngineCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:ActionCapabilities", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__ActionEngineCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ActionEngineCapabilities, SOAP_TYPE_ns1__ActionEngineCapabilities, sizeof(struct ns1__ActionEngineCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ns1__SupportedActionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SupportedActionsExtension, sizeof(struct ns1__SupportedActionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__SupportedActionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SupportedActionsExtension, SOAP_TYPE_ns1__SupportedActionsExtension, sizeof(struct ns1__SupportedActionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns1__SupportedActions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SupportedActions, sizeof(struct ns1__SupportedActions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:ActionContentSchemaLocation", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:ActionDescription", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ns1__SupportedActions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SupportedActions, SOAP_TYPE_ns1__SupportedActions, sizeof(struct ns1__SupportedActions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ns1__ActionConfigDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ActionConfigDescription, sizeof(struct ns1__ActionConfigDescription), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ParameterDescription && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ParameterDescription))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ns1__ActionConfigDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ActionConfigDescription, SOAP_TYPE_ns1__ActionConfigDescription, sizeof(struct ns1__ActionConfigDescription), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__GetAnalyticsStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsStateResponse, sizeof(struct _tad__GetAnalyticsStateResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->State))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__GetAnalyticsStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsStateResponse, SOAP_TYPE__tad__GetAnalyticsStateResponse, sizeof(struct _tad__GetAnalyticsStateResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__GetAnalyticsState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsState, sizeof(struct _tad__GetAnalyticsState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AnalyticsEngineControlToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->AnalyticsEngineControlToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__GetAnalyticsState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsState, SOAP_TYPE__tad__GetAnalyticsState, sizeof(struct _tad__GetAnalyticsState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__DeleteAnalyticsEngineInputsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse, sizeof(struct _tad__DeleteAnalyticsEngineInputsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tad__DeleteAnalyticsEngineInputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse, sizeof(struct _tad__DeleteAnalyticsEngineInputsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__DeleteAnalyticsEngineInputs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs, sizeof(struct _tad__DeleteAnalyticsEngineInputs), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:ConfigurationToken", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfigurationToken < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__DeleteAnalyticsEngineInputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs, sizeof(struct _tad__DeleteAnalyticsEngineInputs), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__GetVideoAnalyticsConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse, sizeof(struct _tad__GetVideoAnalyticsConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__GetVideoAnalyticsConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse, sizeof(struct _tad__GetVideoAnalyticsConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__GetVideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetVideoAnalyticsConfiguration, sizeof(struct _tad__GetVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__GetVideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetVideoAnalyticsConfiguration, SOAP_TYPE__tad__GetVideoAnalyticsConfiguration, sizeof(struct _tad__GetVideoAnalyticsConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__GetAnalyticsDeviceStreamUriResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse, sizeof(struct _tad__GetAnalyticsDeviceStreamUriResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Uri))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__GetAnalyticsDeviceStreamUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse, sizeof(struct _tad__GetAnalyticsDeviceStreamUriResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__GetAnalyticsDeviceStreamUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri, sizeof(struct _tad__GetAnalyticsDeviceStreamUri), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_StreamSetup && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AnalyticsEngineControlToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->StreamSetup || !a->AnalyticsEngineControlToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__GetAnalyticsDeviceStreamUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri, sizeof(struct _tad__GetAnalyticsDeviceStreamUri), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tad__GetAnalyticsEngineInputsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse, sizeof(struct _tad__GetAnalyticsEngineInputsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:Configuration", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfiguration < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineInputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse, SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse, sizeof(struct _tad__GetAnalyticsEngineInputsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__GetAnalyticsEngineInputs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineInputs, sizeof(struct _tad__GetAnalyticsEngineInputs), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineInputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineInputs, SOAP_TYPE__tad__GetAnalyticsEngineInputs, sizeof(struct _tad__GetAnalyticsEngineInputs), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__GetAnalyticsEngineInputResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineInputResponse, sizeof(struct _tad__GetAnalyticsEngineInputResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineInputResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineInputResponse, SOAP_TYPE__tad__GetAnalyticsEngineInputResponse, sizeof(struct _tad__GetAnalyticsEngineInputResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__GetAnalyticsEngineInput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineInput, sizeof(struct _tad__GetAnalyticsEngineInput), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineInput, SOAP_TYPE__tad__GetAnalyticsEngineInput, sizeof(struct _tad__GetAnalyticsEngineInput), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__SetAnalyticsEngineInputResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetAnalyticsEngineInputResponse, sizeof(struct _tad__SetAnalyticsEngineInputResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tad__SetAnalyticsEngineInputResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetAnalyticsEngineInputResponse, SOAP_TYPE__tad__SetAnalyticsEngineInputResponse, sizeof(struct _tad__SetAnalyticsEngineInputResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__SetAnalyticsEngineInput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetAnalyticsEngineInput, sizeof(struct _tad__SetAnalyticsEngineInput), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__SetAnalyticsEngineInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetAnalyticsEngineInput, SOAP_TYPE__tad__SetAnalyticsEngineInput, sizeof(struct _tad__SetAnalyticsEngineInput), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__SetVideoAnalyticsConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse, sizeof(struct _tad__SetVideoAnalyticsConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tad__SetVideoAnalyticsConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse, SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse, sizeof(struct _tad__SetVideoAnalyticsConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__SetVideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetVideoAnalyticsConfiguration, sizeof(struct _tad__SetVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__SetVideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetVideoAnalyticsConfiguration, SOAP_TYPE__tad__SetVideoAnalyticsConfiguration, sizeof(struct _tad__SetVideoAnalyticsConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tad__GetAnalyticsEnginesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEnginesResponse, sizeof(struct _tad__GetAnalyticsEnginesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:Configuration", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfiguration < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__GetAnalyticsEnginesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEnginesResponse, SOAP_TYPE__tad__GetAnalyticsEnginesResponse, sizeof(struct _tad__GetAnalyticsEnginesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__GetAnalyticsEngines *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngines, sizeof(struct _tad__GetAnalyticsEngines), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngines *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngines, SOAP_TYPE__tad__GetAnalyticsEngines, sizeof(struct _tad__GetAnalyticsEngines), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AnalyticsEngine *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngine, sizeof(struct tt__AnalyticsEngine), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AnalyticsEngineConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->AnalyticsEngineConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AnalyticsEngine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngine, SOAP_TYPE_tt__AnalyticsEngine, sizeof(struct tt__AnalyticsEngine), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__GetAnalyticsEngineResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineResponse, sizeof(struct _tad__GetAnalyticsEngineResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineResponse, SOAP_TYPE__tad__GetAnalyticsEngineResponse, sizeof(struct _tad__GetAnalyticsEngineResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__GetAnalyticsEngine *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngine, sizeof(struct _tad__GetAnalyticsEngine), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngine, SOAP_TYPE__tad__GetAnalyticsEngine, sizeof(struct _tad__GetAnalyticsEngine), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tad__GetAnalyticsEngineControlsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse, sizeof(struct _tad__GetAnalyticsEngineControlsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:AnalyticsEngineControls", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAnalyticsEngineControls < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineControlsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse, SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse, sizeof(struct _tad__GetAnalyticsEngineControlsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__GetAnalyticsEngineControls *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineControls, sizeof(struct _tad__GetAnalyticsEngineControls), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineControls *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineControls, SOAP_TYPE__tad__GetAnalyticsEngineControls, sizeof(struct _tad__GetAnalyticsEngineControls), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__GetAnalyticsEngineControlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineControlResponse, sizeof(struct _tad__GetAnalyticsEngineControlResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineControlResponse, SOAP_TYPE__tad__GetAnalyticsEngineControlResponse, sizeof(struct _tad__GetAnalyticsEngineControlResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__GetAnalyticsEngineControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineControl, sizeof(struct _tad__GetAnalyticsEngineControl), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineControl, SOAP_TYPE__tad__GetAnalyticsEngineControl, sizeof(struct _tad__GetAnalyticsEngineControl), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__SetAnalyticsEngineControlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetAnalyticsEngineControlResponse, sizeof(struct _tad__SetAnalyticsEngineControlResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tad__SetAnalyticsEngineControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetAnalyticsEngineControlResponse, SOAP_TYPE__tad__SetAnalyticsEngineControlResponse, sizeof(struct _tad__SetAnalyticsEngineControlResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__SetAnalyticsEngineControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetAnalyticsEngineControl, sizeof(struct _tad__SetAnalyticsEngineControl), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__SetAnalyticsEngineControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetAnalyticsEngineControl, SOAP_TYPE__tad__SetAnalyticsEngineControl, sizeof(struct _tad__SetAnalyticsEngineControl), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tad__CreateAnalyticsEngineControlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse, sizeof(struct _tad__CreateAnalyticsEngineControlResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:Configuration", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfiguration < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__CreateAnalyticsEngineControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse, SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse, sizeof(struct _tad__CreateAnalyticsEngineControlResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AnalyticsEngineControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineControl, sizeof(struct tt__AnalyticsEngineControl), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_EngineToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_EngineConfigToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:InputToken", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ReceiverToken", 1, NULL))
./soapC.c:			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Subscription && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->EngineToken || !a->EngineConfigToken || a->__sizeInputToken < 1 || a->__sizeReceiverToken < 1 || !a->Subscription || soap_flag_Mode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AnalyticsEngineControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineControl, SOAP_TYPE_tt__AnalyticsEngineControl, sizeof(struct tt__AnalyticsEngineControl), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__CreateAnalyticsEngineControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__CreateAnalyticsEngineControl, sizeof(struct _tad__CreateAnalyticsEngineControl), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__CreateAnalyticsEngineControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__CreateAnalyticsEngineControl, SOAP_TYPE__tad__CreateAnalyticsEngineControl, sizeof(struct _tad__CreateAnalyticsEngineControl), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tad__CreateAnalyticsEngineInputsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse, sizeof(struct _tad__CreateAnalyticsEngineInputsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:Configuration", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfiguration < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__CreateAnalyticsEngineInputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse, sizeof(struct _tad__CreateAnalyticsEngineInputsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AnalyticsEngineInput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineInput, sizeof(struct tt__AnalyticsEngineInput), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SourceIdentification && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_VideoInput && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MetadataInput && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->SourceIdentification || !a->VideoInput || !a->MetadataInput))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AnalyticsEngineInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineInput, SOAP_TYPE_tt__AnalyticsEngineInput, sizeof(struct tt__AnalyticsEngineInput), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tad__CreateAnalyticsEngineInputs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__CreateAnalyticsEngineInputs, sizeof(struct _tad__CreateAnalyticsEngineInputs), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:Configuration", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:ForcePersistence", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfiguration < 1 || a->__sizeForcePersistence < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__CreateAnalyticsEngineInputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__CreateAnalyticsEngineInputs, SOAP_TYPE__tad__CreateAnalyticsEngineInputs, sizeof(struct _tad__CreateAnalyticsEngineInputs), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__DeleteAnalyticsEngineControlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse, sizeof(struct _tad__DeleteAnalyticsEngineControlResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tad__DeleteAnalyticsEngineControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse, SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse, sizeof(struct _tad__DeleteAnalyticsEngineControlResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__DeleteAnalyticsEngineControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineControl, sizeof(struct _tad__DeleteAnalyticsEngineControl), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__DeleteAnalyticsEngineControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__DeleteAnalyticsEngineControl, SOAP_TYPE__tad__DeleteAnalyticsEngineControl, sizeof(struct _tad__DeleteAnalyticsEngineControl), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetServiceCapabilitiesResponse, sizeof(struct _tad__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tad__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetServiceCapabilitiesResponse, SOAP_TYPE__tad__GetServiceCapabilitiesResponse, sizeof(struct _tad__GetServiceCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tad__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetServiceCapabilities, sizeof(struct _tad__GetServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tad__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetServiceCapabilities, SOAP_TYPE__tad__GetServiceCapabilities, sizeof(struct _tad__GetServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tad__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tad__Capabilities, sizeof(struct tad__Capabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tad__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tad__Capabilities, SOAP_TYPE_tad__Capabilities, sizeof(struct tad__Capabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tan__GetAnalyticsModulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetAnalyticsModulesResponse, sizeof(struct _tan__GetAnalyticsModulesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:AnalyticsModule", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tan__GetAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetAnalyticsModulesResponse, SOAP_TYPE__tan__GetAnalyticsModulesResponse, sizeof(struct _tan__GetAnalyticsModulesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tan__GetAnalyticsModules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetAnalyticsModules, sizeof(struct _tan__GetAnalyticsModules), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tan__GetAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetAnalyticsModules, SOAP_TYPE__tan__GetAnalyticsModules, sizeof(struct _tan__GetAnalyticsModules), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tan__ModifyAnalyticsModulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse, sizeof(struct _tan__ModifyAnalyticsModulesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tan__ModifyAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse, sizeof(struct _tan__ModifyAnalyticsModulesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tan__ModifyAnalyticsModules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__ModifyAnalyticsModules, sizeof(struct _tan__ModifyAnalyticsModules), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:AnalyticsModule", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken || a->__sizeAnalyticsModule < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tan__ModifyAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__ModifyAnalyticsModules, SOAP_TYPE__tan__ModifyAnalyticsModules, sizeof(struct _tan__ModifyAnalyticsModules), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tan__DeleteAnalyticsModulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse, sizeof(struct _tan__DeleteAnalyticsModulesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tan__DeleteAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse, sizeof(struct _tan__DeleteAnalyticsModulesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tan__DeleteAnalyticsModules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__DeleteAnalyticsModules, sizeof(struct _tan__DeleteAnalyticsModules), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:AnalyticsModuleName", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken || a->__sizeAnalyticsModuleName < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tan__DeleteAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__DeleteAnalyticsModules, SOAP_TYPE__tan__DeleteAnalyticsModules, sizeof(struct _tan__DeleteAnalyticsModules), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tan__CreateAnalyticsModulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__CreateAnalyticsModulesResponse, sizeof(struct _tan__CreateAnalyticsModulesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tan__CreateAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__CreateAnalyticsModulesResponse, SOAP_TYPE__tan__CreateAnalyticsModulesResponse, sizeof(struct _tan__CreateAnalyticsModulesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tan__CreateAnalyticsModules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__CreateAnalyticsModules, sizeof(struct _tan__CreateAnalyticsModules), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:AnalyticsModule", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken || a->__sizeAnalyticsModule < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tan__CreateAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__CreateAnalyticsModules, SOAP_TYPE__tan__CreateAnalyticsModules, sizeof(struct _tan__CreateAnalyticsModules), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tan__GetSupportedAnalyticsModulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse, sizeof(struct _tan__GetSupportedAnalyticsModulesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SupportedAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SupportedAnalyticsModules))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tan__GetSupportedAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse, sizeof(struct _tan__GetSupportedAnalyticsModulesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tan__GetSupportedAnalyticsModules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetSupportedAnalyticsModules, sizeof(struct _tan__GetSupportedAnalyticsModules), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tan__GetSupportedAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetSupportedAnalyticsModules, SOAP_TYPE__tan__GetSupportedAnalyticsModules, sizeof(struct _tan__GetSupportedAnalyticsModules), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tan__GetRuleOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetRuleOptionsResponse, sizeof(struct _tan__GetRuleOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:RuleOptions", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tan__GetRuleOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetRuleOptionsResponse, SOAP_TYPE__tan__GetRuleOptionsResponse, sizeof(struct _tan__GetRuleOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tan__GetRuleOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetRuleOptions, sizeof(struct _tan__GetRuleOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RuleType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tan__GetRuleOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetRuleOptions, SOAP_TYPE__tan__GetRuleOptions, sizeof(struct _tan__GetRuleOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tan__GetRulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetRulesResponse, sizeof(struct _tan__GetRulesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:Rule", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tan__GetRulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetRulesResponse, SOAP_TYPE__tan__GetRulesResponse, sizeof(struct _tan__GetRulesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tan__GetRules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetRules, sizeof(struct _tan__GetRules), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tan__GetRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetRules, SOAP_TYPE__tan__GetRules, sizeof(struct _tan__GetRules), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tan__ModifyRulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__ModifyRulesResponse, sizeof(struct _tan__ModifyRulesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tan__ModifyRulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__ModifyRulesResponse, SOAP_TYPE__tan__ModifyRulesResponse, sizeof(struct _tan__ModifyRulesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tan__ModifyRules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__ModifyRules, sizeof(struct _tan__ModifyRules), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:Rule", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken || a->__sizeRule < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tan__ModifyRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__ModifyRules, SOAP_TYPE__tan__ModifyRules, sizeof(struct _tan__ModifyRules), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tan__DeleteRulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__DeleteRulesResponse, sizeof(struct _tan__DeleteRulesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tan__DeleteRulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__DeleteRulesResponse, SOAP_TYPE__tan__DeleteRulesResponse, sizeof(struct _tan__DeleteRulesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tan__DeleteRules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__DeleteRules, sizeof(struct _tan__DeleteRules), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:RuleName", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken || a->__sizeRuleName < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tan__DeleteRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__DeleteRules, SOAP_TYPE__tan__DeleteRules, sizeof(struct _tan__DeleteRules), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tan__CreateRulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__CreateRulesResponse, sizeof(struct _tan__CreateRulesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tan__CreateRulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__CreateRulesResponse, SOAP_TYPE__tan__CreateRulesResponse, sizeof(struct _tan__CreateRulesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tan__CreateRules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__CreateRules, sizeof(struct _tan__CreateRules), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:Rule", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken || a->__sizeRule < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tan__CreateRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__CreateRules, SOAP_TYPE__tan__CreateRules, sizeof(struct _tan__CreateRules), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tan__GetSupportedRulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetSupportedRulesResponse, sizeof(struct _tan__GetSupportedRulesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SupportedRules && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SupportedRules))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tan__GetSupportedRulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetSupportedRulesResponse, SOAP_TYPE__tan__GetSupportedRulesResponse, sizeof(struct _tan__GetSupportedRulesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tan__GetSupportedRules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetSupportedRules, sizeof(struct _tan__GetSupportedRules), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tan__GetSupportedRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetSupportedRules, SOAP_TYPE__tan__GetSupportedRules, sizeof(struct _tan__GetSupportedRules), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tan__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetServiceCapabilitiesResponse, sizeof(struct _tan__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tan__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetServiceCapabilitiesResponse, SOAP_TYPE__tan__GetServiceCapabilitiesResponse, sizeof(struct _tan__GetServiceCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tan__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetServiceCapabilities, sizeof(struct _tan__GetServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tan__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetServiceCapabilities, SOAP_TYPE__tan__GetServiceCapabilities, sizeof(struct _tan__GetServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tan__ConfigOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tan__ConfigOptions, sizeof(struct tan__ConfigOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tan__ConfigOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tan__ConfigOptions, SOAP_TYPE_tan__ConfigOptions, sizeof(struct tan__ConfigOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tan__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tan__Capabilities, sizeof(struct tan__Capabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tan__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tan__Capabilities, SOAP_TYPE_tan__Capabilities, sizeof(struct tan__Capabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trp__GetReplayConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetReplayConfigurationResponse, sizeof(struct _trp__GetReplayConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trp__GetReplayConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetReplayConfigurationResponse, SOAP_TYPE__trp__GetReplayConfigurationResponse, sizeof(struct _trp__GetReplayConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trp__GetReplayConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetReplayConfiguration, sizeof(struct _trp__GetReplayConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trp__GetReplayConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetReplayConfiguration, SOAP_TYPE__trp__GetReplayConfiguration, sizeof(struct _trp__GetReplayConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trp__SetReplayConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__SetReplayConfigurationResponse, sizeof(struct _trp__SetReplayConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trp__SetReplayConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__SetReplayConfigurationResponse, SOAP_TYPE__trp__SetReplayConfigurationResponse, sizeof(struct _trp__SetReplayConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trp__SetReplayConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__SetReplayConfiguration, sizeof(struct _trp__SetReplayConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trp__SetReplayConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__SetReplayConfiguration, SOAP_TYPE__trp__SetReplayConfiguration, sizeof(struct _trp__SetReplayConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trp__GetReplayUriResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetReplayUriResponse, sizeof(struct _trp__GetReplayUriResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Uri))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trp__GetReplayUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetReplayUriResponse, SOAP_TYPE__trp__GetReplayUriResponse, sizeof(struct _trp__GetReplayUriResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trp__GetReplayUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetReplayUri, sizeof(struct _trp__GetReplayUri), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_StreamSetup && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->StreamSetup || !a->RecordingToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trp__GetReplayUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetReplayUri, SOAP_TYPE__trp__GetReplayUri, sizeof(struct _trp__GetReplayUri), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trp__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetServiceCapabilitiesResponse, sizeof(struct _trp__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trp__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetServiceCapabilitiesResponse, SOAP_TYPE__trp__GetServiceCapabilitiesResponse, sizeof(struct _trp__GetServiceCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trp__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetServiceCapabilities, sizeof(struct _trp__GetServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trp__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetServiceCapabilities, SOAP_TYPE__trp__GetServiceCapabilities, sizeof(struct _trp__GetServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct trp__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trp__Capabilities, sizeof(struct trp__Capabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct trp__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trp__Capabilities, SOAP_TYPE_trp__Capabilities, sizeof(struct trp__Capabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__EndSearchResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__EndSearchResponse, sizeof(struct _tse__EndSearchResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Endpoint && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Endpoint > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__EndSearchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__EndSearchResponse, SOAP_TYPE__tse__EndSearchResponse, sizeof(struct _tse__EndSearchResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__EndSearch *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__EndSearch, sizeof(struct _tse__EndSearch), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__EndSearch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__EndSearch, SOAP_TYPE__tse__EndSearch, sizeof(struct _tse__EndSearch), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__GetSearchStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetSearchStateResponse, sizeof(struct _tse__GetSearchStateResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__GetSearchStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetSearchStateResponse, SOAP_TYPE__tse__GetSearchStateResponse, sizeof(struct _tse__GetSearchStateResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__GetSearchState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetSearchState, sizeof(struct _tse__GetSearchState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__GetSearchState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetSearchState, SOAP_TYPE__tse__GetSearchState, sizeof(struct _tse__GetSearchState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__GetMetadataSearchResultsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetMetadataSearchResultsResponse, sizeof(struct _tse__GetMetadataSearchResultsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ResultList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ResultList))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__GetMetadataSearchResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetMetadataSearchResultsResponse, SOAP_TYPE__tse__GetMetadataSearchResultsResponse, sizeof(struct _tse__GetMetadataSearchResultsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__GetMetadataSearchResults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetMetadataSearchResults, sizeof(struct _tse__GetMetadataSearchResults), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_MinResults && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxResults && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_WaitTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__GetMetadataSearchResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetMetadataSearchResults, SOAP_TYPE__tse__GetMetadataSearchResults, sizeof(struct _tse__GetMetadataSearchResults), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__FindMetadataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindMetadataResponse, sizeof(struct _tse__FindMetadataResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__FindMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindMetadataResponse, SOAP_TYPE__tse__FindMetadataResponse, sizeof(struct _tse__FindMetadataResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__FindMetadata *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindMetadata, sizeof(struct _tse__FindMetadata), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_StartPoint && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_EndPoint && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Scope && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MetadataFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxMatches && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_KeepAliveTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartPoint > 0 || !a->Scope || !a->MetadataFilter || soap_flag_KeepAliveTime > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__FindMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindMetadata, SOAP_TYPE__tse__FindMetadata, sizeof(struct _tse__FindMetadata), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__GetPTZPositionSearchResultsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse, sizeof(struct _tse__GetPTZPositionSearchResultsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ResultList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ResultList))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__GetPTZPositionSearchResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse, sizeof(struct _tse__GetPTZPositionSearchResultsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__GetPTZPositionSearchResults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetPTZPositionSearchResults, sizeof(struct _tse__GetPTZPositionSearchResults), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_MinResults && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxResults && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_WaitTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__GetPTZPositionSearchResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetPTZPositionSearchResults, SOAP_TYPE__tse__GetPTZPositionSearchResults, sizeof(struct _tse__GetPTZPositionSearchResults), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__FindPTZPositionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindPTZPositionResponse, sizeof(struct _tse__FindPTZPositionResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__FindPTZPositionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindPTZPositionResponse, SOAP_TYPE__tse__FindPTZPositionResponse, sizeof(struct _tse__FindPTZPositionResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__FindPTZPosition *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindPTZPosition, sizeof(struct _tse__FindPTZPosition), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_StartPoint && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_EndPoint && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Scope && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SearchFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxMatches && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_KeepAliveTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartPoint > 0 || !a->Scope || !a->SearchFilter || soap_flag_KeepAliveTime > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__FindPTZPosition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindPTZPosition, SOAP_TYPE__tse__FindPTZPosition, sizeof(struct _tse__FindPTZPosition), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__GetEventSearchResultsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetEventSearchResultsResponse, sizeof(struct _tse__GetEventSearchResultsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ResultList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ResultList))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__GetEventSearchResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetEventSearchResultsResponse, SOAP_TYPE__tse__GetEventSearchResultsResponse, sizeof(struct _tse__GetEventSearchResultsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__GetEventSearchResults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetEventSearchResults, sizeof(struct _tse__GetEventSearchResults), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_MinResults && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxResults && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_WaitTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__GetEventSearchResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetEventSearchResults, SOAP_TYPE__tse__GetEventSearchResults, sizeof(struct _tse__GetEventSearchResults), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__FindEventsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindEventsResponse, sizeof(struct _tse__FindEventsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__FindEventsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindEventsResponse, SOAP_TYPE__tse__FindEventsResponse, sizeof(struct _tse__FindEventsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__EventFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventFilter, sizeof(struct tt__EventFilter), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__EventFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventFilter, SOAP_TYPE_tt__EventFilter, sizeof(struct tt__EventFilter), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__FindEvents *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindEvents, sizeof(struct _tse__FindEvents), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_StartPoint && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_EndPoint && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Scope && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SearchFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_IncludeStartState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxMatches && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_KeepAliveTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartPoint > 0 || !a->Scope || !a->SearchFilter || soap_flag_IncludeStartState > 0 || soap_flag_KeepAliveTime > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__FindEvents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindEvents, SOAP_TYPE__tse__FindEvents, sizeof(struct _tse__FindEvents), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__GetRecordingSearchResultsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingSearchResultsResponse, sizeof(struct _tse__GetRecordingSearchResultsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ResultList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ResultList))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__GetRecordingSearchResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingSearchResultsResponse, SOAP_TYPE__tse__GetRecordingSearchResultsResponse, sizeof(struct _tse__GetRecordingSearchResultsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__GetRecordingSearchResults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingSearchResults, sizeof(struct _tse__GetRecordingSearchResults), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_MinResults && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxResults && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_WaitTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__GetRecordingSearchResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingSearchResults, SOAP_TYPE__tse__GetRecordingSearchResults, sizeof(struct _tse__GetRecordingSearchResults), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__FindRecordingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindRecordingsResponse, sizeof(struct _tse__FindRecordingsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__FindRecordingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindRecordingsResponse, SOAP_TYPE__tse__FindRecordingsResponse, sizeof(struct _tse__FindRecordingsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__FindRecordings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindRecordings, sizeof(struct _tse__FindRecordings), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Scope && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxMatches && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_KeepAliveTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Scope || soap_flag_KeepAliveTime > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__FindRecordings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindRecordings, SOAP_TYPE__tse__FindRecordings, sizeof(struct _tse__FindRecordings), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tse__GetMediaAttributesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetMediaAttributesResponse, sizeof(struct _tse__GetMediaAttributesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tse:MediaAttributes", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tse__GetMediaAttributesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetMediaAttributesResponse, SOAP_TYPE__tse__GetMediaAttributesResponse, sizeof(struct _tse__GetMediaAttributesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__GetMediaAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetMediaAttributes, sizeof(struct _tse__GetMediaAttributes), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tse:RecordingTokens", 1, NULL))
./soapC.c:			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Time > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__GetMediaAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetMediaAttributes, SOAP_TYPE__tse__GetMediaAttributes, sizeof(struct _tse__GetMediaAttributes), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__GetRecordingInformationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingInformationResponse, sizeof(struct _tse__GetRecordingInformationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingInformation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingInformation))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__GetRecordingInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingInformationResponse, SOAP_TYPE__tse__GetRecordingInformationResponse, sizeof(struct _tse__GetRecordingInformationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__GetRecordingInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingInformation, sizeof(struct _tse__GetRecordingInformation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__GetRecordingInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingInformation, SOAP_TYPE__tse__GetRecordingInformation, sizeof(struct _tse__GetRecordingInformation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__GetRecordingSummaryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingSummaryResponse, sizeof(struct _tse__GetRecordingSummaryResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Summary && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Summary))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__GetRecordingSummaryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingSummaryResponse, SOAP_TYPE__tse__GetRecordingSummaryResponse, sizeof(struct _tse__GetRecordingSummaryResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__GetRecordingSummary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingSummary, sizeof(struct _tse__GetRecordingSummary), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tse__GetRecordingSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingSummary, SOAP_TYPE__tse__GetRecordingSummary, sizeof(struct _tse__GetRecordingSummary), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetServiceCapabilitiesResponse, sizeof(struct _tse__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tse__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetServiceCapabilitiesResponse, SOAP_TYPE__tse__GetServiceCapabilitiesResponse, sizeof(struct _tse__GetServiceCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tse__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetServiceCapabilities, sizeof(struct _tse__GetServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tse__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetServiceCapabilities, SOAP_TYPE__tse__GetServiceCapabilities, sizeof(struct _tse__GetServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tse__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tse__Capabilities, sizeof(struct tse__Capabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tse__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tse__Capabilities, SOAP_TYPE_tse__Capabilities, sizeof(struct tse__Capabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__GetExportRecordedDataStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetExportRecordedDataStateResponse, sizeof(struct _trc__GetExportRecordedDataStateResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Progress && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_FileProgressStatus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Progress > 0 || !a->FileProgressStatus))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__GetExportRecordedDataStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetExportRecordedDataStateResponse, SOAP_TYPE__trc__GetExportRecordedDataStateResponse, sizeof(struct _trc__GetExportRecordedDataStateResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__GetExportRecordedDataState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetExportRecordedDataState, sizeof(struct _trc__GetExportRecordedDataState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_OperationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->OperationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__GetExportRecordedDataState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetExportRecordedDataState, SOAP_TYPE__trc__GetExportRecordedDataState, sizeof(struct _trc__GetExportRecordedDataState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__StopExportRecordedDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__StopExportRecordedDataResponse, sizeof(struct _trc__StopExportRecordedDataResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Progress && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_FileProgressStatus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Progress > 0 || !a->FileProgressStatus))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__StopExportRecordedDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__StopExportRecordedDataResponse, SOAP_TYPE__trc__StopExportRecordedDataResponse, sizeof(struct _trc__StopExportRecordedDataResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__StopExportRecordedData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__StopExportRecordedData, sizeof(struct _trc__StopExportRecordedData), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_OperationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->OperationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__StopExportRecordedData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__StopExportRecordedData, SOAP_TYPE__trc__StopExportRecordedData, sizeof(struct _trc__StopExportRecordedData), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__ExportRecordedDataResponse_Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__ExportRecordedDataResponse_Extension, sizeof(struct _trc__ExportRecordedDataResponse_Extension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trc__ExportRecordedDataResponse_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__ExportRecordedDataResponse_Extension, SOAP_TYPE__trc__ExportRecordedDataResponse_Extension, sizeof(struct _trc__ExportRecordedDataResponse_Extension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__ExportRecordedDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__ExportRecordedDataResponse, sizeof(struct _trc__ExportRecordedDataResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_OperationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trc:FileNames", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->OperationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__ExportRecordedDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__ExportRecordedDataResponse, SOAP_TYPE__trc__ExportRecordedDataResponse, sizeof(struct _trc__ExportRecordedDataResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__ExportRecordedData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__ExportRecordedData, sizeof(struct _trc__ExportRecordedData), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SearchScope && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_FileFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_StorageDestination && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchScope || !a->FileFormat || !a->StorageDestination))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__ExportRecordedData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__ExportRecordedData, SOAP_TYPE__trc__ExportRecordedData, sizeof(struct _trc__ExportRecordedData), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__GetRecordingOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingOptionsResponse, sizeof(struct _trc__GetRecordingOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Options))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__GetRecordingOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingOptionsResponse, SOAP_TYPE__trc__GetRecordingOptionsResponse, sizeof(struct _trc__GetRecordingOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__GetRecordingOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingOptions, sizeof(struct _trc__GetRecordingOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__GetRecordingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingOptions, SOAP_TYPE__trc__GetRecordingOptions, sizeof(struct _trc__GetRecordingOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__GetRecordingJobStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobStateResponse, sizeof(struct _trc__GetRecordingJobStateResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->State))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__GetRecordingJobStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobStateResponse, SOAP_TYPE__trc__GetRecordingJobStateResponse, sizeof(struct _trc__GetRecordingJobStateResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__GetRecordingJobState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobState, sizeof(struct _trc__GetRecordingJobState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__GetRecordingJobState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobState, SOAP_TYPE__trc__GetRecordingJobState, sizeof(struct _trc__GetRecordingJobState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__SetRecordingJobModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingJobModeResponse, sizeof(struct _trc__SetRecordingJobModeResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trc__SetRecordingJobModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingJobModeResponse, SOAP_TYPE__trc__SetRecordingJobModeResponse, sizeof(struct _trc__SetRecordingJobModeResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__SetRecordingJobMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingJobMode, sizeof(struct _trc__SetRecordingJobMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Mode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobToken || !a->Mode))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__SetRecordingJobMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingJobMode, SOAP_TYPE__trc__SetRecordingJobMode, sizeof(struct _trc__SetRecordingJobMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__GetRecordingJobConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse, sizeof(struct _trc__GetRecordingJobConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__GetRecordingJobConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse, sizeof(struct _trc__GetRecordingJobConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__GetRecordingJobConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobConfiguration, sizeof(struct _trc__GetRecordingJobConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__GetRecordingJobConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobConfiguration, SOAP_TYPE__trc__GetRecordingJobConfiguration, sizeof(struct _trc__GetRecordingJobConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__SetRecordingJobConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse, sizeof(struct _trc__SetRecordingJobConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__SetRecordingJobConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse, sizeof(struct _trc__SetRecordingJobConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__SetRecordingJobConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingJobConfiguration, sizeof(struct _trc__SetRecordingJobConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobToken || !a->JobConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__SetRecordingJobConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingJobConfiguration, SOAP_TYPE__trc__SetRecordingJobConfiguration, sizeof(struct _trc__SetRecordingJobConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trc__GetRecordingJobsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobsResponse, sizeof(struct _trc__GetRecordingJobsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trc:JobItem", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trc__GetRecordingJobsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobsResponse, SOAP_TYPE__trc__GetRecordingJobsResponse, sizeof(struct _trc__GetRecordingJobsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__GetRecordingJobs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobs, sizeof(struct _trc__GetRecordingJobs), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trc__GetRecordingJobs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobs, SOAP_TYPE__trc__GetRecordingJobs, sizeof(struct _trc__GetRecordingJobs), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__DeleteRecordingJobResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteRecordingJobResponse, sizeof(struct _trc__DeleteRecordingJobResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trc__DeleteRecordingJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteRecordingJobResponse, SOAP_TYPE__trc__DeleteRecordingJobResponse, sizeof(struct _trc__DeleteRecordingJobResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__DeleteRecordingJob *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteRecordingJob, sizeof(struct _trc__DeleteRecordingJob), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__DeleteRecordingJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteRecordingJob, SOAP_TYPE__trc__DeleteRecordingJob, sizeof(struct _trc__DeleteRecordingJob), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__CreateRecordingJobResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateRecordingJobResponse, sizeof(struct _trc__CreateRecordingJobResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobToken || !a->JobConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__CreateRecordingJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateRecordingJobResponse, SOAP_TYPE__trc__CreateRecordingJobResponse, sizeof(struct _trc__CreateRecordingJobResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__CreateRecordingJob *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateRecordingJob, sizeof(struct _trc__CreateRecordingJob), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__CreateRecordingJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateRecordingJob, SOAP_TYPE__trc__CreateRecordingJob, sizeof(struct _trc__CreateRecordingJob), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__SetTrackConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetTrackConfigurationResponse, sizeof(struct _trc__SetTrackConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trc__SetTrackConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetTrackConfigurationResponse, SOAP_TYPE__trc__SetTrackConfigurationResponse, sizeof(struct _trc__SetTrackConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__SetTrackConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetTrackConfiguration, sizeof(struct _trc__SetTrackConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_TrackConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->TrackToken || !a->TrackConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__SetTrackConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetTrackConfiguration, SOAP_TYPE__trc__SetTrackConfiguration, sizeof(struct _trc__SetTrackConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__GetTrackConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetTrackConfigurationResponse, sizeof(struct _trc__GetTrackConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_TrackConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->TrackConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__GetTrackConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetTrackConfigurationResponse, SOAP_TYPE__trc__GetTrackConfigurationResponse, sizeof(struct _trc__GetTrackConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__GetTrackConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetTrackConfiguration, sizeof(struct _trc__GetTrackConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->TrackToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__GetTrackConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetTrackConfiguration, SOAP_TYPE__trc__GetTrackConfiguration, sizeof(struct _trc__GetTrackConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__DeleteTrackResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteTrackResponse, sizeof(struct _trc__DeleteTrackResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trc__DeleteTrackResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteTrackResponse, SOAP_TYPE__trc__DeleteTrackResponse, sizeof(struct _trc__DeleteTrackResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__DeleteTrack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteTrack, sizeof(struct _trc__DeleteTrack), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->TrackToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__DeleteTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteTrack, SOAP_TYPE__trc__DeleteTrack, sizeof(struct _trc__DeleteTrack), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__CreateTrackResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateTrackResponse, sizeof(struct _trc__CreateTrackResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->TrackToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__CreateTrackResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateTrackResponse, SOAP_TYPE__trc__CreateTrackResponse, sizeof(struct _trc__CreateTrackResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__CreateTrack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateTrack, sizeof(struct _trc__CreateTrack), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_TrackConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->TrackConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__CreateTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateTrack, SOAP_TYPE__trc__CreateTrack, sizeof(struct _trc__CreateTrack), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__GetRecordingConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingConfigurationResponse, sizeof(struct _trc__GetRecordingConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__GetRecordingConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingConfigurationResponse, SOAP_TYPE__trc__GetRecordingConfigurationResponse, sizeof(struct _trc__GetRecordingConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__GetRecordingConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingConfiguration, sizeof(struct _trc__GetRecordingConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__GetRecordingConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingConfiguration, SOAP_TYPE__trc__GetRecordingConfiguration, sizeof(struct _trc__GetRecordingConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__SetRecordingConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingConfigurationResponse, sizeof(struct _trc__SetRecordingConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trc__SetRecordingConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingConfigurationResponse, SOAP_TYPE__trc__SetRecordingConfigurationResponse, sizeof(struct _trc__SetRecordingConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__SetRecordingConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingConfiguration, sizeof(struct _trc__SetRecordingConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_RecordingConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->RecordingConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__SetRecordingConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingConfiguration, SOAP_TYPE__trc__SetRecordingConfiguration, sizeof(struct _trc__SetRecordingConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trc__GetRecordingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingsResponse, sizeof(struct _trc__GetRecordingsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trc:RecordingItem", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trc__GetRecordingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingsResponse, SOAP_TYPE__trc__GetRecordingsResponse, sizeof(struct _trc__GetRecordingsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__GetRecordings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordings, sizeof(struct _trc__GetRecordings), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trc__GetRecordings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordings, SOAP_TYPE__trc__GetRecordings, sizeof(struct _trc__GetRecordings), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__DeleteRecordingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteRecordingResponse, sizeof(struct _trc__DeleteRecordingResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trc__DeleteRecordingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteRecordingResponse, SOAP_TYPE__trc__DeleteRecordingResponse, sizeof(struct _trc__DeleteRecordingResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__DeleteRecording *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteRecording, sizeof(struct _trc__DeleteRecording), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__DeleteRecording *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteRecording, SOAP_TYPE__trc__DeleteRecording, sizeof(struct _trc__DeleteRecording), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__CreateRecordingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateRecordingResponse, sizeof(struct _trc__CreateRecordingResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__CreateRecordingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateRecordingResponse, SOAP_TYPE__trc__CreateRecordingResponse, sizeof(struct _trc__CreateRecordingResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__CreateRecording *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateRecording, sizeof(struct _trc__CreateRecording), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__CreateRecording *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateRecording, SOAP_TYPE__trc__CreateRecording, sizeof(struct _trc__CreateRecording), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetServiceCapabilitiesResponse, sizeof(struct _trc__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trc__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetServiceCapabilitiesResponse, SOAP_TYPE__trc__GetServiceCapabilitiesResponse, sizeof(struct _trc__GetServiceCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trc__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetServiceCapabilities, sizeof(struct _trc__GetServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trc__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetServiceCapabilities, SOAP_TYPE__trc__GetServiceCapabilities, sizeof(struct _trc__GetServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct trc__TrackOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trc__TrackOptions, sizeof(struct trc__TrackOptions), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct trc__TrackOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trc__TrackOptions, SOAP_TYPE_trc__TrackOptions, sizeof(struct trc__TrackOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct trc__JobOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trc__JobOptions, sizeof(struct trc__JobOptions), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct trc__JobOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trc__JobOptions, SOAP_TYPE_trc__JobOptions, sizeof(struct trc__JobOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct trc__RecordingOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trc__RecordingOptions, sizeof(struct trc__RecordingOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Job && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Track && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Job || !a->Track))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct trc__RecordingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trc__RecordingOptions, SOAP_TYPE_trc__RecordingOptions, sizeof(struct trc__RecordingOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct trc__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trc__Capabilities, sizeof(struct trc__Capabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct trc__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trc__Capabilities, SOAP_TYPE_trc__Capabilities, sizeof(struct trc__Capabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trv__GetReceiverStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiverStateResponse, sizeof(struct _trv__GetReceiverStateResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ReceiverState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ReceiverState))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trv__GetReceiverStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiverStateResponse, SOAP_TYPE__trv__GetReceiverStateResponse, sizeof(struct _trv__GetReceiverStateResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trv__GetReceiverState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiverState, sizeof(struct _trv__GetReceiverState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ReceiverToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trv__GetReceiverState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiverState, SOAP_TYPE__trv__GetReceiverState, sizeof(struct _trv__GetReceiverState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trv__SetReceiverModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__SetReceiverModeResponse, sizeof(struct _trv__SetReceiverModeResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trv__SetReceiverModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__SetReceiverModeResponse, SOAP_TYPE__trv__SetReceiverModeResponse, sizeof(struct _trv__SetReceiverModeResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trv__SetReceiverMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__SetReceiverMode, sizeof(struct _trv__SetReceiverMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ReceiverToken || soap_flag_Mode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trv__SetReceiverMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__SetReceiverMode, SOAP_TYPE__trv__SetReceiverMode, sizeof(struct _trv__SetReceiverMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trv__ConfigureReceiverResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__ConfigureReceiverResponse, sizeof(struct _trv__ConfigureReceiverResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trv__ConfigureReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__ConfigureReceiverResponse, SOAP_TYPE__trv__ConfigureReceiverResponse, sizeof(struct _trv__ConfigureReceiverResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trv__ConfigureReceiver *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__ConfigureReceiver, sizeof(struct _trv__ConfigureReceiver), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ReceiverToken || !a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trv__ConfigureReceiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__ConfigureReceiver, SOAP_TYPE__trv__ConfigureReceiver, sizeof(struct _trv__ConfigureReceiver), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trv__DeleteReceiverResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__DeleteReceiverResponse, sizeof(struct _trv__DeleteReceiverResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trv__DeleteReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__DeleteReceiverResponse, SOAP_TYPE__trv__DeleteReceiverResponse, sizeof(struct _trv__DeleteReceiverResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trv__DeleteReceiver *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__DeleteReceiver, sizeof(struct _trv__DeleteReceiver), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ReceiverToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trv__DeleteReceiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__DeleteReceiver, SOAP_TYPE__trv__DeleteReceiver, sizeof(struct _trv__DeleteReceiver), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trv__CreateReceiverResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__CreateReceiverResponse, sizeof(struct _trv__CreateReceiverResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Receiver && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Receiver))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trv__CreateReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__CreateReceiverResponse, SOAP_TYPE__trv__CreateReceiverResponse, sizeof(struct _trv__CreateReceiverResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trv__CreateReceiver *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__CreateReceiver, sizeof(struct _trv__CreateReceiver), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trv__CreateReceiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__CreateReceiver, SOAP_TYPE__trv__CreateReceiver, sizeof(struct _trv__CreateReceiver), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trv__GetReceiverResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiverResponse, sizeof(struct _trv__GetReceiverResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Receiver && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Receiver))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trv__GetReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiverResponse, SOAP_TYPE__trv__GetReceiverResponse, sizeof(struct _trv__GetReceiverResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trv__GetReceiver *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiver, sizeof(struct _trv__GetReceiver), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ReceiverToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trv__GetReceiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiver, SOAP_TYPE__trv__GetReceiver, sizeof(struct _trv__GetReceiver), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trv__GetReceiversResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiversResponse, sizeof(struct _trv__GetReceiversResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trv:Receivers", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trv__GetReceiversResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiversResponse, SOAP_TYPE__trv__GetReceiversResponse, sizeof(struct _trv__GetReceiversResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trv__GetReceivers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceivers, sizeof(struct _trv__GetReceivers), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trv__GetReceivers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceivers, SOAP_TYPE__trv__GetReceivers, sizeof(struct _trv__GetReceivers), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trv__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetServiceCapabilitiesResponse, sizeof(struct _trv__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trv__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetServiceCapabilitiesResponse, SOAP_TYPE__trv__GetServiceCapabilitiesResponse, sizeof(struct _trv__GetServiceCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trv__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetServiceCapabilities, sizeof(struct _trv__GetServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trv__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetServiceCapabilities, SOAP_TYPE__trv__GetServiceCapabilities, sizeof(struct _trv__GetServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct trv__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trv__Capabilities, sizeof(struct trv__Capabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct trv__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trv__Capabilities, SOAP_TYPE_trv__Capabilities, sizeof(struct trv__Capabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tptz__GetCompatibleConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse, sizeof(struct _tptz__GetCompatibleConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:PTZConfiguration", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__GetCompatibleConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse, sizeof(struct _tptz__GetCompatibleConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetCompatibleConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetCompatibleConfigurations, sizeof(struct _tptz__GetCompatibleConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GetCompatibleConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetCompatibleConfigurations, SOAP_TYPE__tptz__GetCompatibleConfigurations, sizeof(struct _tptz__GetCompatibleConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__RemovePresetTourResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePresetTourResponse, sizeof(struct _tptz__RemovePresetTourResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__RemovePresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePresetTourResponse, SOAP_TYPE__tptz__RemovePresetTourResponse, sizeof(struct _tptz__RemovePresetTourResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__RemovePresetTour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePresetTour, sizeof(struct _tptz__RemovePresetTour), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->PresetTourToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__RemovePresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePresetTour, SOAP_TYPE__tptz__RemovePresetTour, sizeof(struct _tptz__RemovePresetTour), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__OperatePresetTourResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__OperatePresetTourResponse, sizeof(struct _tptz__OperatePresetTourResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__OperatePresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__OperatePresetTourResponse, SOAP_TYPE__tptz__OperatePresetTourResponse, sizeof(struct _tptz__OperatePresetTourResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__OperatePresetTour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__OperatePresetTour, sizeof(struct _tptz__OperatePresetTour), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Operation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->PresetTourToken || soap_flag_Operation > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__OperatePresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__OperatePresetTour, SOAP_TYPE__tptz__OperatePresetTour, sizeof(struct _tptz__OperatePresetTour), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__ModifyPresetTourResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ModifyPresetTourResponse, sizeof(struct _tptz__ModifyPresetTourResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__ModifyPresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ModifyPresetTourResponse, SOAP_TYPE__tptz__ModifyPresetTourResponse, sizeof(struct _tptz__ModifyPresetTourResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__ModifyPresetTour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ModifyPresetTour, sizeof(struct _tptz__ModifyPresetTour), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PresetTour && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->PresetTour))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__ModifyPresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ModifyPresetTour, SOAP_TYPE__tptz__ModifyPresetTour, sizeof(struct _tptz__ModifyPresetTour), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__CreatePresetTourResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__CreatePresetTourResponse, sizeof(struct _tptz__CreatePresetTourResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PresetTourToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__CreatePresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__CreatePresetTourResponse, SOAP_TYPE__tptz__CreatePresetTourResponse, sizeof(struct _tptz__CreatePresetTourResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__CreatePresetTour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__CreatePresetTour, sizeof(struct _tptz__CreatePresetTour), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__CreatePresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__CreatePresetTour, SOAP_TYPE__tptz__CreatePresetTour, sizeof(struct _tptz__CreatePresetTour), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetPresetTourOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, sizeof(struct _tptz__GetPresetTourOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Options))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GetPresetTourOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, sizeof(struct _tptz__GetPresetTourOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetPresetTourOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTourOptions, sizeof(struct _tptz__GetPresetTourOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GetPresetTourOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTourOptions, SOAP_TYPE__tptz__GetPresetTourOptions, sizeof(struct _tptz__GetPresetTourOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetPresetTourResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTourResponse, sizeof(struct _tptz__GetPresetTourResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PresetTour && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PresetTour))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GetPresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTourResponse, SOAP_TYPE__tptz__GetPresetTourResponse, sizeof(struct _tptz__GetPresetTourResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetPresetTour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTour, sizeof(struct _tptz__GetPresetTour), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->PresetTourToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GetPresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTour, SOAP_TYPE__tptz__GetPresetTour, sizeof(struct _tptz__GetPresetTour), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tptz__GetPresetToursResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetToursResponse, sizeof(struct _tptz__GetPresetToursResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:PresetTour", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__GetPresetToursResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetToursResponse, SOAP_TYPE__tptz__GetPresetToursResponse, sizeof(struct _tptz__GetPresetToursResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetPresetTours *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTours, sizeof(struct _tptz__GetPresetTours), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GetPresetTours *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTours, SOAP_TYPE__tptz__GetPresetTours, sizeof(struct _tptz__GetPresetTours), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__StopResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__StopResponse, sizeof(struct _tptz__StopResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__StopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__StopResponse, SOAP_TYPE__tptz__StopResponse, sizeof(struct _tptz__StopResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__Stop *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__Stop, sizeof(struct _tptz__Stop), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__Stop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__Stop, SOAP_TYPE__tptz__Stop, sizeof(struct _tptz__Stop), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__AbsoluteMoveResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__AbsoluteMoveResponse, sizeof(struct _tptz__AbsoluteMoveResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__AbsoluteMoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__AbsoluteMoveResponse, SOAP_TYPE__tptz__AbsoluteMoveResponse, sizeof(struct _tptz__AbsoluteMoveResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__AbsoluteMove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__AbsoluteMove, sizeof(struct _tptz__AbsoluteMove), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->Position))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__AbsoluteMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__AbsoluteMove, SOAP_TYPE__tptz__AbsoluteMove, sizeof(struct _tptz__AbsoluteMove), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__RelativeMoveResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RelativeMoveResponse, sizeof(struct _tptz__RelativeMoveResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__RelativeMoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RelativeMoveResponse, SOAP_TYPE__tptz__RelativeMoveResponse, sizeof(struct _tptz__RelativeMoveResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__RelativeMove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RelativeMove, sizeof(struct _tptz__RelativeMove), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Translation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->Translation))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__RelativeMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RelativeMove, SOAP_TYPE__tptz__RelativeMove, sizeof(struct _tptz__RelativeMove), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__ContinuousMoveResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ContinuousMoveResponse, sizeof(struct _tptz__ContinuousMoveResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__ContinuousMoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ContinuousMoveResponse, SOAP_TYPE__tptz__ContinuousMoveResponse, sizeof(struct _tptz__ContinuousMoveResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__ContinuousMove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ContinuousMove, sizeof(struct _tptz__ContinuousMove), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Velocity && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Timeout && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->Velocity))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__ContinuousMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ContinuousMove, SOAP_TYPE__tptz__ContinuousMove, sizeof(struct _tptz__ContinuousMove), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__SetHomePositionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetHomePositionResponse, sizeof(struct _tptz__SetHomePositionResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__SetHomePositionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetHomePositionResponse, SOAP_TYPE__tptz__SetHomePositionResponse, sizeof(struct _tptz__SetHomePositionResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__SetHomePosition *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetHomePosition, sizeof(struct _tptz__SetHomePosition), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__SetHomePosition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetHomePosition, SOAP_TYPE__tptz__SetHomePosition, sizeof(struct _tptz__SetHomePosition), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GotoHomePositionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoHomePositionResponse, sizeof(struct _tptz__GotoHomePositionResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__GotoHomePositionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoHomePositionResponse, SOAP_TYPE__tptz__GotoHomePositionResponse, sizeof(struct _tptz__GotoHomePositionResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GotoHomePosition *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoHomePosition, sizeof(struct _tptz__GotoHomePosition), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GotoHomePosition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoHomePosition, SOAP_TYPE__tptz__GotoHomePosition, sizeof(struct _tptz__GotoHomePosition), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetStatusResponse, sizeof(struct _tptz__GetStatusResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PTZStatus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PTZStatus))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GetStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetStatusResponse, SOAP_TYPE__tptz__GetStatusResponse, sizeof(struct _tptz__GetStatusResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetStatus, sizeof(struct _tptz__GetStatus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GetStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetStatus, SOAP_TYPE__tptz__GetStatus, sizeof(struct _tptz__GetStatus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GotoPresetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoPresetResponse, sizeof(struct _tptz__GotoPresetResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__GotoPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoPresetResponse, SOAP_TYPE__tptz__GotoPresetResponse, sizeof(struct _tptz__GotoPresetResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GotoPreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoPreset, sizeof(struct _tptz__GotoPreset), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->PresetToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GotoPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoPreset, SOAP_TYPE__tptz__GotoPreset, sizeof(struct _tptz__GotoPreset), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__RemovePresetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePresetResponse, sizeof(struct _tptz__RemovePresetResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__RemovePresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePresetResponse, SOAP_TYPE__tptz__RemovePresetResponse, sizeof(struct _tptz__RemovePresetResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__RemovePreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePreset, sizeof(struct _tptz__RemovePreset), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->PresetToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__RemovePreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePreset, SOAP_TYPE__tptz__RemovePreset, sizeof(struct _tptz__RemovePreset), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__SetPresetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetPresetResponse, sizeof(struct _tptz__SetPresetResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PresetToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__SetPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetPresetResponse, SOAP_TYPE__tptz__SetPresetResponse, sizeof(struct _tptz__SetPresetResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__SetPreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetPreset, sizeof(struct _tptz__SetPreset), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PresetName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__SetPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetPreset, SOAP_TYPE__tptz__SetPreset, sizeof(struct _tptz__SetPreset), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tptz__GetPresetsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetsResponse, sizeof(struct _tptz__GetPresetsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:Preset", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__GetPresetsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetsResponse, SOAP_TYPE__tptz__GetPresetsResponse, sizeof(struct _tptz__GetPresetsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetPresets *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresets, sizeof(struct _tptz__GetPresets), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GetPresets *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresets, SOAP_TYPE__tptz__GetPresets, sizeof(struct _tptz__GetPresets), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__SendAuxiliaryCommandResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, sizeof(struct _tptz__SendAuxiliaryCommandResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AuxiliaryResponse && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->AuxiliaryResponse))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__SendAuxiliaryCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, sizeof(struct _tptz__SendAuxiliaryCommandResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__SendAuxiliaryCommand *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SendAuxiliaryCommand, sizeof(struct _tptz__SendAuxiliaryCommand), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_AuxiliaryData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->AuxiliaryData))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__SendAuxiliaryCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SendAuxiliaryCommand, SOAP_TYPE__tptz__SendAuxiliaryCommand, sizeof(struct _tptz__SendAuxiliaryCommand), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, sizeof(struct _tptz__GetConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PTZConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PTZConfigurationOptions))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GetConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, sizeof(struct _tptz__GetConfigurationOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationOptions, sizeof(struct _tptz__GetConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GetConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationOptions, SOAP_TYPE__tptz__GetConfigurationOptions, sizeof(struct _tptz__GetConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__SetConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetConfigurationResponse, sizeof(struct _tptz__SetConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___SetConfigurationResponse_sequence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__SetConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetConfigurationResponse, SOAP_TYPE__tptz__SetConfigurationResponse, sizeof(struct _tptz__SetConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__SetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetConfiguration, sizeof(struct _tptz__SetConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PTZConfiguration || soap_flag_ForcePersistence > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__SetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetConfiguration, SOAP_TYPE__tptz__SetConfiguration, sizeof(struct _tptz__SetConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationResponse, sizeof(struct _tptz__GetConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PTZConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GetConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationResponse, SOAP_TYPE__tptz__GetConfigurationResponse, sizeof(struct _tptz__GetConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfiguration, sizeof(struct _tptz__GetConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PTZConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PTZConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfiguration, SOAP_TYPE__tptz__GetConfiguration, sizeof(struct _tptz__GetConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tptz__GetConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationsResponse, sizeof(struct _tptz__GetConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:PTZConfiguration", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__GetConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationsResponse, SOAP_TYPE__tptz__GetConfigurationsResponse, sizeof(struct _tptz__GetConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurations, sizeof(struct _tptz__GetConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__GetConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurations, SOAP_TYPE__tptz__GetConfigurations, sizeof(struct _tptz__GetConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetNodeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNodeResponse, sizeof(struct _tptz__GetNodeResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PTZNode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PTZNode))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GetNodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNodeResponse, SOAP_TYPE__tptz__GetNodeResponse, sizeof(struct _tptz__GetNodeResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetNode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNode, sizeof(struct _tptz__GetNode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_NodeToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->NodeToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GetNode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNode, SOAP_TYPE__tptz__GetNode, sizeof(struct _tptz__GetNode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZNode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNode, sizeof(struct tt__PTZNode), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_SupportedPTZSpaces && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaximumNumberOfPresets && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_HomeSupported && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AuxiliaryCommands", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SupportedPTZSpaces || soap_flag_MaximumNumberOfPresets > 0 || soap_flag_HomeSupported > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PTZNode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNode, SOAP_TYPE_tt__PTZNode, sizeof(struct tt__PTZNode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tptz__GetNodesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNodesResponse, sizeof(struct _tptz__GetNodesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:PTZNode", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__GetNodesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNodesResponse, SOAP_TYPE__tptz__GetNodesResponse, sizeof(struct _tptz__GetNodesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetNodes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNodes, sizeof(struct _tptz__GetNodes), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__GetNodes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNodes, SOAP_TYPE__tptz__GetNodes, sizeof(struct _tptz__GetNodes), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, sizeof(struct _tptz__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tptz__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, sizeof(struct _tptz__GetServiceCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tptz__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetServiceCapabilities, sizeof(struct _tptz__GetServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tptz__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetServiceCapabilities, SOAP_TYPE__tptz__GetServiceCapabilities, sizeof(struct _tptz__GetServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tptz__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tptz__Capabilities, sizeof(struct tptz__Capabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tptz__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tptz__Capabilities, SOAP_TYPE_tptz__Capabilities, sizeof(struct tptz__Capabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__DeleteOSDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__DeleteOSDResponse, sizeof(struct _trt__DeleteOSDResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__DeleteOSDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__DeleteOSDResponse, SOAP_TYPE__trt__DeleteOSDResponse, sizeof(struct _trt__DeleteOSDResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__DeleteOSD *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__DeleteOSD, sizeof(struct _trt__DeleteOSD), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_OSDToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->OSDToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__DeleteOSD *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__DeleteOSD, SOAP_TYPE__trt__DeleteOSD, sizeof(struct _trt__DeleteOSD), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__CreateOSDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__CreateOSDResponse, sizeof(struct _trt__CreateOSDResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_OSDToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->OSDToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__CreateOSDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__CreateOSDResponse, SOAP_TYPE__trt__CreateOSDResponse, sizeof(struct _trt__CreateOSDResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__CreateOSD *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__CreateOSD, sizeof(struct _trt__CreateOSD), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_OSD && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->OSD))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__CreateOSD *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__CreateOSD, SOAP_TYPE__trt__CreateOSD, sizeof(struct _trt__CreateOSD), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetOSDOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSDOptionsResponse, sizeof(struct _trt__GetOSDOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_OSDOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->OSDOptions))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetOSDOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSDOptionsResponse, SOAP_TYPE__trt__GetOSDOptionsResponse, sizeof(struct _trt__GetOSDOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetOSDOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSDOptions, sizeof(struct _trt__GetOSDOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetOSDOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSDOptions, SOAP_TYPE__trt__GetOSDOptions, sizeof(struct _trt__GetOSDOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__SetOSDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetOSDResponse, sizeof(struct _trt__SetOSDResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__SetOSDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetOSDResponse, SOAP_TYPE__trt__SetOSDResponse, sizeof(struct _trt__SetOSDResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__SetOSD *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetOSD, sizeof(struct _trt__SetOSD), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_OSD && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->OSD))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__SetOSD *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetOSD, SOAP_TYPE__trt__SetOSD, sizeof(struct _trt__SetOSD), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetOSDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSDResponse, sizeof(struct _trt__GetOSDResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_OSD && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->OSD))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetOSDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSDResponse, SOAP_TYPE__trt__GetOSDResponse, sizeof(struct _trt__GetOSDResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetOSD *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSD, sizeof(struct _trt__GetOSD), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_OSDToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->OSDToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetOSD *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSD, SOAP_TYPE__trt__GetOSD, sizeof(struct _trt__GetOSD), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__OSDConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfiguration, sizeof(struct tt__OSDConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoSourceConfigurationToken && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_TextString && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Image && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceConfigurationToken || soap_flag_Type > 0 || !a->Position))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__OSDConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfiguration, SOAP_TYPE_tt__OSDConfiguration, sizeof(struct tt__OSDConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetOSDsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSDsResponse, sizeof(struct _trt__GetOSDsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:OSDs", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetOSDsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSDsResponse, SOAP_TYPE__trt__GetOSDsResponse, sizeof(struct _trt__GetOSDsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetOSDs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSDs, sizeof(struct _trt__GetOSDs), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetOSDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSDs, SOAP_TYPE__trt__GetOSDs, sizeof(struct _trt__GetOSDs), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetVideoSourceModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetVideoSourceModeResponse, sizeof(struct _trt__SetVideoSourceModeResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Reboot && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Reboot > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__SetVideoSourceModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetVideoSourceModeResponse, SOAP_TYPE__trt__SetVideoSourceModeResponse, sizeof(struct _trt__SetVideoSourceModeResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetVideoSourceMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetVideoSourceMode, sizeof(struct _trt__SetVideoSourceMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_VideoSourceModeToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken || !a->VideoSourceModeToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__SetVideoSourceMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetVideoSourceMode, SOAP_TYPE__trt__SetVideoSourceMode, sizeof(struct _trt__SetVideoSourceMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetVideoSourceModesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceModesResponse, sizeof(struct _trt__GetVideoSourceModesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:VideoSourceModes", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeVideoSourceModes < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetVideoSourceModesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceModesResponse, SOAP_TYPE__trt__GetVideoSourceModesResponse, sizeof(struct _trt__GetVideoSourceModesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetVideoSourceModes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceModes, sizeof(struct _trt__GetVideoSourceModes), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetVideoSourceModes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceModes, SOAP_TYPE__trt__GetVideoSourceModes, sizeof(struct _trt__GetVideoSourceModes), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetSnapshotUriResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetSnapshotUriResponse, sizeof(struct _trt__GetSnapshotUriResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_MediaUri && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->MediaUri))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetSnapshotUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetSnapshotUriResponse, SOAP_TYPE__trt__GetSnapshotUriResponse, sizeof(struct _trt__GetSnapshotUriResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetSnapshotUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetSnapshotUri, sizeof(struct _trt__GetSnapshotUri), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetSnapshotUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetSnapshotUri, SOAP_TYPE__trt__GetSnapshotUri, sizeof(struct _trt__GetSnapshotUri), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetSynchronizationPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetSynchronizationPointResponse, sizeof(struct _trt__SetSynchronizationPointResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__SetSynchronizationPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetSynchronizationPointResponse, SOAP_TYPE__trt__SetSynchronizationPointResponse, sizeof(struct _trt__SetSynchronizationPointResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetSynchronizationPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetSynchronizationPoint, sizeof(struct _trt__SetSynchronizationPoint), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__SetSynchronizationPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetSynchronizationPoint, SOAP_TYPE__trt__SetSynchronizationPoint, sizeof(struct _trt__SetSynchronizationPoint), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__StopMulticastStreamingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__StopMulticastStreamingResponse, sizeof(struct _trt__StopMulticastStreamingResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__StopMulticastStreamingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__StopMulticastStreamingResponse, SOAP_TYPE__trt__StopMulticastStreamingResponse, sizeof(struct _trt__StopMulticastStreamingResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__StopMulticastStreaming *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__StopMulticastStreaming, sizeof(struct _trt__StopMulticastStreaming), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__StopMulticastStreaming *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__StopMulticastStreaming, SOAP_TYPE__trt__StopMulticastStreaming, sizeof(struct _trt__StopMulticastStreaming), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__StartMulticastStreamingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__StartMulticastStreamingResponse, sizeof(struct _trt__StartMulticastStreamingResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__StartMulticastStreamingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__StartMulticastStreamingResponse, SOAP_TYPE__trt__StartMulticastStreamingResponse, sizeof(struct _trt__StartMulticastStreamingResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__StartMulticastStreaming *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__StartMulticastStreaming, sizeof(struct _trt__StartMulticastStreaming), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__StartMulticastStreaming *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__StartMulticastStreaming, SOAP_TYPE__trt__StartMulticastStreaming, sizeof(struct _trt__StartMulticastStreaming), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetStreamUriResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetStreamUriResponse, sizeof(struct _trt__GetStreamUriResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_MediaUri && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->MediaUri))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetStreamUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetStreamUriResponse, SOAP_TYPE__trt__GetStreamUriResponse, sizeof(struct _trt__GetStreamUriResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetStreamUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetStreamUri, sizeof(struct _trt__GetStreamUri), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_StreamSetup && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->StreamSetup || !a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetStreamUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetStreamUri, SOAP_TYPE__trt__GetStreamUri, sizeof(struct _trt__GetStreamUri), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_TotalNumber && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_JPEG && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TotalNumber > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstances), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstances), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioDecoderConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioDecoderConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Options))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetAudioDecoderConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioDecoderConfigurationOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioDecoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions, sizeof(struct _trt__GetAudioDecoderConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetAudioDecoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions, sizeof(struct _trt__GetAudioDecoderConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioOutputConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse, sizeof(struct _trt__GetAudioOutputConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Options))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetAudioOutputConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse, sizeof(struct _trt__GetAudioOutputConfigurationOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioOutputConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions, sizeof(struct _trt__GetAudioOutputConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetAudioOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions, sizeof(struct _trt__GetAudioOutputConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetMetadataConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse, sizeof(struct _trt__GetMetadataConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Options))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetMetadataConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse, sizeof(struct _trt__GetMetadataConfigurationOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetMetadataConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetMetadataConfigurationOptions, sizeof(struct _trt__GetMetadataConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetMetadataConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetMetadataConfigurationOptions, SOAP_TYPE__trt__GetMetadataConfigurationOptions, sizeof(struct _trt__GetMetadataConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioEncoderConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Options))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetAudioEncoderConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioEncoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions, sizeof(struct _trt__GetAudioEncoderConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetAudioEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions, sizeof(struct _trt__GetAudioEncoderConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioSourceConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse, sizeof(struct _trt__GetAudioSourceConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Options))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetAudioSourceConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse, sizeof(struct _trt__GetAudioSourceConfigurationOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioSourceConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions, sizeof(struct _trt__GetAudioSourceConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetAudioSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions, sizeof(struct _trt__GetAudioSourceConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetVideoEncoderConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Options))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetVideoEncoderConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetVideoEncoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions, sizeof(struct _trt__GetVideoEncoderConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetVideoEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions, sizeof(struct _trt__GetVideoEncoderConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetVideoSourceConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse, sizeof(struct _trt__GetVideoSourceConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Options))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetVideoSourceConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse, SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse, sizeof(struct _trt__GetVideoSourceConfigurationOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetVideoSourceConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions, sizeof(struct _trt__GetVideoSourceConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetVideoSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions, sizeof(struct _trt__GetVideoSourceConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetAudioDecoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse, sizeof(struct _trt__SetAudioDecoderConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__SetAudioDecoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse, SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse, sizeof(struct _trt__SetAudioDecoderConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetAudioDecoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetAudioDecoderConfiguration, sizeof(struct _trt__SetAudioDecoderConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__SetAudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetAudioDecoderConfiguration, SOAP_TYPE__trt__SetAudioDecoderConfiguration, sizeof(struct _trt__SetAudioDecoderConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetAudioOutputConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetAudioOutputConfigurationResponse, sizeof(struct _trt__SetAudioOutputConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__SetAudioOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetAudioOutputConfigurationResponse, SOAP_TYPE__trt__SetAudioOutputConfigurationResponse, sizeof(struct _trt__SetAudioOutputConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetAudioOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetAudioOutputConfiguration, sizeof(struct _trt__SetAudioOutputConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__SetAudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetAudioOutputConfiguration, SOAP_TYPE__trt__SetAudioOutputConfiguration, sizeof(struct _trt__SetAudioOutputConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetMetadataConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetMetadataConfigurationResponse, sizeof(struct _trt__SetMetadataConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__SetMetadataConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetMetadataConfigurationResponse, SOAP_TYPE__trt__SetMetadataConfigurationResponse, sizeof(struct _trt__SetMetadataConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetMetadataConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetMetadataConfiguration, sizeof(struct _trt__SetMetadataConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__SetMetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetMetadataConfiguration, SOAP_TYPE__trt__SetMetadataConfiguration, sizeof(struct _trt__SetMetadataConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetVideoAnalyticsConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse, sizeof(struct _trt__SetVideoAnalyticsConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__SetVideoAnalyticsConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse, SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse, sizeof(struct _trt__SetVideoAnalyticsConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetVideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetVideoAnalyticsConfiguration, sizeof(struct _trt__SetVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__SetVideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetVideoAnalyticsConfiguration, SOAP_TYPE__trt__SetVideoAnalyticsConfiguration, sizeof(struct _trt__SetVideoAnalyticsConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetAudioSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetAudioSourceConfigurationResponse, sizeof(struct _trt__SetAudioSourceConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__SetAudioSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetAudioSourceConfigurationResponse, SOAP_TYPE__trt__SetAudioSourceConfigurationResponse, sizeof(struct _trt__SetAudioSourceConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetAudioSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetAudioSourceConfiguration, sizeof(struct _trt__SetAudioSourceConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__SetAudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetAudioSourceConfiguration, SOAP_TYPE__trt__SetAudioSourceConfiguration, sizeof(struct _trt__SetAudioSourceConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetAudioEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse, sizeof(struct _trt__SetAudioEncoderConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__SetAudioEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse, SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse, sizeof(struct _trt__SetAudioEncoderConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetAudioEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetAudioEncoderConfiguration, sizeof(struct _trt__SetAudioEncoderConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__SetAudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetAudioEncoderConfiguration, SOAP_TYPE__trt__SetAudioEncoderConfiguration, sizeof(struct _trt__SetAudioEncoderConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetVideoSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetVideoSourceConfigurationResponse, sizeof(struct _trt__SetVideoSourceConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__SetVideoSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetVideoSourceConfigurationResponse, SOAP_TYPE__trt__SetVideoSourceConfigurationResponse, sizeof(struct _trt__SetVideoSourceConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetVideoSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetVideoSourceConfiguration, sizeof(struct _trt__SetVideoSourceConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__SetVideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetVideoSourceConfiguration, SOAP_TYPE__trt__SetVideoSourceConfiguration, sizeof(struct _trt__SetVideoSourceConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetVideoEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse, sizeof(struct _trt__SetVideoEncoderConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__SetVideoEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse, sizeof(struct _trt__SetVideoEncoderConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__SetVideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetVideoEncoderConfiguration, sizeof(struct _trt__SetVideoEncoderConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__SetVideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetVideoEncoderConfiguration, SOAP_TYPE__trt__SetVideoEncoderConfiguration, sizeof(struct _trt__SetVideoEncoderConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetCompatibleAudioDecoderConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetCompatibleAudioDecoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetCompatibleAudioDecoderConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetCompatibleAudioDecoderConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetCompatibleAudioOutputConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioOutputConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetCompatibleAudioOutputConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioOutputConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetCompatibleAudioOutputConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations, sizeof(struct _trt__GetCompatibleAudioOutputConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetCompatibleAudioOutputConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations, sizeof(struct _trt__GetCompatibleAudioOutputConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetCompatibleMetadataConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse, sizeof(struct _trt__GetCompatibleMetadataConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetCompatibleMetadataConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse, SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse, sizeof(struct _trt__GetCompatibleMetadataConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetCompatibleMetadataConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations, sizeof(struct _trt__GetCompatibleMetadataConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetCompatibleMetadataConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations, sizeof(struct _trt__GetCompatibleMetadataConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetCompatibleVideoAnalyticsConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetCompatibleVideoAnalyticsConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetCompatibleAudioSourceConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioSourceConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetCompatibleAudioSourceConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioSourceConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetCompatibleAudioSourceConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations, sizeof(struct _trt__GetCompatibleAudioSourceConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetCompatibleAudioSourceConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations, sizeof(struct _trt__GetCompatibleAudioSourceConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetCompatibleAudioEncoderConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetCompatibleAudioEncoderConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetCompatibleVideoSourceConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoSourceConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetCompatibleVideoSourceConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoSourceConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetCompatibleVideoSourceConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations, sizeof(struct _trt__GetCompatibleVideoSourceConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetCompatibleVideoSourceConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations, sizeof(struct _trt__GetCompatibleVideoSourceConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetCompatibleVideoEncoderConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetCompatibleVideoEncoderConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioDecoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse, sizeof(struct _trt__GetAudioDecoderConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetAudioDecoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse, SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse, sizeof(struct _trt__GetAudioDecoderConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioDecoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioDecoderConfiguration, sizeof(struct _trt__GetAudioDecoderConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetAudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioDecoderConfiguration, SOAP_TYPE__trt__GetAudioDecoderConfiguration, sizeof(struct _trt__GetAudioDecoderConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioOutputConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputConfigurationResponse, sizeof(struct _trt__GetAudioOutputConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetAudioOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputConfigurationResponse, SOAP_TYPE__trt__GetAudioOutputConfigurationResponse, sizeof(struct _trt__GetAudioOutputConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputConfiguration, sizeof(struct _trt__GetAudioOutputConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetAudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputConfiguration, SOAP_TYPE__trt__GetAudioOutputConfiguration, sizeof(struct _trt__GetAudioOutputConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetMetadataConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetMetadataConfigurationResponse, sizeof(struct _trt__GetMetadataConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetMetadataConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetMetadataConfigurationResponse, SOAP_TYPE__trt__GetMetadataConfigurationResponse, sizeof(struct _trt__GetMetadataConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetMetadataConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetMetadataConfiguration, sizeof(struct _trt__GetMetadataConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetMetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetMetadataConfiguration, SOAP_TYPE__trt__GetMetadataConfiguration, sizeof(struct _trt__GetMetadataConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetVideoAnalyticsConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse, sizeof(struct _trt__GetVideoAnalyticsConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetVideoAnalyticsConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse, sizeof(struct _trt__GetVideoAnalyticsConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetVideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration, sizeof(struct _trt__GetVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetVideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration, sizeof(struct _trt__GetVideoAnalyticsConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse, sizeof(struct _trt__GetAudioEncoderConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetAudioEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse, SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse, sizeof(struct _trt__GetAudioEncoderConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfiguration, sizeof(struct _trt__GetAudioEncoderConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetAudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfiguration, SOAP_TYPE__trt__GetAudioEncoderConfiguration, sizeof(struct _trt__GetAudioEncoderConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourceConfigurationResponse, sizeof(struct _trt__GetAudioSourceConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetAudioSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourceConfigurationResponse, SOAP_TYPE__trt__GetAudioSourceConfigurationResponse, sizeof(struct _trt__GetAudioSourceConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourceConfiguration, sizeof(struct _trt__GetAudioSourceConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetAudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourceConfiguration, SOAP_TYPE__trt__GetAudioSourceConfiguration, sizeof(struct _trt__GetAudioSourceConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetVideoEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse, sizeof(struct _trt__GetVideoEncoderConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetVideoEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse, sizeof(struct _trt__GetVideoEncoderConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetVideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfiguration, sizeof(struct _trt__GetVideoEncoderConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetVideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfiguration, SOAP_TYPE__trt__GetVideoEncoderConfiguration, sizeof(struct _trt__GetVideoEncoderConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetVideoSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceConfigurationResponse, sizeof(struct _trt__GetVideoSourceConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetVideoSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceConfigurationResponse, SOAP_TYPE__trt__GetVideoSourceConfigurationResponse, sizeof(struct _trt__GetVideoSourceConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetVideoSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceConfiguration, sizeof(struct _trt__GetVideoSourceConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetVideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceConfiguration, SOAP_TYPE__trt__GetVideoSourceConfiguration, sizeof(struct _trt__GetVideoSourceConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetAudioDecoderConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse, sizeof(struct _trt__GetAudioDecoderConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetAudioDecoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse, SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse, sizeof(struct _trt__GetAudioDecoderConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioDecoderConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurations, sizeof(struct _trt__GetAudioDecoderConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetAudioDecoderConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioDecoderConfigurations, SOAP_TYPE__trt__GetAudioDecoderConfigurations, sizeof(struct _trt__GetAudioDecoderConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetAudioOutputConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse, sizeof(struct _trt__GetAudioOutputConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetAudioOutputConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse, SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse, sizeof(struct _trt__GetAudioOutputConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioOutputConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputConfigurations, sizeof(struct _trt__GetAudioOutputConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetAudioOutputConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputConfigurations, SOAP_TYPE__trt__GetAudioOutputConfigurations, sizeof(struct _trt__GetAudioOutputConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetMetadataConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetMetadataConfigurationsResponse, sizeof(struct _trt__GetMetadataConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetMetadataConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetMetadataConfigurationsResponse, SOAP_TYPE__trt__GetMetadataConfigurationsResponse, sizeof(struct _trt__GetMetadataConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetMetadataConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetMetadataConfigurations, sizeof(struct _trt__GetMetadataConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetMetadataConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetMetadataConfigurations, SOAP_TYPE__trt__GetMetadataConfigurations, sizeof(struct _trt__GetMetadataConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetVideoAnalyticsConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse, sizeof(struct _trt__GetVideoAnalyticsConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetVideoAnalyticsConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse, sizeof(struct _trt__GetVideoAnalyticsConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetVideoAnalyticsConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations, sizeof(struct _trt__GetVideoAnalyticsConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetVideoAnalyticsConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations, sizeof(struct _trt__GetVideoAnalyticsConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetAudioSourceConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse, sizeof(struct _trt__GetAudioSourceConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetAudioSourceConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse, sizeof(struct _trt__GetAudioSourceConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioSourceConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourceConfigurations, sizeof(struct _trt__GetAudioSourceConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetAudioSourceConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourceConfigurations, SOAP_TYPE__trt__GetAudioSourceConfigurations, sizeof(struct _trt__GetAudioSourceConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetAudioEncoderConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetAudioEncoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioEncoderConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurations, sizeof(struct _trt__GetAudioEncoderConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetAudioEncoderConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfigurations, SOAP_TYPE__trt__GetAudioEncoderConfigurations, sizeof(struct _trt__GetAudioEncoderConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetVideoSourceConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse, sizeof(struct _trt__GetVideoSourceConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetVideoSourceConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse, sizeof(struct _trt__GetVideoSourceConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetVideoSourceConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceConfigurations, sizeof(struct _trt__GetVideoSourceConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetVideoSourceConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceConfigurations, SOAP_TYPE__trt__GetVideoSourceConfigurations, sizeof(struct _trt__GetVideoSourceConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetVideoEncoderConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetVideoEncoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetVideoEncoderConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurations, sizeof(struct _trt__GetVideoEncoderConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetVideoEncoderConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfigurations, SOAP_TYPE__trt__GetVideoEncoderConfigurations, sizeof(struct _trt__GetVideoEncoderConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__DeleteProfileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__DeleteProfileResponse, sizeof(struct _trt__DeleteProfileResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__DeleteProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__DeleteProfileResponse, SOAP_TYPE__trt__DeleteProfileResponse, sizeof(struct _trt__DeleteProfileResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__DeleteProfile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__DeleteProfile, sizeof(struct _trt__DeleteProfile), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__DeleteProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__DeleteProfile, SOAP_TYPE__trt__DeleteProfile, sizeof(struct _trt__DeleteProfile), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemoveAudioDecoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse, sizeof(struct _trt__RemoveAudioDecoderConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__RemoveAudioDecoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse, sizeof(struct _trt__RemoveAudioDecoderConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemoveAudioDecoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration, sizeof(struct _trt__RemoveAudioDecoderConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__RemoveAudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration, sizeof(struct _trt__RemoveAudioDecoderConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddAudioDecoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse, sizeof(struct _trt__AddAudioDecoderConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__AddAudioDecoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse, sizeof(struct _trt__AddAudioDecoderConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddAudioDecoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioDecoderConfiguration, sizeof(struct _trt__AddAudioDecoderConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__AddAudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioDecoderConfiguration, SOAP_TYPE__trt__AddAudioDecoderConfiguration, sizeof(struct _trt__AddAudioDecoderConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemoveAudioOutputConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse, sizeof(struct _trt__RemoveAudioOutputConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__RemoveAudioOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse, sizeof(struct _trt__RemoveAudioOutputConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemoveAudioOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioOutputConfiguration, sizeof(struct _trt__RemoveAudioOutputConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__RemoveAudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioOutputConfiguration, SOAP_TYPE__trt__RemoveAudioOutputConfiguration, sizeof(struct _trt__RemoveAudioOutputConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddAudioOutputConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse, sizeof(struct _trt__AddAudioOutputConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__AddAudioOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse, sizeof(struct _trt__AddAudioOutputConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddAudioOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioOutputConfiguration, sizeof(struct _trt__AddAudioOutputConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__AddAudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioOutputConfiguration, SOAP_TYPE__trt__AddAudioOutputConfiguration, sizeof(struct _trt__AddAudioOutputConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemoveMetadataConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse, sizeof(struct _trt__RemoveMetadataConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__RemoveMetadataConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse, sizeof(struct _trt__RemoveMetadataConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemoveMetadataConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveMetadataConfiguration, sizeof(struct _trt__RemoveMetadataConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__RemoveMetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveMetadataConfiguration, SOAP_TYPE__trt__RemoveMetadataConfiguration, sizeof(struct _trt__RemoveMetadataConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddMetadataConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddMetadataConfigurationResponse, sizeof(struct _trt__AddMetadataConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__AddMetadataConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddMetadataConfigurationResponse, SOAP_TYPE__trt__AddMetadataConfigurationResponse, sizeof(struct _trt__AddMetadataConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddMetadataConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddMetadataConfiguration, sizeof(struct _trt__AddMetadataConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__AddMetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddMetadataConfiguration, SOAP_TYPE__trt__AddMetadataConfiguration, sizeof(struct _trt__AddMetadataConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemoveVideoAnalyticsConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse, sizeof(struct _trt__RemoveVideoAnalyticsConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__RemoveVideoAnalyticsConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse, sizeof(struct _trt__RemoveVideoAnalyticsConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemoveVideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration, sizeof(struct _trt__RemoveVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__RemoveVideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration, sizeof(struct _trt__RemoveVideoAnalyticsConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddVideoAnalyticsConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse, sizeof(struct _trt__AddVideoAnalyticsConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__AddVideoAnalyticsConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse, sizeof(struct _trt__AddVideoAnalyticsConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddVideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration, sizeof(struct _trt__AddVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__AddVideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration, sizeof(struct _trt__AddVideoAnalyticsConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemovePTZConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemovePTZConfigurationResponse, sizeof(struct _trt__RemovePTZConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__RemovePTZConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemovePTZConfigurationResponse, SOAP_TYPE__trt__RemovePTZConfigurationResponse, sizeof(struct _trt__RemovePTZConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemovePTZConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemovePTZConfiguration, sizeof(struct _trt__RemovePTZConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__RemovePTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemovePTZConfiguration, SOAP_TYPE__trt__RemovePTZConfiguration, sizeof(struct _trt__RemovePTZConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddPTZConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddPTZConfigurationResponse, sizeof(struct _trt__AddPTZConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__AddPTZConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddPTZConfigurationResponse, SOAP_TYPE__trt__AddPTZConfigurationResponse, sizeof(struct _trt__AddPTZConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddPTZConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddPTZConfiguration, sizeof(struct _trt__AddPTZConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__AddPTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddPTZConfiguration, SOAP_TYPE__trt__AddPTZConfiguration, sizeof(struct _trt__AddPTZConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemoveAudioSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse, sizeof(struct _trt__RemoveAudioSourceConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__RemoveAudioSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse, sizeof(struct _trt__RemoveAudioSourceConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemoveAudioSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioSourceConfiguration, sizeof(struct _trt__RemoveAudioSourceConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__RemoveAudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioSourceConfiguration, SOAP_TYPE__trt__RemoveAudioSourceConfiguration, sizeof(struct _trt__RemoveAudioSourceConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddAudioSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse, sizeof(struct _trt__AddAudioSourceConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__AddAudioSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse, sizeof(struct _trt__AddAudioSourceConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddAudioSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioSourceConfiguration, sizeof(struct _trt__AddAudioSourceConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__AddAudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioSourceConfiguration, SOAP_TYPE__trt__AddAudioSourceConfiguration, sizeof(struct _trt__AddAudioSourceConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemoveAudioEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse, sizeof(struct _trt__RemoveAudioEncoderConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__RemoveAudioEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse, sizeof(struct _trt__RemoveAudioEncoderConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemoveAudioEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration, sizeof(struct _trt__RemoveAudioEncoderConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__RemoveAudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration, sizeof(struct _trt__RemoveAudioEncoderConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddAudioEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse, sizeof(struct _trt__AddAudioEncoderConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__AddAudioEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse, sizeof(struct _trt__AddAudioEncoderConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddAudioEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioEncoderConfiguration, sizeof(struct _trt__AddAudioEncoderConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__AddAudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioEncoderConfiguration, SOAP_TYPE__trt__AddAudioEncoderConfiguration, sizeof(struct _trt__AddAudioEncoderConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemoveVideoSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse, sizeof(struct _trt__RemoveVideoSourceConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__RemoveVideoSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse, sizeof(struct _trt__RemoveVideoSourceConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemoveVideoSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoSourceConfiguration, sizeof(struct _trt__RemoveVideoSourceConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__RemoveVideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoSourceConfiguration, SOAP_TYPE__trt__RemoveVideoSourceConfiguration, sizeof(struct _trt__RemoveVideoSourceConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddVideoSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse, sizeof(struct _trt__AddVideoSourceConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__AddVideoSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse, sizeof(struct _trt__AddVideoSourceConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddVideoSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoSourceConfiguration, sizeof(struct _trt__AddVideoSourceConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__AddVideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoSourceConfiguration, SOAP_TYPE__trt__AddVideoSourceConfiguration, sizeof(struct _trt__AddVideoSourceConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemoveVideoEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse, sizeof(struct _trt__RemoveVideoEncoderConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__RemoveVideoEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse, sizeof(struct _trt__RemoveVideoEncoderConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__RemoveVideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration, sizeof(struct _trt__RemoveVideoEncoderConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__RemoveVideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration, sizeof(struct _trt__RemoveVideoEncoderConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddVideoEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse, sizeof(struct _trt__AddVideoEncoderConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__AddVideoEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse, sizeof(struct _trt__AddVideoEncoderConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__AddVideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoEncoderConfiguration, sizeof(struct _trt__AddVideoEncoderConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__AddVideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoEncoderConfiguration, SOAP_TYPE__trt__AddVideoEncoderConfiguration, sizeof(struct _trt__AddVideoEncoderConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetProfilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfilesResponse, sizeof(struct _trt__GetProfilesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Profiles", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetProfilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfilesResponse, SOAP_TYPE__trt__GetProfilesResponse, sizeof(struct _trt__GetProfilesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetProfiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfiles, sizeof(struct _trt__GetProfiles), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetProfiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfiles, SOAP_TYPE__trt__GetProfiles, sizeof(struct _trt__GetProfiles), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetProfileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfileResponse, sizeof(struct _trt__GetProfileResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Profile && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Profile))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfileResponse, SOAP_TYPE__trt__GetProfileResponse, sizeof(struct _trt__GetProfileResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetProfile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfile, sizeof(struct _trt__GetProfile), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfile, SOAP_TYPE__trt__GetProfile, sizeof(struct _trt__GetProfile), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__CreateProfileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__CreateProfileResponse, sizeof(struct _trt__CreateProfileResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Profile && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Profile))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__CreateProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__CreateProfileResponse, SOAP_TYPE__trt__CreateProfileResponse, sizeof(struct _trt__CreateProfileResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__CreateProfile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__CreateProfile, sizeof(struct _trt__CreateProfile), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__CreateProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__CreateProfile, SOAP_TYPE__trt__CreateProfile, sizeof(struct _trt__CreateProfile), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AudioOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutput, sizeof(struct tt__AudioOutput), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__AudioOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutput, SOAP_TYPE_tt__AudioOutput, sizeof(struct tt__AudioOutput), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetAudioOutputsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputsResponse, sizeof(struct _trt__GetAudioOutputsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:AudioOutputs", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetAudioOutputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputsResponse, SOAP_TYPE__trt__GetAudioOutputsResponse, sizeof(struct _trt__GetAudioOutputsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioOutputs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputs, sizeof(struct _trt__GetAudioOutputs), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetAudioOutputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputs, SOAP_TYPE__trt__GetAudioOutputs, sizeof(struct _trt__GetAudioOutputs), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AudioSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSource, sizeof(struct tt__AudioSource), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Channels && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Channels > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AudioSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSource, SOAP_TYPE_tt__AudioSource, sizeof(struct tt__AudioSource), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetAudioSourcesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourcesResponse, sizeof(struct _trt__GetAudioSourcesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:AudioSources", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetAudioSourcesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourcesResponse, SOAP_TYPE__trt__GetAudioSourcesResponse, sizeof(struct _trt__GetAudioSourcesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetAudioSources *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSources, sizeof(struct _trt__GetAudioSources), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetAudioSources *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSources, SOAP_TYPE__trt__GetAudioSources, sizeof(struct _trt__GetAudioSources), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__VideoSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSource, sizeof(struct tt__VideoSource), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Framerate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Imaging && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Framerate > 0 || !a->Resolution))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__VideoSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSource, SOAP_TYPE_tt__VideoSource, sizeof(struct tt__VideoSource), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _trt__GetVideoSourcesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourcesResponse, sizeof(struct _trt__GetVideoSourcesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:VideoSources", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetVideoSourcesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourcesResponse, SOAP_TYPE__trt__GetVideoSourcesResponse, sizeof(struct _trt__GetVideoSourcesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetVideoSources *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSources, sizeof(struct _trt__GetVideoSources), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetVideoSources *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSources, SOAP_TYPE__trt__GetVideoSources, sizeof(struct _trt__GetVideoSources), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetServiceCapabilitiesResponse, sizeof(struct _trt__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _trt__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetServiceCapabilitiesResponse, SOAP_TYPE__trt__GetServiceCapabilitiesResponse, sizeof(struct _trt__GetServiceCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _trt__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetServiceCapabilities, sizeof(struct _trt__GetServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _trt__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetServiceCapabilities, SOAP_TYPE__trt__GetServiceCapabilities, sizeof(struct _trt__GetServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct trt__VideoSourceModeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trt__VideoSourceModeExtension, sizeof(struct trt__VideoSourceModeExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct trt__VideoSourceModeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trt__VideoSourceModeExtension, SOAP_TYPE_trt__VideoSourceModeExtension, sizeof(struct trt__VideoSourceModeExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct trt__VideoSourceMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trt__VideoSourceMode, sizeof(struct trt__VideoSourceMode), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_MaxFramerate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxResolution && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Encodings && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Reboot && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaxFramerate > 0 || !a->MaxResolution || !a->Encodings || soap_flag_Reboot > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct trt__VideoSourceMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trt__VideoSourceMode, SOAP_TYPE_trt__VideoSourceMode, sizeof(struct trt__VideoSourceMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct trt__StreamingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trt__StreamingCapabilities, sizeof(struct trt__StreamingCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct trt__StreamingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trt__StreamingCapabilities, SOAP_TYPE_trt__StreamingCapabilities, sizeof(struct trt__StreamingCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct trt__ProfileCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trt__ProfileCapabilities, sizeof(struct trt__ProfileCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct trt__ProfileCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trt__ProfileCapabilities, SOAP_TYPE_trt__ProfileCapabilities, sizeof(struct trt__ProfileCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct trt__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trt__Capabilities, sizeof(struct trt__Capabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_StreamingCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileCapabilities || !a->StreamingCapabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct trt__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trt__Capabilities, SOAP_TYPE_trt__Capabilities, sizeof(struct trt__Capabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__SetCurrentPresetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetCurrentPresetResponse, sizeof(struct _timg__SetCurrentPresetResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _timg__SetCurrentPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetCurrentPresetResponse, SOAP_TYPE__timg__SetCurrentPresetResponse, sizeof(struct _timg__SetCurrentPresetResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__SetCurrentPreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetCurrentPreset, sizeof(struct _timg__SetCurrentPreset), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken || !a->PresetToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _timg__SetCurrentPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetCurrentPreset, SOAP_TYPE__timg__SetCurrentPreset, sizeof(struct _timg__SetCurrentPreset), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__GetCurrentPresetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetCurrentPresetResponse, sizeof(struct _timg__GetCurrentPresetResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Preset && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _timg__GetCurrentPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetCurrentPresetResponse, SOAP_TYPE__timg__GetCurrentPresetResponse, sizeof(struct _timg__GetCurrentPresetResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__GetCurrentPreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetCurrentPreset, sizeof(struct _timg__GetCurrentPreset), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _timg__GetCurrentPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetCurrentPreset, SOAP_TYPE__timg__GetCurrentPreset, sizeof(struct _timg__GetCurrentPreset), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _timg__GetPresetsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetPresetsResponse, sizeof(struct _timg__GetPresetsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "timg:Preset", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePreset < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _timg__GetPresetsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetPresetsResponse, SOAP_TYPE__timg__GetPresetsResponse, sizeof(struct _timg__GetPresetsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__GetPresets *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetPresets, sizeof(struct _timg__GetPresets), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _timg__GetPresets *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetPresets, SOAP_TYPE__timg__GetPresets, sizeof(struct _timg__GetPresets), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__GetStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetStatusResponse, sizeof(struct _timg__GetStatusResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Status))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _timg__GetStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetStatusResponse, SOAP_TYPE__timg__GetStatusResponse, sizeof(struct _timg__GetStatusResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__GetStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetStatus, sizeof(struct _timg__GetStatus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _timg__GetStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetStatus, SOAP_TYPE__timg__GetStatus, sizeof(struct _timg__GetStatus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__StopResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__StopResponse, sizeof(struct _timg__StopResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _timg__StopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__StopResponse, SOAP_TYPE__timg__StopResponse, sizeof(struct _timg__StopResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__Stop *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__Stop, sizeof(struct _timg__Stop), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _timg__Stop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__Stop, SOAP_TYPE__timg__Stop, sizeof(struct _timg__Stop), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__GetMoveOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetMoveOptionsResponse, sizeof(struct _timg__GetMoveOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_MoveOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->MoveOptions))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _timg__GetMoveOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetMoveOptionsResponse, SOAP_TYPE__timg__GetMoveOptionsResponse, sizeof(struct _timg__GetMoveOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__GetMoveOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetMoveOptions, sizeof(struct _timg__GetMoveOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _timg__GetMoveOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetMoveOptions, SOAP_TYPE__timg__GetMoveOptions, sizeof(struct _timg__GetMoveOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__MoveResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__MoveResponse, sizeof(struct _timg__MoveResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _timg__MoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__MoveResponse, SOAP_TYPE__timg__MoveResponse, sizeof(struct _timg__MoveResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__Move *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__Move, sizeof(struct _timg__Move), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken || !a->Focus))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _timg__Move *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__Move, SOAP_TYPE__timg__Move, sizeof(struct _timg__Move), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__GetOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetOptionsResponse, sizeof(struct _timg__GetOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ImagingOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ImagingOptions))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _timg__GetOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetOptionsResponse, SOAP_TYPE__timg__GetOptionsResponse, sizeof(struct _timg__GetOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__GetOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetOptions, sizeof(struct _timg__GetOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _timg__GetOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetOptions, SOAP_TYPE__timg__GetOptions, sizeof(struct _timg__GetOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__SetImagingSettingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetImagingSettingsResponse, sizeof(struct _timg__SetImagingSettingsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _timg__SetImagingSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetImagingSettingsResponse, SOAP_TYPE__timg__SetImagingSettingsResponse, sizeof(struct _timg__SetImagingSettingsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__SetImagingSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetImagingSettings, sizeof(struct _timg__SetImagingSettings), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ImagingSettings && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken || !a->ImagingSettings))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _timg__SetImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetImagingSettings, SOAP_TYPE__timg__SetImagingSettings, sizeof(struct _timg__SetImagingSettings), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__GetImagingSettingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetImagingSettingsResponse, sizeof(struct _timg__GetImagingSettingsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ImagingSettings && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ImagingSettings))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _timg__GetImagingSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetImagingSettingsResponse, SOAP_TYPE__timg__GetImagingSettingsResponse, sizeof(struct _timg__GetImagingSettingsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__GetImagingSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetImagingSettings, sizeof(struct _timg__GetImagingSettings), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _timg__GetImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetImagingSettings, SOAP_TYPE__timg__GetImagingSettings, sizeof(struct _timg__GetImagingSettings), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, sizeof(struct _timg__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _timg__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, sizeof(struct _timg__GetServiceCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _timg__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetServiceCapabilities, sizeof(struct _timg__GetServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _timg__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetServiceCapabilities, SOAP_TYPE__timg__GetServiceCapabilities, sizeof(struct _timg__GetServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct timg__ImagingPreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_timg__ImagingPreset, sizeof(struct timg__ImagingPreset), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct timg__ImagingPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_timg__ImagingPreset, SOAP_TYPE_timg__ImagingPreset, sizeof(struct timg__ImagingPreset), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct timg__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_timg__Capabilities, sizeof(struct timg__Capabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct timg__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_timg__Capabilities, SOAP_TYPE_timg__Capabilities, sizeof(struct timg__Capabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__SendReceiveSerialCommandResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SendReceiveSerialCommandResponse, sizeof(struct _tmd__SendReceiveSerialCommandResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SerialData && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__SendReceiveSerialCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SendReceiveSerialCommandResponse, SOAP_TYPE__tmd__SendReceiveSerialCommandResponse, sizeof(struct _tmd__SendReceiveSerialCommandResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__SendReceiveSerialCommand *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SendReceiveSerialCommand, sizeof(struct _tmd__SendReceiveSerialCommand), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SerialData && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_TimeOut && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DataLength && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Delimiter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__SendReceiveSerialCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SendReceiveSerialCommand, SOAP_TYPE__tmd__SendReceiveSerialCommand, sizeof(struct _tmd__SendReceiveSerialCommand), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__GetSerialPortConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse, sizeof(struct _tmd__GetSerialPortConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SerialPortOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SerialPortOptions))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetSerialPortConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse, SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse, sizeof(struct _tmd__GetSerialPortConfigurationOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__GetSerialPortConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetSerialPortConfigurationOptions, sizeof(struct _tmd__GetSerialPortConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SerialPortToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SerialPortToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetSerialPortConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetSerialPortConfigurationOptions, SOAP_TYPE__tmd__GetSerialPortConfigurationOptions, sizeof(struct _tmd__GetSerialPortConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__SetSerialPortConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetSerialPortConfigurationResponse, sizeof(struct _tmd__SetSerialPortConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__SetSerialPortConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetSerialPortConfigurationResponse, SOAP_TYPE__tmd__SetSerialPortConfigurationResponse, sizeof(struct _tmd__SetSerialPortConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__SetSerialPortConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetSerialPortConfiguration, sizeof(struct _tmd__SetSerialPortConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SerialPortConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistance && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SerialPortConfiguration || soap_flag_ForcePersistance > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__SetSerialPortConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetSerialPortConfiguration, SOAP_TYPE__tmd__SetSerialPortConfiguration, sizeof(struct _tmd__SetSerialPortConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__GetSerialPortConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetSerialPortConfigurationResponse, sizeof(struct _tmd__GetSerialPortConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SerialPortConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SerialPortConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetSerialPortConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetSerialPortConfigurationResponse, SOAP_TYPE__tmd__GetSerialPortConfigurationResponse, sizeof(struct _tmd__GetSerialPortConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__GetSerialPortConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetSerialPortConfiguration, sizeof(struct _tmd__GetSerialPortConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SerialPortToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SerialPortToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetSerialPortConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetSerialPortConfiguration, SOAP_TYPE__tmd__GetSerialPortConfiguration, sizeof(struct _tmd__GetSerialPortConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tmd__SerialPort *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__SerialPort, sizeof(struct tmd__SerialPort), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tmd__SerialPort *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__SerialPort, SOAP_TYPE_tmd__SerialPort, sizeof(struct tmd__SerialPort), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetSerialPortsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetSerialPortsResponse, sizeof(struct _tmd__GetSerialPortsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:SerialPort", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__GetSerialPortsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetSerialPortsResponse, SOAP_TYPE__tmd__GetSerialPortsResponse, sizeof(struct _tmd__GetSerialPortsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__GetSerialPorts *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetSerialPorts, sizeof(struct _tmd__GetSerialPorts), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__GetSerialPorts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetSerialPorts, SOAP_TYPE__tmd__GetSerialPorts, sizeof(struct _tmd__GetSerialPorts), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__SetDigitalInputConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse, sizeof(struct _tmd__SetDigitalInputConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__SetDigitalInputConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse, SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse, sizeof(struct _tmd__SetDigitalInputConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__SetDigitalInputConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetDigitalInputConfigurations, sizeof(struct _tmd__SetDigitalInputConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:DigitalInputs", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeDigitalInputs < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__SetDigitalInputConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetDigitalInputConfigurations, SOAP_TYPE__tmd__SetDigitalInputConfigurations, sizeof(struct _tmd__SetDigitalInputConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__GetDigitalInputConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse, sizeof(struct _tmd__GetDigitalInputConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_DigitalInputOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->DigitalInputOptions))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetDigitalInputConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse, SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse, sizeof(struct _tmd__GetDigitalInputConfigurationOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__GetDigitalInputConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions, sizeof(struct _tmd__GetDigitalInputConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__GetDigitalInputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions, SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions, sizeof(struct _tmd__GetDigitalInputConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__DigitalInput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DigitalInput, sizeof(struct tt__DigitalInput), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__DigitalInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DigitalInput, SOAP_TYPE_tt__DigitalInput, sizeof(struct tt__DigitalInput), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetDigitalInputsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetDigitalInputsResponse, sizeof(struct _tmd__GetDigitalInputsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:DigitalInputs", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__GetDigitalInputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetDigitalInputsResponse, SOAP_TYPE__tmd__GetDigitalInputsResponse, sizeof(struct _tmd__GetDigitalInputsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__GetDigitalInputs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetDigitalInputs, sizeof(struct _tmd__GetDigitalInputs), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__GetDigitalInputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetDigitalInputs, SOAP_TYPE__tmd__GetDigitalInputs, sizeof(struct _tmd__GetDigitalInputs), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__SetRelayOutputSettingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetRelayOutputSettingsResponse, sizeof(struct _tmd__SetRelayOutputSettingsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__SetRelayOutputSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetRelayOutputSettingsResponse, SOAP_TYPE__tmd__SetRelayOutputSettingsResponse, sizeof(struct _tmd__SetRelayOutputSettingsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__SetRelayOutputSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetRelayOutputSettings, sizeof(struct _tmd__SetRelayOutputSettings), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RelayOutput && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RelayOutput))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__SetRelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetRelayOutputSettings, SOAP_TYPE__tmd__SetRelayOutputSettings, sizeof(struct _tmd__SetRelayOutputSettings), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetAudioOutputConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse, sizeof(struct _tmd__GetAudioOutputConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AudioOutputOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->AudioOutputOptions))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetAudioOutputConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse, sizeof(struct _tmd__GetAudioOutputConfigurationOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetAudioOutputConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions, sizeof(struct _tmd__GetAudioOutputConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AudioOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->AudioOutputToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetAudioOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions, sizeof(struct _tmd__GetAudioOutputConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetAudioSourceConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse, sizeof(struct _tmd__GetAudioSourceConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AudioSourceOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->AudioSourceOptions))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetAudioSourceConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse, sizeof(struct _tmd__GetAudioSourceConfigurationOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetAudioSourceConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions, sizeof(struct _tmd__GetAudioSourceConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AudioSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->AudioSourceToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetAudioSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions, sizeof(struct _tmd__GetAudioSourceConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetVideoOutputConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse, sizeof(struct _tmd__GetVideoOutputConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoOutputConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutputConfigurationOptions))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetVideoOutputConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse, sizeof(struct _tmd__GetVideoOutputConfigurationOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetVideoOutputConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions, sizeof(struct _tmd__GetVideoOutputConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutputToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetVideoOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions, sizeof(struct _tmd__GetVideoOutputConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetVideoSourceConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse, sizeof(struct _tmd__GetVideoSourceConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoSourceConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceConfigurationOptions))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetVideoSourceConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse, sizeof(struct _tmd__GetVideoSourceConfigurationOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetVideoSourceConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions, sizeof(struct _tmd__GetVideoSourceConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetVideoSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions, sizeof(struct _tmd__GetVideoSourceConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__SetVideoOutputConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse, sizeof(struct _tmd__SetVideoOutputConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__SetVideoOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse, SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse, sizeof(struct _tmd__SetVideoOutputConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__SetVideoOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetVideoOutputConfiguration, sizeof(struct _tmd__SetVideoOutputConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__SetVideoOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetVideoOutputConfiguration, SOAP_TYPE__tmd__SetVideoOutputConfiguration, sizeof(struct _tmd__SetVideoOutputConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__SetVideoSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse, sizeof(struct _tmd__SetVideoSourceConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__SetVideoSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse, SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse, sizeof(struct _tmd__SetVideoSourceConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__SetVideoSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetVideoSourceConfiguration, sizeof(struct _tmd__SetVideoSourceConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__SetVideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetVideoSourceConfiguration, SOAP_TYPE__tmd__SetVideoSourceConfiguration, sizeof(struct _tmd__SetVideoSourceConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__SetAudioOutputConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse, sizeof(struct _tmd__SetAudioOutputConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__SetAudioOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse, SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse, sizeof(struct _tmd__SetAudioOutputConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__SetAudioOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetAudioOutputConfiguration, sizeof(struct _tmd__SetAudioOutputConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__SetAudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetAudioOutputConfiguration, SOAP_TYPE__tmd__SetAudioOutputConfiguration, sizeof(struct _tmd__SetAudioOutputConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__SetAudioSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse, sizeof(struct _tmd__SetAudioSourceConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__SetAudioSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse, SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse, sizeof(struct _tmd__SetAudioSourceConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__SetAudioSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetAudioSourceConfiguration, sizeof(struct _tmd__SetAudioSourceConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__SetAudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetAudioSourceConfiguration, SOAP_TYPE__tmd__SetAudioSourceConfiguration, sizeof(struct _tmd__SetAudioSourceConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__VideoOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutputConfiguration, sizeof(struct tt__VideoOutputConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_OutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->OutputToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__VideoOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutputConfiguration, SOAP_TYPE_tt__VideoOutputConfiguration, sizeof(struct tt__VideoOutputConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetVideoOutputConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse, sizeof(struct _tmd__GetVideoOutputConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutputConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetVideoOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse, SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse, sizeof(struct _tmd__GetVideoOutputConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetVideoOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoOutputConfiguration, sizeof(struct _tmd__GetVideoOutputConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutputToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetVideoOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoOutputConfiguration, SOAP_TYPE__tmd__GetVideoOutputConfiguration, sizeof(struct _tmd__GetVideoOutputConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetVideoSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse, sizeof(struct _tmd__GetVideoSourceConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetVideoSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse, SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse, sizeof(struct _tmd__GetVideoSourceConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetVideoSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoSourceConfiguration, sizeof(struct _tmd__GetVideoSourceConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetVideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoSourceConfiguration, SOAP_TYPE__tmd__GetVideoSourceConfiguration, sizeof(struct _tmd__GetVideoSourceConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetAudioOutputConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse, sizeof(struct _tmd__GetAudioOutputConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->AudioOutputConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetAudioOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse, SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse, sizeof(struct _tmd__GetAudioOutputConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetAudioOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetAudioOutputConfiguration, sizeof(struct _tmd__GetAudioOutputConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AudioOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->AudioOutputToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetAudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetAudioOutputConfiguration, SOAP_TYPE__tmd__GetAudioOutputConfiguration, sizeof(struct _tmd__GetAudioOutputConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetAudioSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse, sizeof(struct _tmd__GetAudioSourceConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->AudioSourceConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetAudioSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse, SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse, sizeof(struct _tmd__GetAudioSourceConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetAudioSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetAudioSourceConfiguration, sizeof(struct _tmd__GetAudioSourceConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AudioSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->AudioSourceToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetAudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetAudioSourceConfiguration, SOAP_TYPE__tmd__GetAudioSourceConfiguration, sizeof(struct _tmd__GetAudioSourceConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__VideoOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutput, sizeof(struct tt__VideoOutput), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Layout && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RefreshRate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AspectRatio && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Layout))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__VideoOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutput, SOAP_TYPE_tt__VideoOutput, sizeof(struct tt__VideoOutput), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetVideoOutputsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoOutputsResponse, sizeof(struct _tmd__GetVideoOutputsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:VideoOutputs", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__GetVideoOutputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoOutputsResponse, SOAP_TYPE__tmd__GetVideoOutputsResponse, sizeof(struct _tmd__GetVideoOutputsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__GetVideoOutputs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoOutputs, sizeof(struct _tmd__GetVideoOutputs), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__GetVideoOutputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoOutputs, SOAP_TYPE__tmd__GetVideoOutputs, sizeof(struct _tmd__GetVideoOutputs), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tmd__GetRelayOutputOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetRelayOutputOptionsResponse, sizeof(struct _tmd__GetRelayOutputOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:RelayOutputOptions", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__GetRelayOutputOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetRelayOutputOptionsResponse, SOAP_TYPE__tmd__GetRelayOutputOptionsResponse, sizeof(struct _tmd__GetRelayOutputOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__GetRelayOutputOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetRelayOutputOptions, sizeof(struct _tmd__GetRelayOutputOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RelayOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__GetRelayOutputOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetRelayOutputOptions, SOAP_TYPE__tmd__GetRelayOutputOptions, sizeof(struct _tmd__GetRelayOutputOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetServiceCapabilitiesResponse, sizeof(struct _tmd__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tmd__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetServiceCapabilitiesResponse, SOAP_TYPE__tmd__GetServiceCapabilitiesResponse, sizeof(struct _tmd__GetServiceCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tmd__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetServiceCapabilities, sizeof(struct _tmd__GetServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tmd__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetServiceCapabilities, SOAP_TYPE__tmd__GetServiceCapabilities, sizeof(struct _tmd__GetServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tmd__ParityBitList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__ParityBitList, sizeof(struct tmd__ParityBitList), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:Items", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tmd__ParityBitList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__ParityBitList, SOAP_TYPE_tmd__ParityBitList, sizeof(struct tmd__ParityBitList), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tmd__SerialPortConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__SerialPortConfigurationOptions, sizeof(struct tmd__SerialPortConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_BaudRateList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ParityBitList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CharacterLengthList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_StopBitList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->BaudRateList || !a->ParityBitList || !a->CharacterLengthList || !a->StopBitList))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tmd__SerialPortConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__SerialPortConfigurationOptions, SOAP_TYPE_tmd__SerialPortConfigurationOptions, sizeof(struct tmd__SerialPortConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tmd__SerialPortConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__SerialPortConfiguration, sizeof(struct tmd__SerialPortConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_BaudRate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ParityBit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CharacterLength && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_StopBit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BaudRate > 0 || soap_flag_ParityBit > 0 || soap_flag_CharacterLength > 0 || soap_flag_StopBit > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tmd__SerialPortConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__SerialPortConfiguration, SOAP_TYPE_tmd__SerialPortConfiguration, sizeof(struct tmd__SerialPortConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tmd__SerialData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__SerialData, sizeof(struct tmd__SerialData), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_union_SerialData && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_SerialData))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tmd__SerialData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__SerialData, SOAP_TYPE_tmd__SerialData, sizeof(struct tmd__SerialData), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tmd__DigitalInputConfigurationInputOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__DigitalInputConfigurationInputOptions, sizeof(struct tmd__DigitalInputConfigurationInputOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:IdleState", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeIdleState < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tmd__DigitalInputConfigurationInputOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__DigitalInputConfigurationInputOptions, SOAP_TYPE_tmd__DigitalInputConfigurationInputOptions, sizeof(struct tmd__DigitalInputConfigurationInputOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tmd__GetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__GetResponse, sizeof(struct tmd__GetResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:Token", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tmd__GetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__GetResponse, SOAP_TYPE_tmd__GetResponse, sizeof(struct tmd__GetResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tmd__Get *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__Get, sizeof(struct tmd__Get), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tmd__Get *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__Get, SOAP_TYPE_tmd__Get, sizeof(struct tmd__Get), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tmd__RelayOutputOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__RelayOutputOptionsExtension, sizeof(struct tmd__RelayOutputOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tmd__RelayOutputOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__RelayOutputOptionsExtension, SOAP_TYPE_tmd__RelayOutputOptionsExtension, sizeof(struct tmd__RelayOutputOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tmd__RelayOutputOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__RelayOutputOptions, sizeof(struct tmd__RelayOutputOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:Mode", 1, NULL))
./soapC.c:			if (soap_flag_DelayTimes && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Discrete && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tmd__RelayOutputOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__RelayOutputOptions, SOAP_TYPE_tmd__RelayOutputOptions, sizeof(struct tmd__RelayOutputOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tmd__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__Capabilities, sizeof(struct tmd__Capabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tmd__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__Capabilities, SOAP_TYPE_tmd__Capabilities, sizeof(struct tmd__Capabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__DeletePaneConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__DeletePaneConfigurationResponse, sizeof(struct _tls__DeletePaneConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tls__DeletePaneConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__DeletePaneConfigurationResponse, SOAP_TYPE__tls__DeletePaneConfigurationResponse, sizeof(struct _tls__DeletePaneConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__DeletePaneConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__DeletePaneConfiguration, sizeof(struct _tls__DeletePaneConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PaneToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutput || !a->PaneToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tls__DeletePaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__DeletePaneConfiguration, SOAP_TYPE__tls__DeletePaneConfiguration, sizeof(struct _tls__DeletePaneConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__CreatePaneConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__CreatePaneConfigurationResponse, sizeof(struct _tls__CreatePaneConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PaneToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PaneToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tls__CreatePaneConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__CreatePaneConfigurationResponse, SOAP_TYPE__tls__CreatePaneConfigurationResponse, sizeof(struct _tls__CreatePaneConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__CreatePaneConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__CreatePaneConfiguration, sizeof(struct _tls__CreatePaneConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PaneConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutput || !a->PaneConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tls__CreatePaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__CreatePaneConfiguration, SOAP_TYPE__tls__CreatePaneConfiguration, sizeof(struct _tls__CreatePaneConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__SetPaneConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetPaneConfigurationResponse, sizeof(struct _tls__SetPaneConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tls__SetPaneConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetPaneConfigurationResponse, SOAP_TYPE__tls__SetPaneConfigurationResponse, sizeof(struct _tls__SetPaneConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__SetPaneConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetPaneConfiguration, sizeof(struct _tls__SetPaneConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PaneConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutput || !a->PaneConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tls__SetPaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetPaneConfiguration, SOAP_TYPE__tls__SetPaneConfiguration, sizeof(struct _tls__SetPaneConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__SetPaneConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetPaneConfigurationsResponse, sizeof(struct _tls__SetPaneConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tls__SetPaneConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetPaneConfigurationsResponse, SOAP_TYPE__tls__SetPaneConfigurationsResponse, sizeof(struct _tls__SetPaneConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__SetPaneConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetPaneConfigurations, sizeof(struct _tls__SetPaneConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tls:PaneConfiguration", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutput || a->__sizePaneConfiguration < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tls__SetPaneConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetPaneConfigurations, SOAP_TYPE__tls__SetPaneConfigurations, sizeof(struct _tls__SetPaneConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__GetPaneConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetPaneConfigurationResponse, sizeof(struct _tls__GetPaneConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PaneConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PaneConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tls__GetPaneConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetPaneConfigurationResponse, SOAP_TYPE__tls__GetPaneConfigurationResponse, sizeof(struct _tls__GetPaneConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__GetPaneConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetPaneConfiguration, sizeof(struct _tls__GetPaneConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Pane && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutput || !a->Pane))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tls__GetPaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetPaneConfiguration, SOAP_TYPE__tls__GetPaneConfiguration, sizeof(struct _tls__GetPaneConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__GetPaneConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetPaneConfigurationsResponse, sizeof(struct _tls__GetPaneConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tls:PaneConfiguration", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePaneConfiguration < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tls__GetPaneConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetPaneConfigurationsResponse, SOAP_TYPE__tls__GetPaneConfigurationsResponse, sizeof(struct _tls__GetPaneConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__GetPaneConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetPaneConfigurations, sizeof(struct _tls__GetPaneConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutput))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tls__GetPaneConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetPaneConfigurations, SOAP_TYPE__tls__GetPaneConfigurations, sizeof(struct _tls__GetPaneConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__GetDisplayOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetDisplayOptionsResponse, sizeof(struct _tls__GetDisplayOptionsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_LayoutOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CodingCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CodingCapabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tls__GetDisplayOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetDisplayOptionsResponse, SOAP_TYPE__tls__GetDisplayOptionsResponse, sizeof(struct _tls__GetDisplayOptionsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__GetDisplayOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetDisplayOptions, sizeof(struct _tls__GetDisplayOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutput))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tls__GetDisplayOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetDisplayOptions, SOAP_TYPE__tls__GetDisplayOptions, sizeof(struct _tls__GetDisplayOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__SetLayoutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetLayoutResponse, sizeof(struct _tls__SetLayoutResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tls__SetLayoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetLayoutResponse, SOAP_TYPE__tls__SetLayoutResponse, sizeof(struct _tls__SetLayoutResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__SetLayout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetLayout, sizeof(struct _tls__SetLayout), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Layout && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutput || !a->Layout))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tls__SetLayout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetLayout, SOAP_TYPE__tls__SetLayout, sizeof(struct _tls__SetLayout), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__GetLayoutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetLayoutResponse, sizeof(struct _tls__GetLayoutResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Layout && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Layout))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tls__GetLayoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetLayoutResponse, SOAP_TYPE__tls__GetLayoutResponse, sizeof(struct _tls__GetLayoutResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tls__GetLayout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetLayout, sizeof(struct _tls__GetLayout), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutput))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tls__GetLayout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetLayout, SOAP_TYPE__tls__GetLayout, sizeof(struct _tls__GetLayout), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tls__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetServiceCapabilitiesResponse, sizeof(struct _tls__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tls__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetServiceCapabilitiesResponse, SOAP_TYPE__tls__GetServiceCapabilitiesResponse, sizeof(struct _tls__GetServiceCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tls__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetServiceCapabilities, sizeof(struct _tls__GetServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tls__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetServiceCapabilities, SOAP_TYPE__tls__GetServiceCapabilities, sizeof(struct _tls__GetServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tls__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tls__Capabilities, sizeof(struct tls__Capabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tls__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tls__Capabilities, SOAP_TYPE_tls__Capabilities, sizeof(struct tls__Capabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tev__GetEventPropertiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetEventPropertiesResponse, sizeof(struct _tev__GetEventPropertiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:TopicNamespaceLocation", 1, NULL))
./soapC.c:			if (soap_flag_wsnt__FixedTopicSet && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wstop__TopicSet && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:TopicExpressionDialect", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:MessageContentFilterDialect", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:ProducerPropertiesFilterDialect", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:MessageContentSchemaLocation", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeTopicNamespaceLocation < 1 || !a->wstop__TopicSet || a->__sizeTopicExpressionDialect < 1 || a->__sizeMessageContentFilterDialect < 1 || a->__sizeMessageContentSchemaLocation < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tev__GetEventPropertiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetEventPropertiesResponse, SOAP_TYPE__tev__GetEventPropertiesResponse, sizeof(struct _tev__GetEventPropertiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tev__GetEventProperties *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetEventProperties, sizeof(struct _tev__GetEventProperties), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tev__GetEventProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetEventProperties, SOAP_TYPE__tev__GetEventProperties, sizeof(struct _tev__GetEventProperties), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tev__SetSynchronizationPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__SetSynchronizationPointResponse, sizeof(struct _tev__SetSynchronizationPointResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tev__SetSynchronizationPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__SetSynchronizationPointResponse, SOAP_TYPE__tev__SetSynchronizationPointResponse, sizeof(struct _tev__SetSynchronizationPointResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tev__SetSynchronizationPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__SetSynchronizationPoint, sizeof(struct _tev__SetSynchronizationPoint), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tev__SetSynchronizationPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__SetSynchronizationPoint, SOAP_TYPE__tev__SetSynchronizationPoint, sizeof(struct _tev__SetSynchronizationPoint), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tev__SeekResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__SeekResponse, sizeof(struct _tev__SeekResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tev__SeekResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__SeekResponse, SOAP_TYPE__tev__SeekResponse, sizeof(struct _tev__SeekResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tev__Seek *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__Seek, sizeof(struct _tev__Seek), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_UtcTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Reverse && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UtcTime > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tev__Seek *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__Seek, SOAP_TYPE__tev__Seek, sizeof(struct _tev__Seek), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tev__PullMessagesFaultResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(struct _tev__PullMessagesFaultResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_MaxTimeout && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxMessageLimit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaxTimeout > 0 || soap_flag_MaxMessageLimit > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tev__PullMessagesFaultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessagesFaultResponse, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(struct _tev__PullMessagesFaultResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tev__PullMessagesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessagesResponse, sizeof(struct _tev__PullMessagesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:NotificationMessage", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CurrentTime > 0 || soap_flag_TerminationTime > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tev__PullMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessagesResponse, SOAP_TYPE__tev__PullMessagesResponse, sizeof(struct _tev__PullMessagesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tev__PullMessages *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessages, sizeof(struct _tev__PullMessages), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Timeout && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MessageLimit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timeout > 0 || soap_flag_MessageLimit > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tev__PullMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessages, SOAP_TYPE__tev__PullMessages, sizeof(struct _tev__PullMessages), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tev__CreatePullPointSubscriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, sizeof(struct _tev__CreatePullPointSubscriptionResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__CurrentTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__TerminationTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0 || soap_flag_wsnt__CurrentTime > 0 || soap_flag_wsnt__TerminationTime > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tev__CreatePullPointSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, sizeof(struct _tev__CreatePullPointSubscriptionResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tev__CreatePullPointSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscription, sizeof(struct _tev__CreatePullPointSubscription), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_InitialTerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tev__CreatePullPointSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscription, SOAP_TYPE__tev__CreatePullPointSubscription, sizeof(struct _tev__CreatePullPointSubscription), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tev__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, sizeof(struct _tev__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tev__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, sizeof(struct _tev__GetServiceCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tev__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetServiceCapabilities, sizeof(struct _tev__GetServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tev__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetServiceCapabilities, SOAP_TYPE__tev__GetServiceCapabilities, sizeof(struct _tev__GetServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tev__SubscriptionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tev__SubscriptionPolicy, sizeof(struct tev__SubscriptionPolicy), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tev__SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tev__SubscriptionPolicy, SOAP_TYPE_tev__SubscriptionPolicy, sizeof(struct tev__SubscriptionPolicy), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tev__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tev__Capabilities, sizeof(struct tev__Capabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tev__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tev__Capabilities, SOAP_TYPE_tev__Capabilities, sizeof(struct tev__Capabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wstop__QueryExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(struct wstop__QueryExpressionType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wstop__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__QueryExpressionType, SOAP_TYPE_wstop__QueryExpressionType, sizeof(struct wstop__QueryExpressionType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wstop__ExtensibleDocumented *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__ExtensibleDocumented, sizeof(struct wstop__ExtensibleDocumented), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wstop__ExtensibleDocumented *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__ExtensibleDocumented, SOAP_TYPE_wstop__ExtensibleDocumented, sizeof(struct wstop__ExtensibleDocumented), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct wstop__Documentation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__Documentation, sizeof(struct wstop__Documentation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wstop__Documentation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__Documentation, SOAP_TYPE_wstop__Documentation, sizeof(struct wstop__Documentation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsrfbf__BaseFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(struct _wsrfbf__BaseFaultType_FaultCause), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsrfbf__BaseFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(struct _wsrfbf__BaseFaultType_FaultCause), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsrfbf__BaseFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_Description, sizeof(struct _wsrfbf__BaseFaultType_Description), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsrfbf__BaseFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsrfbf__BaseFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsrfbf__BaseFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfbf__BaseFaultType, sizeof(struct wsrfbf__BaseFaultType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Originator && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ErrorCode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
./soapC.c:			if (soap_flag_FaultCause && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsrfbf__BaseFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfbf__BaseFaultType, SOAP_TYPE_wsrfbf__BaseFaultType, sizeof(struct wsrfbf__BaseFaultType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__ResumeSubscriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(struct _wsnt__ResumeSubscriptionResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__ResumeSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(struct _wsnt__ResumeSubscriptionResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__ResumeSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(struct _wsnt__ResumeSubscription), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__ResumeSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeSubscription, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(struct _wsnt__ResumeSubscription), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__PauseSubscriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(struct _wsnt__PauseSubscriptionResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__PauseSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseSubscriptionResponse, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(struct _wsnt__PauseSubscriptionResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__PauseSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseSubscription, sizeof(struct _wsnt__PauseSubscription), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__PauseSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseSubscription, SOAP_TYPE__wsnt__PauseSubscription, sizeof(struct _wsnt__PauseSubscription), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__UnsubscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(struct _wsnt__UnsubscribeResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UnsubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsubscribeResponse, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(struct _wsnt__UnsubscribeResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__Unsubscribe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Unsubscribe, sizeof(struct _wsnt__Unsubscribe), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__Unsubscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Unsubscribe, SOAP_TYPE__wsnt__Unsubscribe, sizeof(struct _wsnt__Unsubscribe), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__RenewResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__RenewResponse, sizeof(struct _wsnt__RenewResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _wsnt__RenewResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__RenewResponse, SOAP_TYPE__wsnt__RenewResponse, sizeof(struct _wsnt__RenewResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__Renew *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Renew, sizeof(struct _wsnt__Renew), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_TerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _wsnt__Renew *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Renew, SOAP_TYPE__wsnt__Renew, sizeof(struct _wsnt__Renew), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__CreatePullPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(struct _wsnt__CreatePullPointResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PullPoint && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PullPoint > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _wsnt__CreatePullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__CreatePullPointResponse, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(struct _wsnt__CreatePullPointResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__CreatePullPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(struct _wsnt__CreatePullPoint), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__CreatePullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__CreatePullPoint, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(struct _wsnt__CreatePullPoint), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__DestroyPullPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(struct _wsnt__DestroyPullPointResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__DestroyPullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__DestroyPullPointResponse, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(struct _wsnt__DestroyPullPointResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__DestroyPullPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(struct _wsnt__DestroyPullPoint), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__DestroyPullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__DestroyPullPoint, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(struct _wsnt__DestroyPullPoint), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__GetMessagesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(struct _wsnt__GetMessagesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:NotificationMessage", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__GetMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetMessagesResponse, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(struct _wsnt__GetMessagesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__GetMessages *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetMessages, sizeof(struct _wsnt__GetMessages), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_MaximumNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__GetMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetMessages, SOAP_TYPE__wsnt__GetMessages, sizeof(struct _wsnt__GetMessages), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__GetCurrentMessageResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(struct _wsnt__GetCurrentMessageResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__GetCurrentMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetCurrentMessageResponse, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(struct _wsnt__GetCurrentMessageResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__GetCurrentMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(struct _wsnt__GetCurrentMessage), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Topic && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Topic))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _wsnt__GetCurrentMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetCurrentMessage, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(struct _wsnt__GetCurrentMessage), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__SubscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(struct _wsnt__SubscribeResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _wsnt__SubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeResponse, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(struct _wsnt__SubscribeResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__Subscribe_SubscriptionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__Subscribe_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__Subscribe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Subscribe, sizeof(struct _wsnt__Subscribe), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConsumerReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_InitialTerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _wsnt__Subscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Subscribe, SOAP_TYPE__wsnt__Subscribe, sizeof(struct _wsnt__Subscribe), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__UseRaw *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UseRaw, sizeof(struct _wsnt__UseRaw), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__UseRaw *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UseRaw, SOAP_TYPE__wsnt__UseRaw, sizeof(struct _wsnt__UseRaw), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _wsnt__Notify *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Notify, sizeof(struct _wsnt__Notify), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:NotificationMessage", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNotificationMessage < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _wsnt__Notify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Notify, SOAP_TYPE__wsnt__Notify, sizeof(struct _wsnt__Notify), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__SubscriptionManagerRP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscriptionManagerRP, sizeof(struct _wsnt__SubscriptionManagerRP), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ConsumerReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CreationTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _wsnt__SubscriptionManagerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscriptionManagerRP, SOAP_TYPE__wsnt__SubscriptionManagerRP, sizeof(struct _wsnt__SubscriptionManagerRP), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct wstop__TopicSetType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicSetType, sizeof(struct wstop__TopicSetType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wstop__TopicSetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicSetType, SOAP_TYPE_wstop__TopicSetType, sizeof(struct wstop__TopicSetType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__NotificationProducerRP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotificationProducerRP, sizeof(struct _wsnt__NotificationProducerRP), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:TopicExpression", 1, NULL))
./soapC.c:			if (soap_flag_FixedTopicSet && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:TopicExpressionDialect", 1, NULL))
./soapC.c:			if (soap_flag_wstop__TopicSet && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__NotificationProducerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotificationProducerRP, SOAP_TYPE__wsnt__NotificationProducerRP, sizeof(struct _wsnt__NotificationProducerRP), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsnt__NotificationMessageHolderType_Message *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, sizeof(struct _wsnt__NotificationMessageHolderType_Message), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsnt__NotificationMessageHolderType_Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, sizeof(struct _wsnt__NotificationMessageHolderType_Message), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct wsnt__SubscriptionPolicyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(struct wsnt__SubscriptionPolicyType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsnt__SubscriptionPolicyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscriptionPolicyType, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(struct wsnt__SubscriptionPolicyType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__TopicExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(struct wsnt__TopicExpressionType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsnt__TopicExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionType, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(struct wsnt__TopicExpressionType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__QueryExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(struct wsnt__QueryExpressionType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsnt__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__QueryExpressionType, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(struct wsnt__QueryExpressionType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tt__Message *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__Message, sizeof(struct _tt__Message), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tt__Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__Message, SOAP_TYPE__tt__Message, sizeof(struct _tt__Message), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__TransformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TransformationExtension, sizeof(struct tt__TransformationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__TransformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TransformationExtension, SOAP_TYPE_tt__TransformationExtension, sizeof(struct tt__TransformationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ColorCovariance *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorCovariance, sizeof(struct tt__ColorCovariance), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ColorCovariance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorCovariance, SOAP_TYPE_tt__ColorCovariance, sizeof(struct tt__ColorCovariance), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZMoveStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZMoveStatus, sizeof(struct tt__PTZMoveStatus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZMoveStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZMoveStatus, SOAP_TYPE_tt__PTZMoveStatus, sizeof(struct tt__PTZMoveStatus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatus, sizeof(struct tt__PTZStatus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MoveStatus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UtcTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UtcTime > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PTZStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStatus, SOAP_TYPE_tt__PTZStatus, sizeof(struct tt__PTZStatus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__StorageReferencePathExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StorageReferencePathExtension, sizeof(struct tt__StorageReferencePathExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__StorageReferencePathExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StorageReferencePathExtension, SOAP_TYPE_tt__StorageReferencePathExtension, sizeof(struct tt__StorageReferencePathExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__StorageReferencePath *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StorageReferencePath, sizeof(struct tt__StorageReferencePath), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_StorageToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_RelativePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->StorageToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__StorageReferencePath *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StorageReferencePath, SOAP_TYPE_tt__StorageReferencePath, sizeof(struct tt__StorageReferencePath), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ArrayOfFileProgressExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ArrayOfFileProgressExtension, sizeof(struct tt__ArrayOfFileProgressExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ArrayOfFileProgressExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ArrayOfFileProgressExtension, SOAP_TYPE_tt__ArrayOfFileProgressExtension, sizeof(struct tt__ArrayOfFileProgressExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ArrayOfFileProgress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ArrayOfFileProgress, sizeof(struct tt__ArrayOfFileProgress), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:FileProgress", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ArrayOfFileProgress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ArrayOfFileProgress, SOAP_TYPE_tt__ArrayOfFileProgress, sizeof(struct tt__ArrayOfFileProgress), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__FileProgress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FileProgress, sizeof(struct tt__FileProgress), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_FileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Progress && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->FileName || soap_flag_Progress > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__FileProgress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FileProgress, SOAP_TYPE_tt__FileProgress, sizeof(struct tt__FileProgress), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__OSDConfigurationOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, sizeof(struct tt__OSDConfigurationOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__OSDConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, sizeof(struct tt__OSDConfigurationOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__OSDConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfigurationOptions, sizeof(struct tt__OSDConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_MaximumNumberOfOSDs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Type", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PositionOption", 1, NULL))
./soapC.c:			if (soap_flag_TextOption && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ImageOption && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->MaximumNumberOfOSDs || a->__sizeType < 1 || a->__sizePositionOption < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__OSDConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfigurationOptions, SOAP_TYPE_tt__OSDConfigurationOptions, sizeof(struct tt__OSDConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__MaximumNumberOfOSDs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MaximumNumberOfOSDs, sizeof(struct tt__MaximumNumberOfOSDs), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__MaximumNumberOfOSDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MaximumNumberOfOSDs, SOAP_TYPE_tt__MaximumNumberOfOSDs, sizeof(struct tt__MaximumNumberOfOSDs), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__OSDConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfigurationExtension, sizeof(struct tt__OSDConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__OSDConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfigurationExtension, SOAP_TYPE_tt__OSDConfigurationExtension, sizeof(struct tt__OSDConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__OSDImgOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgOptionsExtension, sizeof(struct tt__OSDImgOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__OSDImgOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgOptionsExtension, SOAP_TYPE_tt__OSDImgOptionsExtension, sizeof(struct tt__OSDImgOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__OSDImgOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgOptions, sizeof(struct tt__OSDImgOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ImagePath", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeImagePath < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__OSDImgOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgOptions, SOAP_TYPE_tt__OSDImgOptions, sizeof(struct tt__OSDImgOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__OSDTextOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextOptionsExtension, sizeof(struct tt__OSDTextOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__OSDTextOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextOptionsExtension, SOAP_TYPE_tt__OSDTextOptionsExtension, sizeof(struct tt__OSDTextOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__OSDTextOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextOptions, sizeof(struct tt__OSDTextOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Type", 1, NULL))
./soapC.c:			if (soap_flag_FontSizeRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:DateFormat", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:TimeFormat", 1, NULL))
./soapC.c:			if (soap_flag_FontColor && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_BackgroundColor && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeType < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__OSDTextOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextOptions, SOAP_TYPE_tt__OSDTextOptions, sizeof(struct tt__OSDTextOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__OSDColorOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColorOptionsExtension, sizeof(struct tt__OSDColorOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__OSDColorOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDColorOptionsExtension, SOAP_TYPE_tt__OSDColorOptionsExtension, sizeof(struct tt__OSDColorOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__OSDColorOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColorOptions, sizeof(struct tt__OSDColorOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Transparent && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__OSDColorOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDColorOptions, SOAP_TYPE_tt__OSDColorOptions, sizeof(struct tt__OSDColorOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ColorOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorOptions, sizeof(struct tt__ColorOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ColorList", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ColorspaceRange", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ColorOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorOptions, SOAP_TYPE_tt__ColorOptions, sizeof(struct tt__ColorOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ColorspaceRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorspaceRange, sizeof(struct tt__ColorspaceRange), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_X && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Y && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Z && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Colorspace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->X || !a->Y || !a->Z || !a->Colorspace))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ColorspaceRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorspaceRange, SOAP_TYPE_tt__ColorspaceRange, sizeof(struct tt__ColorspaceRange), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__OSDImgConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgConfigurationExtension, sizeof(struct tt__OSDImgConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__OSDImgConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgConfigurationExtension, SOAP_TYPE_tt__OSDImgConfigurationExtension, sizeof(struct tt__OSDImgConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__OSDImgConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgConfiguration, sizeof(struct tt__OSDImgConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ImgPath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ImgPath))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__OSDImgConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgConfiguration, SOAP_TYPE_tt__OSDImgConfiguration, sizeof(struct tt__OSDImgConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__OSDTextConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextConfigurationExtension, sizeof(struct tt__OSDTextConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__OSDTextConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextConfigurationExtension, SOAP_TYPE_tt__OSDTextConfigurationExtension, sizeof(struct tt__OSDTextConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__OSDTextConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextConfiguration, sizeof(struct tt__OSDTextConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_DateFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_TimeFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_FontSize && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_FontColor && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_BackgroundColor && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_PlainText && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Type))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__OSDTextConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextConfiguration, SOAP_TYPE_tt__OSDTextConfiguration, sizeof(struct tt__OSDTextConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Color *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Color, sizeof(struct tt__Color), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__Color *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Color, SOAP_TYPE_tt__Color, sizeof(struct tt__Color), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__OSDColor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColor, sizeof(struct tt__OSDColor), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Color))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__OSDColor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDColor, SOAP_TYPE_tt__OSDColor, sizeof(struct tt__OSDColor), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__OSDPosConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDPosConfigurationExtension, sizeof(struct tt__OSDPosConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__OSDPosConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDPosConfigurationExtension, SOAP_TYPE_tt__OSDPosConfigurationExtension, sizeof(struct tt__OSDPosConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__OSDPosConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDPosConfiguration, sizeof(struct tt__OSDPosConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Pos && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Type))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__OSDPosConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDPosConfiguration, SOAP_TYPE_tt__OSDPosConfiguration, sizeof(struct tt__OSDPosConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ProfileStatusExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileStatusExtension, sizeof(struct tt__ProfileStatusExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ProfileStatusExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileStatusExtension, SOAP_TYPE_tt__ProfileStatusExtension, sizeof(struct tt__ProfileStatusExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ProfileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileStatus, sizeof(struct tt__ProfileStatus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ActiveConnections", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ProfileStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileStatus, SOAP_TYPE_tt__ProfileStatus, sizeof(struct tt__ProfileStatus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ActiveConnection *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ActiveConnection, sizeof(struct tt__ActiveConnection), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CurrentBitrate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CurrentFps && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CurrentBitrate > 0 || soap_flag_CurrentFps > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ActiveConnection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ActiveConnection, SOAP_TYPE_tt__ActiveConnection, sizeof(struct tt__ActiveConnection), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AudioClassDescriptorExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioClassDescriptorExtension, sizeof(struct tt__AudioClassDescriptorExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__AudioClassDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioClassDescriptorExtension, SOAP_TYPE_tt__AudioClassDescriptorExtension, sizeof(struct tt__AudioClassDescriptorExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__AudioClassDescriptor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioClassDescriptor, sizeof(struct tt__AudioClassDescriptor), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ClassCandidate", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__AudioClassDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioClassDescriptor, SOAP_TYPE_tt__AudioClassDescriptor, sizeof(struct tt__AudioClassDescriptor), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AudioClassCandidate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioClassCandidate, sizeof(struct tt__AudioClassCandidate), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Likelihood && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Type || soap_flag_Likelihood > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AudioClassCandidate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioClassCandidate, SOAP_TYPE_tt__AudioClassCandidate, sizeof(struct tt__AudioClassCandidate), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ActionEngineEventPayloadExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, sizeof(struct tt__ActionEngineEventPayloadExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ActionEngineEventPayloadExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, sizeof(struct tt__ActionEngineEventPayloadExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ActionEngineEventPayload *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ActionEngineEventPayload, sizeof(struct tt__ActionEngineEventPayload), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RequestInfo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ResponseInfo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Fault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ActionEngineEventPayload *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ActionEngineEventPayload, SOAP_TYPE_tt__ActionEngineEventPayload, sizeof(struct tt__ActionEngineEventPayload), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AnalyticsState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsState, sizeof(struct tt__AnalyticsState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_State && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->State))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AnalyticsState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsState, SOAP_TYPE_tt__AnalyticsState, sizeof(struct tt__AnalyticsState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AnalyticsStateInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsStateInformation, sizeof(struct tt__AnalyticsStateInformation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AnalyticsEngineControlToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->AnalyticsEngineControlToken || !a->State))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AnalyticsStateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsStateInformation, SOAP_TYPE_tt__AnalyticsStateInformation, sizeof(struct tt__AnalyticsStateInformation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__MetadataInputExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataInputExtension, sizeof(struct tt__MetadataInputExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__MetadataInputExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataInputExtension, SOAP_TYPE_tt__MetadataInputExtension, sizeof(struct tt__MetadataInputExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__MetadataInput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataInput, sizeof(struct tt__MetadataInput), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:MetadataConfig", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__MetadataInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataInput, SOAP_TYPE_tt__MetadataInput, sizeof(struct tt__MetadataInput), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__SourceIdentificationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SourceIdentificationExtension, sizeof(struct tt__SourceIdentificationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__SourceIdentificationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SourceIdentificationExtension, SOAP_TYPE_tt__SourceIdentificationExtension, sizeof(struct tt__SourceIdentificationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__SourceIdentification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SourceIdentification, sizeof(struct tt__SourceIdentification), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Token", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || a->__sizeToken < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__SourceIdentification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SourceIdentification, SOAP_TYPE_tt__SourceIdentification, sizeof(struct tt__SourceIdentification), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AnalyticsEngineInputInfoExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, sizeof(struct tt__AnalyticsEngineInputInfoExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__AnalyticsEngineInputInfoExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, sizeof(struct tt__AnalyticsEngineInputInfoExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__AnalyticsEngineInputInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfo, sizeof(struct tt__AnalyticsEngineInputInfo), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_InputInfo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__AnalyticsEngineInputInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineInputInfo, SOAP_TYPE_tt__AnalyticsEngineInputInfo, sizeof(struct tt__AnalyticsEngineInputInfo), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AnalyticsDeviceEngineConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, sizeof(struct tt__AnalyticsDeviceEngineConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__AnalyticsDeviceEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, sizeof(struct tt__AnalyticsDeviceEngineConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__EngineConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EngineConfiguration, sizeof(struct tt__EngineConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_VideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AnalyticsEngineInputInfo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoAnalyticsConfiguration || !a->AnalyticsEngineInputInfo))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__EngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EngineConfiguration, SOAP_TYPE_tt__EngineConfiguration, sizeof(struct tt__EngineConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__AnalyticsDeviceEngineConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, sizeof(struct tt__AnalyticsDeviceEngineConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:EngineConfiguration", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeEngineConfiguration < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AnalyticsDeviceEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, sizeof(struct tt__AnalyticsDeviceEngineConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ReplayConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReplayConfiguration, sizeof(struct tt__ReplayConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SessionTimeout && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SessionTimeout > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ReplayConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReplayConfiguration, SOAP_TYPE_tt__ReplayConfiguration, sizeof(struct tt__ReplayConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__GetRecordingJobsResponseItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetRecordingJobsResponseItem, sizeof(struct tt__GetRecordingJobsResponseItem), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobToken || !a->JobConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__GetRecordingJobsResponseItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetRecordingJobsResponseItem, SOAP_TYPE_tt__GetRecordingJobsResponseItem, sizeof(struct tt__GetRecordingJobsResponseItem), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RecordingJobStateTrack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateTrack, sizeof(struct tt__RecordingJobStateTrack), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SourceTag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Destination && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_State && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SourceTag || !a->Destination || !a->State))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__RecordingJobStateTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateTrack, SOAP_TYPE_tt__RecordingJobStateTrack, sizeof(struct tt__RecordingJobStateTrack), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RecordingJobStateTracks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateTracks, sizeof(struct tt__RecordingJobStateTracks), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Track", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__RecordingJobStateTracks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateTracks, SOAP_TYPE_tt__RecordingJobStateTracks, sizeof(struct tt__RecordingJobStateTracks), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RecordingJobStateInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateInformationExtension, sizeof(struct tt__RecordingJobStateInformationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__RecordingJobStateInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateInformationExtension, SOAP_TYPE_tt__RecordingJobStateInformationExtension, sizeof(struct tt__RecordingJobStateInformationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RecordingJobStateSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateSource, sizeof(struct tt__RecordingJobStateSource), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SourceToken && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_State && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Tracks && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SourceToken || !a->State || !a->Tracks))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__RecordingJobStateSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateSource, SOAP_TYPE_tt__RecordingJobStateSource, sizeof(struct tt__RecordingJobStateSource), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__RecordingJobStateInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateInformation, sizeof(struct tt__RecordingJobStateInformation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_State && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Sources", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->State))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__RecordingJobStateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateInformation, SOAP_TYPE_tt__RecordingJobStateInformation, sizeof(struct tt__RecordingJobStateInformation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RecordingJobSourceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobSourceExtension, sizeof(struct tt__RecordingJobSourceExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__RecordingJobSourceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobSourceExtension, SOAP_TYPE_tt__RecordingJobSourceExtension, sizeof(struct tt__RecordingJobSourceExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RecordingJobTrack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobTrack, sizeof(struct tt__RecordingJobTrack), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SourceTag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Destination && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SourceTag || !a->Destination))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__RecordingJobTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobTrack, SOAP_TYPE_tt__RecordingJobTrack, sizeof(struct tt__RecordingJobTrack), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RecordingJobConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobConfigurationExtension, sizeof(struct tt__RecordingJobConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__RecordingJobConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobConfigurationExtension, SOAP_TYPE_tt__RecordingJobConfigurationExtension, sizeof(struct tt__RecordingJobConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__RecordingJobSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobSource, sizeof(struct tt__RecordingJobSource), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SourceToken && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AutoCreateReceiver && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Tracks", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__RecordingJobSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobSource, SOAP_TYPE_tt__RecordingJobSource, sizeof(struct tt__RecordingJobSource), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__RecordingJobConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobConfiguration, sizeof(struct tt__RecordingJobConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Mode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Source", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->Mode || soap_flag_Priority > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__RecordingJobConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobConfiguration, SOAP_TYPE_tt__RecordingJobConfiguration, sizeof(struct tt__RecordingJobConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__GetTracksResponseItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetTracksResponseItem, sizeof(struct tt__GetTracksResponseItem), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->TrackToken || !a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__GetTracksResponseItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetTracksResponseItem, SOAP_TYPE_tt__GetTracksResponseItem, sizeof(struct tt__GetTracksResponseItem), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__GetTracksResponseList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetTracksResponseList, sizeof(struct tt__GetTracksResponseList), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Track", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__GetTracksResponseList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetTracksResponseList, SOAP_TYPE_tt__GetTracksResponseList, sizeof(struct tt__GetTracksResponseList), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__GetRecordingsResponseItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetRecordingsResponseItem, sizeof(struct tt__GetRecordingsResponseItem), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Tracks && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->Configuration || !a->Tracks))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__GetRecordingsResponseItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetRecordingsResponseItem, SOAP_TYPE_tt__GetRecordingsResponseItem, sizeof(struct tt__GetRecordingsResponseItem), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__TrackConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackConfiguration, sizeof(struct tt__TrackConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_TrackType && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TrackType > 0 || !a->Description))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__TrackConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackConfiguration, SOAP_TYPE_tt__TrackConfiguration, sizeof(struct tt__TrackConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RecordingConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingConfiguration, sizeof(struct tt__RecordingConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Content && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_MaximumRetentionTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Source || !a->Content || soap_flag_MaximumRetentionTime > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__RecordingConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingConfiguration, SOAP_TYPE_tt__RecordingConfiguration, sizeof(struct tt__RecordingConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__TrackAttributesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackAttributesExtension, sizeof(struct tt__TrackAttributesExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__TrackAttributesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackAttributesExtension, SOAP_TYPE_tt__TrackAttributesExtension, sizeof(struct tt__TrackAttributesExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__MetadataAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataAttributes, sizeof(struct tt__MetadataAttributes), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CanContainPTZ && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CanContainAnalytics && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CanContainNotifications && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CanContainPTZ > 0 || soap_flag_CanContainAnalytics > 0 || soap_flag_CanContainNotifications > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__MetadataAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataAttributes, SOAP_TYPE_tt__MetadataAttributes, sizeof(struct tt__MetadataAttributes), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AudioAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioAttributes, sizeof(struct tt__AudioAttributes), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Encoding && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Samplerate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Encoding || soap_flag_Samplerate > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AudioAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioAttributes, SOAP_TYPE_tt__AudioAttributes, sizeof(struct tt__AudioAttributes), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__VideoAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAttributes, sizeof(struct tt__VideoAttributes), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Width && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Height && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Encoding && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Framerate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width > 0 || soap_flag_Height > 0 || !a->Encoding || soap_flag_Framerate > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__VideoAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAttributes, SOAP_TYPE_tt__VideoAttributes, sizeof(struct tt__VideoAttributes), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__TrackAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackAttributes, sizeof(struct tt__TrackAttributes), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_TrackInformation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_VideoAttributes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AudioAttributes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MetadataAttributes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->TrackInformation))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__TrackAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackAttributes, SOAP_TYPE_tt__TrackAttributes, sizeof(struct tt__TrackAttributes), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__MediaAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaAttributes, sizeof(struct tt__MediaAttributes), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:TrackAttributes", 1, NULL))
./soapC.c:			if (soap_flag_From && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Until && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || soap_flag_From > 0 || soap_flag_Until > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__MediaAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaAttributes, SOAP_TYPE_tt__MediaAttributes, sizeof(struct tt__MediaAttributes), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__TrackInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackInformation, sizeof(struct tt__TrackInformation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_TrackType && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_DataFrom && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DataTo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->TrackToken || soap_flag_TrackType > 0 || !a->Description || soap_flag_DataFrom > 0 || soap_flag_DataTo > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__TrackInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackInformation, SOAP_TYPE_tt__TrackInformation, sizeof(struct tt__TrackInformation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RecordingSourceInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingSourceInformation, sizeof(struct tt__RecordingSourceInformation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SourceId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Location && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SourceId || !a->Name || !a->Location || !a->Description || !a->Address))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__RecordingSourceInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingSourceInformation, SOAP_TYPE_tt__RecordingSourceInformation, sizeof(struct tt__RecordingSourceInformation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__FindMetadataResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindMetadataResult, sizeof(struct tt__FindMetadataResult), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->TrackToken || soap_flag_Time > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__FindMetadataResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindMetadataResult, SOAP_TYPE_tt__FindMetadataResult, sizeof(struct tt__FindMetadataResult), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__FindMetadataResultList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindMetadataResultList, sizeof(struct tt__FindMetadataResultList), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SearchState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Result", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__FindMetadataResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindMetadataResultList, SOAP_TYPE_tt__FindMetadataResultList, sizeof(struct tt__FindMetadataResultList), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__FindPTZPositionResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindPTZPositionResult, sizeof(struct tt__FindPTZPositionResult), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->TrackToken || soap_flag_Time > 0 || !a->Position))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__FindPTZPositionResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindPTZPositionResult, SOAP_TYPE_tt__FindPTZPositionResult, sizeof(struct tt__FindPTZPositionResult), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__FindPTZPositionResultList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindPTZPositionResultList, sizeof(struct tt__FindPTZPositionResultList), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SearchState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Result", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__FindPTZPositionResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindPTZPositionResultList, SOAP_TYPE_tt__FindPTZPositionResultList, sizeof(struct tt__FindPTZPositionResultList), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsnt__NotificationMessageHolderType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(struct wsnt__NotificationMessageHolderType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Topic && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ProducerReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Message && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsnt__NotificationMessageHolderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NotificationMessageHolderType, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(struct wsnt__NotificationMessageHolderType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__FindEventResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindEventResult, sizeof(struct tt__FindEventResult), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Event && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_StartStateEvent && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->TrackToken || soap_flag_Time > 0 || !a->Event || soap_flag_StartStateEvent > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__FindEventResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindEventResult, SOAP_TYPE_tt__FindEventResult, sizeof(struct tt__FindEventResult), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__FindEventResultList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindEventResultList, sizeof(struct tt__FindEventResultList), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SearchState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Result", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__FindEventResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindEventResultList, SOAP_TYPE_tt__FindEventResultList, sizeof(struct tt__FindEventResultList), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RecordingInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingInformation, sizeof(struct tt__RecordingInformation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_EarliestRecording && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_LatestRecording && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Content && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Track", 1, NULL))
./soapC.c:			if (soap_flag_RecordingStatus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->Source || !a->Content || soap_flag_RecordingStatus > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__RecordingInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingInformation, SOAP_TYPE_tt__RecordingInformation, sizeof(struct tt__RecordingInformation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__FindRecordingResultList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindRecordingResultList, sizeof(struct tt__FindRecordingResultList), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SearchState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RecordingInformation", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__FindRecordingResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindRecordingResultList, SOAP_TYPE_tt__FindRecordingResultList, sizeof(struct tt__FindRecordingResultList), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__MetadataFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataFilter, sizeof(struct tt__MetadataFilter), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_MetadataStreamFilter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->MetadataStreamFilter))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__MetadataFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataFilter, SOAP_TYPE_tt__MetadataFilter, sizeof(struct tt__MetadataFilter), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZPositionFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPositionFilter, sizeof(struct tt__PTZPositionFilter), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_MinPosition && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxPosition && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_EnterOrExit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->MinPosition || !a->MaxPosition || soap_flag_EnterOrExit > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PTZPositionFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPositionFilter, SOAP_TYPE_tt__PTZPositionFilter, sizeof(struct tt__PTZPositionFilter), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__SearchScopeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchScopeExtension, sizeof(struct tt__SearchScopeExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__SearchScopeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchScopeExtension, SOAP_TYPE_tt__SearchScopeExtension, sizeof(struct tt__SearchScopeExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__SearchScope *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchScope, sizeof(struct tt__SearchScope), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IncludedSources", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IncludedRecordings", 1, NULL))
./soapC.c:			if (soap_flag_RecordingInformationFilter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__SearchScope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchScope, SOAP_TYPE_tt__SearchScope, sizeof(struct tt__SearchScope), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RecordingSummary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingSummary, sizeof(struct tt__RecordingSummary), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_DataFrom && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DataUntil && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_NumberRecordings && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DataFrom > 0 || soap_flag_DataUntil > 0 || soap_flag_NumberRecordings > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__RecordingSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingSummary, SOAP_TYPE_tt__RecordingSummary, sizeof(struct tt__RecordingSummary), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__SourceReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SourceReference, sizeof(struct tt__SourceReference), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__SourceReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SourceReference, SOAP_TYPE_tt__SourceReference, sizeof(struct tt__SourceReference), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ReceiverStateInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverStateInformation, sizeof(struct tt__ReceiverStateInformation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AutoCreated && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0 || soap_flag_AutoCreated > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ReceiverStateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverStateInformation, SOAP_TYPE_tt__ReceiverStateInformation, sizeof(struct tt__ReceiverStateInformation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ReceiverConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverConfiguration, sizeof(struct tt__ReceiverConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MediaUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_StreamSetup && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || !a->MediaUri || !a->StreamSetup))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ReceiverConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverConfiguration, SOAP_TYPE_tt__ReceiverConfiguration, sizeof(struct tt__ReceiverConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__Receiver *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Receiver, sizeof(struct tt__Receiver), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token || !a->Configuration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Receiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Receiver, SOAP_TYPE_tt__Receiver, sizeof(struct tt__Receiver), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PaneOptionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneOptionExtension, sizeof(struct tt__PaneOptionExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PaneOptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneOptionExtension, SOAP_TYPE_tt__PaneOptionExtension, sizeof(struct tt__PaneOptionExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__LayoutOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LayoutOptionsExtension, sizeof(struct tt__LayoutOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__LayoutOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LayoutOptionsExtension, SOAP_TYPE_tt__LayoutOptionsExtension, sizeof(struct tt__LayoutOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PaneLayoutOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneLayoutOptions, sizeof(struct tt__PaneLayoutOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Area", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeArea < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PaneLayoutOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneLayoutOptions, SOAP_TYPE_tt__PaneLayoutOptions, sizeof(struct tt__PaneLayoutOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__LayoutOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LayoutOptions, sizeof(struct tt__LayoutOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PaneLayoutOptions", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePaneLayoutOptions < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__LayoutOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LayoutOptions, SOAP_TYPE_tt__LayoutOptions, sizeof(struct tt__LayoutOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__CodingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CodingCapabilities, sizeof(struct tt__CodingCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AudioEncodingCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AudioDecodingCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_VideoDecodingCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoDecodingCapabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__CodingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CodingCapabilities, SOAP_TYPE_tt__CodingCapabilities, sizeof(struct tt__CodingCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__LayoutExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LayoutExtension, sizeof(struct tt__LayoutExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__LayoutExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LayoutExtension, SOAP_TYPE_tt__LayoutExtension, sizeof(struct tt__LayoutExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Layout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Layout, sizeof(struct tt__Layout), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PaneLayout", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePaneLayout < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Layout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Layout, SOAP_TYPE_tt__Layout, sizeof(struct tt__Layout), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PaneLayout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneLayout, sizeof(struct tt__PaneLayout), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Pane && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Area && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Pane || !a->Area))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PaneLayout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneLayout, SOAP_TYPE_tt__PaneLayout, sizeof(struct tt__PaneLayout), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PaneConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneConfiguration, sizeof(struct tt__PaneConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PaneName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_AudioOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_AudioSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_AudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneConfiguration, SOAP_TYPE_tt__PaneConfiguration, sizeof(struct tt__PaneConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Transformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Transformation, sizeof(struct tt__Transformation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Translate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Scale && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__Transformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Transformation, SOAP_TYPE_tt__Transformation, sizeof(struct tt__Transformation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__CellLayout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CellLayout, sizeof(struct tt__CellLayout), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Transformation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Transformation))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__CellLayout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CellLayout, SOAP_TYPE_tt__CellLayout, sizeof(struct tt__CellLayout), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__MotionExpressionConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MotionExpressionConfiguration, sizeof(struct tt__MotionExpressionConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_MotionExpression && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->MotionExpression))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__MotionExpressionConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MotionExpressionConfiguration, SOAP_TYPE_tt__MotionExpressionConfiguration, sizeof(struct tt__MotionExpressionConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__MotionExpression *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MotionExpression, sizeof(struct tt__MotionExpression), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Expression && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Expression))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__MotionExpression *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MotionExpression, SOAP_TYPE_tt__MotionExpression, sizeof(struct tt__MotionExpression), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PolylineArrayConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolylineArrayConfiguration, sizeof(struct tt__PolylineArrayConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PolylineArray && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PolylineArray))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PolylineArrayConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolylineArrayConfiguration, SOAP_TYPE_tt__PolylineArrayConfiguration, sizeof(struct tt__PolylineArrayConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PolylineArrayExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolylineArrayExtension, sizeof(struct tt__PolylineArrayExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PolylineArrayExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolylineArrayExtension, SOAP_TYPE_tt__PolylineArrayExtension, sizeof(struct tt__PolylineArrayExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PolylineArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolylineArray, sizeof(struct tt__PolylineArray), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Segment", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeSegment < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PolylineArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolylineArray, SOAP_TYPE_tt__PolylineArray, sizeof(struct tt__PolylineArray), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__Polygon *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Polygon, sizeof(struct tt__Polygon), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Point", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePoint < 3))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Polygon *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Polygon, SOAP_TYPE_tt__Polygon, sizeof(struct tt__Polygon), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PolygonConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolygonConfiguration, sizeof(struct tt__PolygonConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Polygon && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Polygon))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PolygonConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolygonConfiguration, SOAP_TYPE_tt__PolygonConfiguration, sizeof(struct tt__PolygonConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__SupportedAnalyticsModulesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, sizeof(struct tt__SupportedAnalyticsModulesExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__SupportedAnalyticsModulesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, sizeof(struct tt__SupportedAnalyticsModulesExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__SupportedAnalyticsModules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedAnalyticsModules, sizeof(struct tt__SupportedAnalyticsModules), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AnalyticsModuleContentSchemaLocation", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AnalyticsModuleDescription", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__SupportedAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedAnalyticsModules, SOAP_TYPE_tt__SupportedAnalyticsModules, sizeof(struct tt__SupportedAnalyticsModules), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__SupportedRulesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedRulesExtension, sizeof(struct tt__SupportedRulesExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__SupportedRulesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedRulesExtension, SOAP_TYPE_tt__SupportedRulesExtension, sizeof(struct tt__SupportedRulesExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__SupportedRules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedRules, sizeof(struct tt__SupportedRules), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RuleContentSchemaLocation", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RuleDescription", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__SupportedRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedRules, SOAP_TYPE_tt__SupportedRules, sizeof(struct tt__SupportedRules), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ConfigDescriptionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigDescriptionExtension, sizeof(struct tt__ConfigDescriptionExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ConfigDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigDescriptionExtension, SOAP_TYPE_tt__ConfigDescriptionExtension, sizeof(struct tt__ConfigDescriptionExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tt__ConfigDescription_Messages *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ConfigDescription_Messages, sizeof(struct _tt__ConfigDescription_Messages), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ParentTopic && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ParentTopic))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tt__ConfigDescription_Messages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ConfigDescription_Messages, SOAP_TYPE__tt__ConfigDescription_Messages, sizeof(struct _tt__ConfigDescription_Messages), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ConfigDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigDescription, sizeof(struct tt__ConfigDescription), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Parameters && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Messages", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Parameters))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ConfigDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigDescription, SOAP_TYPE_tt__ConfigDescription, sizeof(struct tt__ConfigDescription), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RuleEngineConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(struct tt__RuleEngineConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__RuleEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RuleEngineConfigurationExtension, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(struct tt__RuleEngineConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__RuleEngineConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(struct tt__RuleEngineConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Rule", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__RuleEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RuleEngineConfiguration, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(struct tt__RuleEngineConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AnalyticsEngineConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(struct tt__AnalyticsEngineConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__AnalyticsEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(struct tt__AnalyticsEngineConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Config *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Config, sizeof(struct tt__Config), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Parameters && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Parameters))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Config *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Config, SOAP_TYPE_tt__Config, sizeof(struct tt__Config), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__AnalyticsEngineConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(struct tt__AnalyticsEngineConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AnalyticsModule", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__AnalyticsEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineConfiguration, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(struct tt__AnalyticsEngineConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Vector *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector, sizeof(struct tt__Vector), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__Vector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector, SOAP_TYPE_tt__Vector, sizeof(struct tt__Vector), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__Polyline *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Polyline, sizeof(struct tt__Polyline), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Point", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePoint < 2))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Polyline *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Polyline, SOAP_TYPE_tt__Polyline, sizeof(struct tt__Polyline), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ItemListDescriptionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(struct tt__ItemListDescriptionExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ItemListDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListDescriptionExtension, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(struct tt__ItemListDescriptionExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tt__ItemListDescription_ElementItemDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tt__ItemListDescription_ElementItemDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tt__ItemListDescription_SimpleItemDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tt__ItemListDescription_SimpleItemDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__MessageDescriptionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(struct tt__MessageDescriptionExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__MessageDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageDescriptionExtension, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(struct tt__MessageDescriptionExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ItemListDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListDescription, sizeof(struct tt__ItemListDescription), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SimpleItemDescription", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ElementItemDescription", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ItemListDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListDescription, SOAP_TYPE_tt__ItemListDescription, sizeof(struct tt__ItemListDescription), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__MessageDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageDescription, sizeof(struct tt__MessageDescription), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__MessageDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageDescription, SOAP_TYPE_tt__MessageDescription, sizeof(struct tt__MessageDescription), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ItemListExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListExtension, sizeof(struct tt__ItemListExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ItemListExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListExtension, SOAP_TYPE_tt__ItemListExtension, sizeof(struct tt__ItemListExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tt__ItemList_ElementItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(struct _tt__ItemList_ElementItem), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tt__ItemList_ElementItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemList_ElementItem, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(struct _tt__ItemList_ElementItem), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tt__ItemList_SimpleItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tt__ItemList_SimpleItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemList_SimpleItem, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ItemList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemList, sizeof(struct tt__ItemList), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SimpleItem", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ElementItem", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemList, SOAP_TYPE_tt__ItemList, sizeof(struct tt__ItemList), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__MessageExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageExtension, sizeof(struct tt__MessageExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__MessageExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageExtension, SOAP_TYPE_tt__MessageExtension, sizeof(struct tt__MessageExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__FocusOptions20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(struct tt__FocusOptions20Extension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__FocusOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions20Extension, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(struct tt__FocusOptions20Extension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__WhiteBalanceOptions20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(struct tt__WhiteBalanceOptions20Extension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__WhiteBalanceOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(struct tt__WhiteBalanceOptions20Extension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__FocusConfiguration20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(struct tt__FocusConfiguration20Extension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__FocusConfiguration20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration20Extension, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(struct tt__FocusConfiguration20Extension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__WhiteBalance20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(struct tt__WhiteBalance20Extension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__WhiteBalance20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance20Extension, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(struct tt__WhiteBalance20Extension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__RelativeFocusOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(struct tt__RelativeFocusOptions20), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Distance && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Distance))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__RelativeFocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocusOptions20, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(struct tt__RelativeFocusOptions20), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__MoveOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveOptions20, sizeof(struct tt__MoveOptions20), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Absolute && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Relative && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Continuous && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__MoveOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveOptions20, SOAP_TYPE_tt__MoveOptions20, sizeof(struct tt__MoveOptions20), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__IrCutFilterAutoAdjustmentOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, sizeof(struct tt__IrCutFilterAutoAdjustmentOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__IrCutFilterAutoAdjustmentOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, sizeof(struct tt__IrCutFilterAutoAdjustmentOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ImageStabilizationOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, sizeof(struct tt__ImageStabilizationOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ImageStabilizationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, sizeof(struct tt__ImageStabilizationOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ImagingOptions20Extension4 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension4, sizeof(struct tt__ImagingOptions20Extension4), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ImagingOptions20Extension4 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension4, SOAP_TYPE_tt__ImagingOptions20Extension4, sizeof(struct tt__ImagingOptions20Extension4), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__NoiseReductionOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NoiseReductionOptions, sizeof(struct tt__NoiseReductionOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Level > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__NoiseReductionOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NoiseReductionOptions, SOAP_TYPE_tt__NoiseReductionOptions, sizeof(struct tt__NoiseReductionOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__DefoggingOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DefoggingOptions, sizeof(struct tt__DefoggingOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
./soapC.c:			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || soap_flag_Level > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__DefoggingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DefoggingOptions, SOAP_TYPE_tt__DefoggingOptions, sizeof(struct tt__DefoggingOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ToneCompensationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensationOptions, sizeof(struct tt__ToneCompensationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
./soapC.c:			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || soap_flag_Level > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ToneCompensationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensationOptions, SOAP_TYPE_tt__ToneCompensationOptions, sizeof(struct tt__ToneCompensationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ImagingOptions20Extension3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension3, sizeof(struct tt__ImagingOptions20Extension3), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ToneCompensationOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DefoggingOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_NoiseReductionOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ImagingOptions20Extension3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension3, SOAP_TYPE_tt__ImagingOptions20Extension3, sizeof(struct tt__ImagingOptions20Extension3), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__IrCutFilterAutoAdjustmentOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, sizeof(struct tt__IrCutFilterAutoAdjustmentOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:BoundaryType", 1, NULL))
./soapC.c:			if (soap_flag_BoundaryOffset && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ResponseTimeRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeBoundaryType < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__IrCutFilterAutoAdjustmentOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, sizeof(struct tt__IrCutFilterAutoAdjustmentOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ImagingOptions20Extension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension2, sizeof(struct tt__ImagingOptions20Extension2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_IrCutFilterAutoAdjustment && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ImagingOptions20Extension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension2, SOAP_TYPE_tt__ImagingOptions20Extension2, sizeof(struct tt__ImagingOptions20Extension2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ImageStabilizationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationOptions, sizeof(struct tt__ImageStabilizationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
./soapC.c:			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ImageStabilizationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationOptions, SOAP_TYPE_tt__ImageStabilizationOptions, sizeof(struct tt__ImageStabilizationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ImagingOptions20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(struct tt__ImagingOptions20Extension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ImageStabilization && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ImagingOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(struct tt__ImagingOptions20Extension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__WhiteBalanceOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(struct tt__WhiteBalanceOptions20), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
./soapC.c:			if (soap_flag_YrGain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_YbGain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__WhiteBalanceOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions20, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(struct tt__WhiteBalanceOptions20), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__WideDynamicRangeOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(struct tt__WideDynamicRangeOptions20), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
./soapC.c:			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__WideDynamicRangeOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRangeOptions20, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(struct tt__WideDynamicRangeOptions20), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__FocusOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions20, sizeof(struct tt__FocusOptions20), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AutoFocusModes", 1, NULL))
./soapC.c:			if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__FocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions20, SOAP_TYPE_tt__FocusOptions20, sizeof(struct tt__FocusOptions20), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ExposureOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureOptions20, sizeof(struct tt__ExposureOptions20), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Priority", 1, NULL))
./soapC.c:			if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ExposureOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureOptions20, SOAP_TYPE_tt__ExposureOptions20, sizeof(struct tt__ExposureOptions20), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__BacklightCompensationOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(struct tt__BacklightCompensationOptions20), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
./soapC.c:			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__BacklightCompensationOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationOptions20, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(struct tt__BacklightCompensationOptions20), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ImagingOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20, sizeof(struct tt__ImagingOptions20), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IrCutFilterModes", 1, NULL))
./soapC.c:			if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ImagingOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20, SOAP_TYPE_tt__ImagingOptions20, sizeof(struct tt__ImagingOptions20), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__DefoggingExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DefoggingExtension, sizeof(struct tt__DefoggingExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__DefoggingExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DefoggingExtension, SOAP_TYPE_tt__DefoggingExtension, sizeof(struct tt__DefoggingExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ToneCompensationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensationExtension, sizeof(struct tt__ToneCompensationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ToneCompensationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensationExtension, SOAP_TYPE_tt__ToneCompensationExtension, sizeof(struct tt__ToneCompensationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__IrCutFilterAutoAdjustmentExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, sizeof(struct tt__IrCutFilterAutoAdjustmentExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__IrCutFilterAutoAdjustmentExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, sizeof(struct tt__IrCutFilterAutoAdjustmentExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ImageStabilizationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationExtension, sizeof(struct tt__ImageStabilizationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ImageStabilizationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationExtension, SOAP_TYPE_tt__ImageStabilizationExtension, sizeof(struct tt__ImageStabilizationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ImagingSettingsExtension204 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension204, sizeof(struct tt__ImagingSettingsExtension204), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ImagingSettingsExtension204 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension204, SOAP_TYPE_tt__ImagingSettingsExtension204, sizeof(struct tt__ImagingSettingsExtension204), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__NoiseReduction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NoiseReduction, sizeof(struct tt__NoiseReduction), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Level > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__NoiseReduction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NoiseReduction, SOAP_TYPE_tt__NoiseReduction, sizeof(struct tt__NoiseReduction), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Defogging *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Defogging, sizeof(struct tt__Defogging), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Mode))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Defogging *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Defogging, SOAP_TYPE_tt__Defogging, sizeof(struct tt__Defogging), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ToneCompensation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensation, sizeof(struct tt__ToneCompensation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Mode))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ToneCompensation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensation, SOAP_TYPE_tt__ToneCompensation, sizeof(struct tt__ToneCompensation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ImagingSettingsExtension203 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension203, sizeof(struct tt__ImagingSettingsExtension203), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ToneCompensation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Defogging && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_NoiseReduction && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ImagingSettingsExtension203 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension203, SOAP_TYPE_tt__ImagingSettingsExtension203, sizeof(struct tt__ImagingSettingsExtension203), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__IrCutFilterAutoAdjustment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, sizeof(struct tt__IrCutFilterAutoAdjustment), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_BoundaryType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_BoundaryOffset && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ResponseTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->BoundaryType))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__IrCutFilterAutoAdjustment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, sizeof(struct tt__IrCutFilterAutoAdjustment), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ImagingSettingsExtension202 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension202, sizeof(struct tt__ImagingSettingsExtension202), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IrCutFilterAutoAdjustment", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ImagingSettingsExtension202 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension202, SOAP_TYPE_tt__ImagingSettingsExtension202, sizeof(struct tt__ImagingSettingsExtension202), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ImageStabilization *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilization, sizeof(struct tt__ImageStabilization), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ImageStabilization *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilization, SOAP_TYPE_tt__ImageStabilization, sizeof(struct tt__ImageStabilization), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ImagingSettingsExtension20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(struct tt__ImagingSettingsExtension20), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ImageStabilization && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ImagingSettingsExtension20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension20, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(struct tt__ImagingSettingsExtension20), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__WhiteBalance20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance20, sizeof(struct tt__WhiteBalance20), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CrGain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CbGain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__WhiteBalance20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance20, SOAP_TYPE_tt__WhiteBalance20, sizeof(struct tt__WhiteBalance20), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__WideDynamicRange20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRange20, sizeof(struct tt__WideDynamicRange20), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__WideDynamicRange20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRange20, SOAP_TYPE_tt__WideDynamicRange20, sizeof(struct tt__WideDynamicRange20), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__FocusConfiguration20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration20, sizeof(struct tt__FocusConfiguration20), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AutoFocusMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoFocusMode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__FocusConfiguration20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration20, SOAP_TYPE_tt__FocusConfiguration20, sizeof(struct tt__FocusConfiguration20), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Exposure20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Exposure20, sizeof(struct tt__Exposure20), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Window && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Exposure20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Exposure20, SOAP_TYPE_tt__Exposure20, sizeof(struct tt__Exposure20), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__BacklightCompensation20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensation20, sizeof(struct tt__BacklightCompensation20), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__BacklightCompensation20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensation20, SOAP_TYPE_tt__BacklightCompensation20, sizeof(struct tt__BacklightCompensation20), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__FocusStatus20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus20Extension, sizeof(struct tt__FocusStatus20Extension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__FocusStatus20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus20Extension, SOAP_TYPE_tt__FocusStatus20Extension, sizeof(struct tt__FocusStatus20Extension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ImagingStatus20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus20Extension, sizeof(struct tt__ImagingStatus20Extension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ImagingStatus20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus20Extension, SOAP_TYPE_tt__ImagingStatus20Extension, sizeof(struct tt__ImagingStatus20Extension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__FocusStatus20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus20, sizeof(struct tt__FocusStatus20), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MoveStatus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position > 0 || soap_flag_MoveStatus > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__FocusStatus20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus20, SOAP_TYPE_tt__FocusStatus20, sizeof(struct tt__FocusStatus20), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ImagingStatus20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus20, sizeof(struct tt__ImagingStatus20), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_FocusStatus20 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ImagingStatus20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus20, SOAP_TYPE_tt__ImagingStatus20, sizeof(struct tt__ImagingStatus20), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ContinuousFocusOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(struct tt__ContinuousFocusOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Speed))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ContinuousFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ContinuousFocusOptions, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(struct tt__ContinuousFocusOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__RelativeFocusOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocusOptions, sizeof(struct tt__RelativeFocusOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Distance && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Distance || !a->Speed))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__RelativeFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocusOptions, SOAP_TYPE_tt__RelativeFocusOptions, sizeof(struct tt__RelativeFocusOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__AbsoluteFocusOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(struct tt__AbsoluteFocusOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Position))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AbsoluteFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AbsoluteFocusOptions, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(struct tt__AbsoluteFocusOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__MoveOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveOptions, sizeof(struct tt__MoveOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Absolute && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Relative && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Continuous && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__MoveOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveOptions, SOAP_TYPE_tt__MoveOptions, sizeof(struct tt__MoveOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ContinuousFocus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ContinuousFocus, sizeof(struct tt__ContinuousFocus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Speed > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ContinuousFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ContinuousFocus, SOAP_TYPE_tt__ContinuousFocus, sizeof(struct tt__ContinuousFocus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__RelativeFocus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocus, sizeof(struct tt__RelativeFocus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Distance && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Distance > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__RelativeFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocus, SOAP_TYPE_tt__RelativeFocus, sizeof(struct tt__RelativeFocus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__AbsoluteFocus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AbsoluteFocus, sizeof(struct tt__AbsoluteFocus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AbsoluteFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AbsoluteFocus, SOAP_TYPE_tt__AbsoluteFocus, sizeof(struct tt__AbsoluteFocus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__FocusMove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusMove, sizeof(struct tt__FocusMove), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Absolute && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Relative && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Continuous && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__FocusMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusMove, SOAP_TYPE_tt__FocusMove, sizeof(struct tt__FocusMove), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__WhiteBalanceOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions, sizeof(struct tt__WhiteBalanceOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
./soapC.c:			if (soap_flag_YrGain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_YbGain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || !a->YrGain || !a->YbGain))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__WhiteBalanceOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions, SOAP_TYPE_tt__WhiteBalanceOptions, sizeof(struct tt__WhiteBalanceOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__WideDynamicRangeOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRangeOptions, sizeof(struct tt__WideDynamicRangeOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
./soapC.c:			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || !a->Level))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__WideDynamicRangeOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRangeOptions, SOAP_TYPE_tt__WideDynamicRangeOptions, sizeof(struct tt__WideDynamicRangeOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__FocusOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions, sizeof(struct tt__FocusOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AutoFocusModes", 1, NULL))
./soapC.c:			if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->DefaultSpeed || !a->NearLimit || !a->FarLimit))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__FocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions, SOAP_TYPE_tt__FocusOptions, sizeof(struct tt__FocusOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ExposureOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureOptions, sizeof(struct tt__ExposureOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Priority", 1, NULL))
./soapC.c:			if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || a->__sizePriority < 1 || !a->MinExposureTime || !a->MaxExposureTime || !a->MinGain || !a->MaxGain || !a->MinIris || !a->MaxIris || !a->ExposureTime || !a->Gain || !a->Iris))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ExposureOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureOptions, SOAP_TYPE_tt__ExposureOptions, sizeof(struct tt__ExposureOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__BacklightCompensationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationOptions, sizeof(struct tt__BacklightCompensationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
./soapC.c:			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || !a->Level))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__BacklightCompensationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationOptions, SOAP_TYPE_tt__BacklightCompensationOptions, sizeof(struct tt__BacklightCompensationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ImagingOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions, sizeof(struct tt__ImagingOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IrCutFilterModes", 1, NULL))
./soapC.c:			if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->BacklightCompensation || !a->Brightness || !a->ColorSaturation || !a->Contrast || !a->Exposure || !a->Focus || a->__sizeIrCutFilterModes < 1 || !a->Sharpness || !a->WideDynamicRange || !a->WhiteBalance))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ImagingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions, SOAP_TYPE_tt__ImagingOptions, sizeof(struct tt__ImagingOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Rectangle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rectangle, sizeof(struct tt__Rectangle), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__Rectangle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Rectangle, SOAP_TYPE_tt__Rectangle, sizeof(struct tt__Rectangle), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ImagingSettingsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension, sizeof(struct tt__ImagingSettingsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ImagingSettingsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension, SOAP_TYPE_tt__ImagingSettingsExtension, sizeof(struct tt__ImagingSettingsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__WhiteBalance *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance, sizeof(struct tt__WhiteBalance), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CrGain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CbGain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_CrGain > 0 || soap_flag_CbGain > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__WhiteBalance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance, SOAP_TYPE_tt__WhiteBalance, sizeof(struct tt__WhiteBalance), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__WideDynamicRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRange, sizeof(struct tt__WideDynamicRange), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_Level > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__WideDynamicRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRange, SOAP_TYPE_tt__WideDynamicRange, sizeof(struct tt__WideDynamicRange), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Exposure *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Exposure, sizeof(struct tt__Exposure), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Window && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_Priority > 0 || !a->Window || soap_flag_MinExposureTime > 0 || soap_flag_MaxExposureTime > 0 || soap_flag_MinGain > 0 || soap_flag_MaxGain > 0 || soap_flag_MinIris > 0 || soap_flag_MaxIris > 0 || soap_flag_ExposureTime > 0 || soap_flag_Gain > 0 || soap_flag_Iris > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Exposure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Exposure, SOAP_TYPE_tt__Exposure, sizeof(struct tt__Exposure), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__BacklightCompensation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensation, sizeof(struct tt__BacklightCompensation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_Level > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__BacklightCompensation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensation, SOAP_TYPE_tt__BacklightCompensation, sizeof(struct tt__BacklightCompensation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ImagingSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettings, sizeof(struct tt__ImagingSettings), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_IrCutFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettings, SOAP_TYPE_tt__ImagingSettings, sizeof(struct tt__ImagingSettings), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__FocusConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration, sizeof(struct tt__FocusConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AutoFocusMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoFocusMode > 0 || soap_flag_DefaultSpeed > 0 || soap_flag_NearLimit > 0 || soap_flag_FarLimit > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__FocusConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration, SOAP_TYPE_tt__FocusConfiguration, sizeof(struct tt__FocusConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__FocusStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus, sizeof(struct tt__FocusStatus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MoveStatus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position > 0 || soap_flag_MoveStatus > 0 || !a->Error))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__FocusStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus, SOAP_TYPE_tt__FocusStatus, sizeof(struct tt__FocusStatus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ImagingStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus, sizeof(struct tt__ImagingStatus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_FocusStatus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->FocusStatus))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ImagingStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus, SOAP_TYPE_tt__ImagingStatus, sizeof(struct tt__ImagingStatus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZPresetTourStartingConditionOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, sizeof(struct tt__PTZPresetTourStartingConditionOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZPresetTourStartingConditionOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, sizeof(struct tt__PTZPresetTourStartingConditionOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZPresetTourPresetDetailOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, sizeof(struct tt__PTZPresetTourPresetDetailOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZPresetTourPresetDetailOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, sizeof(struct tt__PTZPresetTourPresetDetailOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZPresetTourPresetDetailOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, sizeof(struct tt__PTZPresetTourPresetDetailOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PresetToken", 1, NULL))
./soapC.c:			if (soap_flag_Home && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_PanTiltPositionSpace && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ZoomPositionSpace && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZPresetTourPresetDetailOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, sizeof(struct tt__PTZPresetTourPresetDetailOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZPresetTourSpotOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSpotOptions, sizeof(struct tt__PTZPresetTourSpotOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PresetDetail && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_StayTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PresetDetail || !a->StayTime))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PTZPresetTourSpotOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSpotOptions, SOAP_TYPE_tt__PTZPresetTourSpotOptions, sizeof(struct tt__PTZPresetTourSpotOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZPresetTourStartingConditionOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, sizeof(struct tt__PTZPresetTourStartingConditionOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecurringTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RecurringDuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Direction", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZPresetTourStartingConditionOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, sizeof(struct tt__PTZPresetTourStartingConditionOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZPresetTourOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourOptions, sizeof(struct tt__PTZPresetTourOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AutoStart && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_StartingCondition && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_TourSpot && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoStart > 0 || !a->StartingCondition || !a->TourSpot))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PTZPresetTourOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourOptions, SOAP_TYPE_tt__PTZPresetTourOptions, sizeof(struct tt__PTZPresetTourOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZPresetTourStartingConditionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, sizeof(struct tt__PTZPresetTourStartingConditionExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZPresetTourStartingConditionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, sizeof(struct tt__PTZPresetTourStartingConditionExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZPresetTourStatusExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStatusExtension, sizeof(struct tt__PTZPresetTourStatusExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZPresetTourStatusExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStatusExtension, SOAP_TYPE_tt__PTZPresetTourStatusExtension, sizeof(struct tt__PTZPresetTourStatusExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZPresetTourTypeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourTypeExtension, sizeof(struct tt__PTZPresetTourTypeExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZPresetTourTypeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourTypeExtension, SOAP_TYPE_tt__PTZPresetTourTypeExtension, sizeof(struct tt__PTZPresetTourTypeExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZPresetTourSpotExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSpotExtension, sizeof(struct tt__PTZPresetTourSpotExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZPresetTourSpotExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSpotExtension, SOAP_TYPE_tt__PTZPresetTourSpotExtension, sizeof(struct tt__PTZPresetTourSpotExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZPresetTourPresetDetail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetail, sizeof(struct tt__PTZPresetTourPresetDetail), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_union_PTZPresetTourPresetDetail && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_PTZPresetTourPresetDetail))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PTZPresetTourPresetDetail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourPresetDetail, SOAP_TYPE_tt__PTZPresetTourPresetDetail, sizeof(struct tt__PTZPresetTourPresetDetail), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZPresetTourExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourExtension, sizeof(struct tt__PTZPresetTourExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZPresetTourExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourExtension, SOAP_TYPE_tt__PTZPresetTourExtension, sizeof(struct tt__PTZPresetTourExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZPresetTourSpot *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSpot, sizeof(struct tt__PTZPresetTourSpot), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PresetDetail && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_StayTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PresetDetail))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PTZPresetTourSpot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSpot, SOAP_TYPE_tt__PTZPresetTourSpot, sizeof(struct tt__PTZPresetTourSpot), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZPresetTourStartingCondition *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStartingCondition, sizeof(struct tt__PTZPresetTourStartingCondition), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RecurringTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RecurringDuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Direction && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZPresetTourStartingCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStartingCondition, SOAP_TYPE_tt__PTZPresetTourStartingCondition, sizeof(struct tt__PTZPresetTourStartingCondition), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZPresetTourStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStatus, sizeof(struct tt__PTZPresetTourStatus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CurrentTourSpot && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PTZPresetTourStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStatus, SOAP_TYPE_tt__PTZPresetTourStatus, sizeof(struct tt__PTZPresetTourStatus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PresetTour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PresetTour, sizeof(struct tt__PresetTour), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AutoStart && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_StartingCondition && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:TourSpot", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Status || soap_flag_AutoStart > 0 || !a->StartingCondition))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PresetTour, SOAP_TYPE_tt__PresetTour, sizeof(struct tt__PresetTour), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZVector *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZVector, sizeof(struct tt__PTZVector), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZVector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZVector, SOAP_TYPE_tt__PTZVector, sizeof(struct tt__PTZVector), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZPreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPreset, sizeof(struct tt__PTZPreset), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PTZPosition && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPreset, SOAP_TYPE_tt__PTZPreset, sizeof(struct tt__PTZPreset), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Vector1D *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector1D, sizeof(struct tt__Vector1D), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__Vector1D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector1D, SOAP_TYPE_tt__Vector1D, sizeof(struct tt__Vector1D), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Vector2D *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector2D, sizeof(struct tt__Vector2D), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__Vector2D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector2D, SOAP_TYPE_tt__Vector2D, sizeof(struct tt__Vector2D), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZSpeed *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpeed, sizeof(struct tt__PTZSpeed), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZSpeed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpeed, SOAP_TYPE_tt__PTZSpeed, sizeof(struct tt__PTZSpeed), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZSpacesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpacesExtension, sizeof(struct tt__PTZSpacesExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZSpacesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpacesExtension, SOAP_TYPE_tt__PTZSpacesExtension, sizeof(struct tt__PTZSpacesExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Space1DDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space1DDescription, sizeof(struct tt__Space1DDescription), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->URI || !a->XRange))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Space1DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space1DDescription, SOAP_TYPE_tt__Space1DDescription, sizeof(struct tt__Space1DDescription), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ZoomLimits *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ZoomLimits, sizeof(struct tt__ZoomLimits), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Range))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ZoomLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ZoomLimits, SOAP_TYPE_tt__ZoomLimits, sizeof(struct tt__ZoomLimits), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Space2DDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space2DDescription, sizeof(struct tt__Space2DDescription), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_YRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->URI || !a->XRange || !a->YRange))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Space2DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space2DDescription, SOAP_TYPE_tt__Space2DDescription, sizeof(struct tt__Space2DDescription), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PanTiltLimits *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PanTiltLimits, sizeof(struct tt__PanTiltLimits), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Range))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PanTiltLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PanTiltLimits, SOAP_TYPE_tt__PanTiltLimits, sizeof(struct tt__PanTiltLimits), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ReverseOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReverseOptionsExtension, sizeof(struct tt__ReverseOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ReverseOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReverseOptionsExtension, SOAP_TYPE_tt__ReverseOptionsExtension, sizeof(struct tt__ReverseOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__EFlipOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlipOptionsExtension, sizeof(struct tt__EFlipOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__EFlipOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlipOptionsExtension, SOAP_TYPE_tt__EFlipOptionsExtension, sizeof(struct tt__EFlipOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTControlDirectionOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, sizeof(struct tt__PTControlDirectionOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTControlDirectionOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, sizeof(struct tt__PTControlDirectionOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ReverseOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReverseOptions, sizeof(struct tt__ReverseOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ReverseOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReverseOptions, SOAP_TYPE_tt__ReverseOptions, sizeof(struct tt__ReverseOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__EFlipOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlipOptions, sizeof(struct tt__EFlipOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__EFlipOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlipOptions, SOAP_TYPE_tt__EFlipOptions, sizeof(struct tt__EFlipOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZConfigurationOptions2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationOptions2, sizeof(struct tt__PTZConfigurationOptions2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZConfigurationOptions2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationOptions2, SOAP_TYPE_tt__PTZConfigurationOptions2, sizeof(struct tt__PTZConfigurationOptions2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTControlDirectionOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirectionOptions, sizeof(struct tt__PTControlDirectionOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_EFlip && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Reverse && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTControlDirectionOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirectionOptions, SOAP_TYPE_tt__PTControlDirectionOptions, sizeof(struct tt__PTControlDirectionOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZSpaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpaces, sizeof(struct tt__PTZSpaces), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AbsolutePanTiltPositionSpace", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AbsoluteZoomPositionSpace", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RelativePanTiltTranslationSpace", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RelativeZoomTranslationSpace", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ContinuousPanTiltVelocitySpace", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ContinuousZoomVelocitySpace", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PanTiltSpeedSpace", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ZoomSpeedSpace", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZSpaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpaces, SOAP_TYPE_tt__PTZSpaces, sizeof(struct tt__PTZSpaces), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationOptions, sizeof(struct tt__PTZConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Spaces && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_PTZTimeout && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_PTControlDirection && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Spaces || !a->PTZTimeout))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PTZConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationOptions, SOAP_TYPE_tt__PTZConfigurationOptions, sizeof(struct tt__PTZConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTControlDirectionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(struct tt__PTControlDirectionExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTControlDirectionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirectionExtension, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(struct tt__PTControlDirectionExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__Reverse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Reverse, sizeof(struct tt__Reverse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Reverse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Reverse, SOAP_TYPE_tt__Reverse, sizeof(struct tt__Reverse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__EFlip *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlip, sizeof(struct tt__EFlip), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__EFlip *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlip, SOAP_TYPE_tt__EFlip, sizeof(struct tt__EFlip), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZConfigurationExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(struct tt__PTZConfigurationExtension2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationExtension2, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(struct tt__PTZConfigurationExtension2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTControlDirection *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirection, sizeof(struct tt__PTControlDirection), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_EFlip && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Reverse && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTControlDirection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirection, SOAP_TYPE_tt__PTControlDirection, sizeof(struct tt__PTControlDirection), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(struct tt__PTZConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PTControlDirection && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationExtension, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(struct tt__PTZConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZPresetTourSupportedExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, sizeof(struct tt__PTZPresetTourSupportedExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZPresetTourSupportedExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, sizeof(struct tt__PTZPresetTourSupportedExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZNodeExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNodeExtension2, sizeof(struct tt__PTZNodeExtension2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZNodeExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNodeExtension2, SOAP_TYPE_tt__PTZNodeExtension2, sizeof(struct tt__PTZNodeExtension2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZPresetTourSupported *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSupported, sizeof(struct tt__PTZPresetTourSupported), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_MaximumNumberOfPresetTours && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PTZPresetTourOperation", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaximumNumberOfPresetTours > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PTZPresetTourSupported *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSupported, SOAP_TYPE_tt__PTZPresetTourSupported, sizeof(struct tt__PTZPresetTourSupported), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZNodeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNodeExtension, sizeof(struct tt__PTZNodeExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SupportedPresetTour && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZNodeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNodeExtension, SOAP_TYPE_tt__PTZNodeExtension, sizeof(struct tt__PTZNodeExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__GenericEapPwdConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension, sizeof(struct tt__GenericEapPwdConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__GenericEapPwdConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension, sizeof(struct tt__GenericEapPwdConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__EapMethodExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EapMethodExtension, sizeof(struct tt__EapMethodExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__EapMethodExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EapMethodExtension, SOAP_TYPE_tt__EapMethodExtension, sizeof(struct tt__EapMethodExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__TLSConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TLSConfiguration, sizeof(struct tt__TLSConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__TLSConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TLSConfiguration, SOAP_TYPE_tt__TLSConfiguration, sizeof(struct tt__TLSConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__Dot1XConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot1XConfigurationExtension, sizeof(struct tt__Dot1XConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__Dot1XConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot1XConfigurationExtension, SOAP_TYPE_tt__Dot1XConfigurationExtension, sizeof(struct tt__Dot1XConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__EAPMethodConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(struct tt__EAPMethodConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_TLSConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__EAPMethodConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EAPMethodConfiguration, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(struct tt__EAPMethodConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__CertificateInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateInformationExtension, sizeof(struct tt__CertificateInformationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__CertificateInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateInformationExtension, SOAP_TYPE_tt__CertificateInformationExtension, sizeof(struct tt__CertificateInformationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__DateTimeRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DateTimeRange, sizeof(struct tt__DateTimeRange), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_From && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Until && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_From > 0 || soap_flag_Until > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__DateTimeRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DateTimeRange, SOAP_TYPE_tt__DateTimeRange, sizeof(struct tt__DateTimeRange), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct tt__CertificateUsage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateUsage, sizeof(struct tt__CertificateUsage), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__CertificateGenerationParametersExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateGenerationParametersExtension, sizeof(struct tt__CertificateGenerationParametersExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__CertificateGenerationParametersExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateGenerationParametersExtension, SOAP_TYPE_tt__CertificateGenerationParametersExtension, sizeof(struct tt__CertificateGenerationParametersExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__CertificateGenerationParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateGenerationParameters, sizeof(struct tt__CertificateGenerationParameters), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Subject && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ValidNotBefore && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ValidNotAfter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__CertificateGenerationParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateGenerationParameters, SOAP_TYPE_tt__CertificateGenerationParameters, sizeof(struct tt__CertificateGenerationParameters), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__UserExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__UserExtension, sizeof(struct tt__UserExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__UserExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__UserExtension, SOAP_TYPE_tt__UserExtension, sizeof(struct tt__UserExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__LocalOrientation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LocalOrientation, sizeof(struct tt__LocalOrientation), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__LocalOrientation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LocalOrientation, SOAP_TYPE_tt__LocalOrientation, sizeof(struct tt__LocalOrientation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__LocalLocation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LocalLocation, sizeof(struct tt__LocalLocation), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__LocalLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LocalLocation, SOAP_TYPE_tt__LocalLocation, sizeof(struct tt__LocalLocation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__GeoOrientation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GeoOrientation, sizeof(struct tt__GeoOrientation), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__GeoOrientation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GeoOrientation, SOAP_TYPE_tt__GeoOrientation, sizeof(struct tt__GeoOrientation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__GeoLocation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GeoLocation, sizeof(struct tt__GeoLocation), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__GeoLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GeoLocation, SOAP_TYPE_tt__GeoLocation, sizeof(struct tt__GeoLocation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Date *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Date, sizeof(struct tt__Date), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Year && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Month && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Day && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Year > 0 || soap_flag_Month > 0 || soap_flag_Day > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Date *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Date, SOAP_TYPE_tt__Date, sizeof(struct tt__Date), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Time *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Time, sizeof(struct tt__Time), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Hour && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Minute && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Second && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Hour > 0 || soap_flag_Minute > 0 || soap_flag_Second > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Time *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Time, SOAP_TYPE_tt__Time, sizeof(struct tt__Time), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__SystemDateTimeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(struct tt__SystemDateTimeExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__SystemDateTimeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemDateTimeExtension, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(struct tt__SystemDateTimeExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__SystemLogUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogUri, sizeof(struct tt__SystemLogUri), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0 || !a->Uri))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__SystemLogUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogUri, SOAP_TYPE_tt__SystemLogUri, sizeof(struct tt__SystemLogUri), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AnalyticsDeviceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceExtension, sizeof(struct tt__AnalyticsDeviceExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__AnalyticsDeviceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceExtension, SOAP_TYPE_tt__AnalyticsDeviceExtension, sizeof(struct tt__AnalyticsDeviceExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__SystemCapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(struct tt__SystemCapabilitiesExtension2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__SystemCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilitiesExtension2, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(struct tt__SystemCapabilitiesExtension2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__SystemCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(struct tt__SystemCapabilitiesExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_HttpFirmwareUpgrade && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_HttpSystemBackup && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_HttpSystemLogging && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_HttpSupportInformation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__SystemCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilitiesExtension, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(struct tt__SystemCapabilitiesExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__SecurityCapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(struct tt__SecurityCapabilitiesExtension2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Dot1X && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SupportedEAPMethod", 1, NULL))
./soapC.c:			if (soap_flag_RemoteUserHandling && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1X > 0 || soap_flag_RemoteUserHandling > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__SecurityCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(struct tt__SecurityCapabilitiesExtension2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__SecurityCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(struct tt__SecurityCapabilitiesExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_TLS1_x002e0 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TLS1_x002e0 > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__SecurityCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilitiesExtension, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(struct tt__SecurityCapabilitiesExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__NetworkCapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(struct tt__NetworkCapabilitiesExtension2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__NetworkCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(struct tt__NetworkCapabilitiesExtension2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__NetworkCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(struct tt__NetworkCapabilitiesExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Dot11Configuration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__NetworkCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilitiesExtension, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(struct tt__NetworkCapabilitiesExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RealTimeStreamingCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(struct tt__RealTimeStreamingCapabilitiesExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__RealTimeStreamingCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(struct tt__RealTimeStreamingCapabilitiesExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ProfileCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileCapabilities, sizeof(struct tt__ProfileCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_MaximumNumberOfProfiles && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaximumNumberOfProfiles > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ProfileCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileCapabilities, SOAP_TYPE_tt__ProfileCapabilities, sizeof(struct tt__ProfileCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__MediaCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(struct tt__MediaCapabilitiesExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ProfileCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileCapabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__MediaCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilitiesExtension, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(struct tt__MediaCapabilitiesExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__RealTimeStreamingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(struct tt__RealTimeStreamingCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RTPMulticast && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RTP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RTP_USCORERTSP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__RealTimeStreamingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RealTimeStreamingCapabilities, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(struct tt__RealTimeStreamingCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__IOCapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilitiesExtension2, sizeof(struct tt__IOCapabilitiesExtension2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__IOCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilitiesExtension2, SOAP_TYPE_tt__IOCapabilitiesExtension2, sizeof(struct tt__IOCapabilitiesExtension2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__IOCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(struct tt__IOCapabilitiesExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Auxiliary && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AuxiliaryCommands", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Extension))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__IOCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilitiesExtension, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(struct tt__IOCapabilitiesExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__DeviceCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(struct tt__DeviceCapabilitiesExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__DeviceCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceCapabilitiesExtension, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(struct tt__DeviceCapabilitiesExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__SecurityCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilities, sizeof(struct tt__SecurityCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_TLS1_x002e1 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_TLS1_x002e2 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_OnboardKeyGeneration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AccessPolicyConfig && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_X_x002e509Token && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SAMLToken && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_KerberosToken && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RELToken && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TLS1_x002e1 > 0 || soap_flag_TLS1_x002e2 > 0 || soap_flag_OnboardKeyGeneration > 0 || soap_flag_AccessPolicyConfig > 0 || soap_flag_X_x002e509Token > 0 || soap_flag_SAMLToken > 0 || soap_flag_KerberosToken > 0 || soap_flag_RELToken > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__SecurityCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilities, SOAP_TYPE_tt__SecurityCapabilities, sizeof(struct tt__SecurityCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__IOCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilities, sizeof(struct tt__IOCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_InputConnectors && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RelayOutputs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__IOCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilities, SOAP_TYPE_tt__IOCapabilities, sizeof(struct tt__IOCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__SystemCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilities, sizeof(struct tt__SystemCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_DiscoveryResolve && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DiscoveryBye && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RemoteDiscovery && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SystemBackup && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SystemLogging && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_FirmwareUpgrade && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SupportedVersions", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryResolve > 0 || soap_flag_DiscoveryBye > 0 || soap_flag_RemoteDiscovery > 0 || soap_flag_SystemBackup > 0 || soap_flag_SystemLogging > 0 || soap_flag_FirmwareUpgrade > 0 || a->__sizeSupportedVersions < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__SystemCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilities, SOAP_TYPE_tt__SystemCapabilities, sizeof(struct tt__SystemCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__NetworkCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilities, sizeof(struct tt__NetworkCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_IPFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_IPVersion6 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DynDNS && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__NetworkCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilities, SOAP_TYPE_tt__NetworkCapabilities, sizeof(struct tt__NetworkCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__CapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilitiesExtension2, sizeof(struct tt__CapabilitiesExtension2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__CapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilitiesExtension2, SOAP_TYPE_tt__CapabilitiesExtension2, sizeof(struct tt__CapabilitiesExtension2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__AnalyticsDeviceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, sizeof(struct tt__AnalyticsDeviceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_RuleSupport && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->XAddr))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AnalyticsDeviceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, sizeof(struct tt__AnalyticsDeviceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ReceiverCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(struct tt__ReceiverCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_RTP_USCOREMulticast && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RTP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RTP_USCORERTSP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SupportedReceivers && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaximumRTSPURILength && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->XAddr || soap_flag_RTP_USCOREMulticast > 0 || soap_flag_RTP_USCORETCP > 0 || soap_flag_RTP_USCORERTSP_USCORETCP > 0 || soap_flag_SupportedReceivers > 0 || soap_flag_MaximumRTSPURILength > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ReceiverCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverCapabilities, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(struct tt__ReceiverCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ReplayCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReplayCapabilities, sizeof(struct tt__ReplayCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->XAddr))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ReplayCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReplayCapabilities, SOAP_TYPE_tt__ReplayCapabilities, sizeof(struct tt__ReplayCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__SearchCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchCapabilities, sizeof(struct tt__SearchCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_MetadataSearch && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->XAddr || soap_flag_MetadataSearch > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__SearchCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchCapabilities, SOAP_TYPE_tt__SearchCapabilities, sizeof(struct tt__SearchCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RecordingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingCapabilities, sizeof(struct tt__RecordingCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ReceiverSource && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MediaProfileSource && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DynamicRecordings && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DynamicTracks && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MaxStringLength && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->XAddr || soap_flag_ReceiverSource > 0 || soap_flag_MediaProfileSource > 0 || soap_flag_DynamicRecordings > 0 || soap_flag_DynamicTracks > 0 || soap_flag_MaxStringLength > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__RecordingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingCapabilities, SOAP_TYPE_tt__RecordingCapabilities, sizeof(struct tt__RecordingCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__DisplayCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DisplayCapabilities, sizeof(struct tt__DisplayCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_FixedLayout && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->XAddr || soap_flag_FixedLayout > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__DisplayCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DisplayCapabilities, SOAP_TYPE_tt__DisplayCapabilities, sizeof(struct tt__DisplayCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__DeviceIOCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(struct tt__DeviceIOCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_VideoSources && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_VideoOutputs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AudioSources && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AudioOutputs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RelayOutputs && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->XAddr || soap_flag_VideoSources > 0 || soap_flag_VideoOutputs > 0 || soap_flag_AudioSources > 0 || soap_flag_AudioOutputs > 0 || soap_flag_RelayOutputs > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__DeviceIOCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceIOCapabilities, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(struct tt__DeviceIOCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	//	return soap->error;
./soapC.c:	a = (struct tt__CapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(struct tt__CapabilitiesExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_DeviceIO && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Display && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Recording && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Search && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Replay && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Receiver && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AnalyticsDevice && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extensions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__CapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilitiesExtension, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(struct tt__CapabilitiesExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZCapabilities, sizeof(struct tt__PTZCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->XAddr))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PTZCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZCapabilities, SOAP_TYPE_tt__PTZCapabilities, sizeof(struct tt__PTZCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__MediaCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilities, sizeof(struct tt__MediaCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_StreamingCapabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->XAddr || !a->StreamingCapabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__MediaCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilities, SOAP_TYPE_tt__MediaCapabilities, sizeof(struct tt__MediaCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ImagingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingCapabilities, sizeof(struct tt__ImagingCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->XAddr))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ImagingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingCapabilities, SOAP_TYPE_tt__ImagingCapabilities, sizeof(struct tt__ImagingCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__EventCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventCapabilities, sizeof(struct tt__EventCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_WSSubscriptionPolicySupport && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_WSPullPointSupport && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_WSPausableSubscriptionManagerInterfaceSupport && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->XAddr || soap_flag_WSSubscriptionPolicySupport > 0 || soap_flag_WSPullPointSupport > 0 || soap_flag_WSPausableSubscriptionManagerInterfaceSupport > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__EventCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventCapabilities, SOAP_TYPE_tt__EventCapabilities, sizeof(struct tt__EventCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__DeviceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(struct tt__DeviceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Network && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_System && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_IO && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Security && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->XAddr))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__DeviceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceCapabilities, SOAP_TYPE_tt__DeviceCapabilities, sizeof(struct tt__DeviceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AnalyticsCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(struct tt__AnalyticsCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_RuleSupport && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AnalyticsModuleSupport && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->XAddr || soap_flag_RuleSupport > 0 || soap_flag_AnalyticsModuleSupport > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AnalyticsCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsCapabilities, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(struct tt__AnalyticsCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__Dot11AvailableNetworksExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, sizeof(struct tt__Dot11AvailableNetworksExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__Dot11AvailableNetworksExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, sizeof(struct tt__Dot11AvailableNetworksExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__Dot11PSKSetExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSKSetExtension, sizeof(struct tt__Dot11PSKSetExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__Dot11PSKSetExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSKSetExtension, SOAP_TYPE_tt__Dot11PSKSetExtension, sizeof(struct tt__Dot11PSKSetExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__Dot11SecurityConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, sizeof(struct tt__Dot11SecurityConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__Dot11SecurityConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, sizeof(struct tt__Dot11SecurityConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Dot11PSKSet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSKSet, sizeof(struct tt__Dot11PSKSet), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Passphrase && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__Dot11PSKSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSKSet, SOAP_TYPE_tt__Dot11PSKSet, sizeof(struct tt__Dot11PSKSet), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Dot11SecurityConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(struct tt__Dot11SecurityConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Algorithm && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_PSK && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Dot1X && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Dot11SecurityConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityConfiguration, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(struct tt__Dot11SecurityConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__IPAddressFilterExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(struct tt__IPAddressFilterExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__IPAddressFilterExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilterExtension, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(struct tt__IPAddressFilterExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__NetworkZeroConfigurationExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, sizeof(struct tt__NetworkZeroConfigurationExtension2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__NetworkZeroConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, sizeof(struct tt__NetworkZeroConfigurationExtension2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__NetworkZeroConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(struct tt__NetworkZeroConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Additional", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__NetworkZeroConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(struct tt__NetworkZeroConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__NetworkInterfaceSetConfigurationExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__NetworkInterfaceSetConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__NetworkInterfaceSetConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Dot3", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Dot11", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__NetworkInterfaceSetConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__IPv6NetworkInterfaceSetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv6NetworkInterfaceSetConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AcceptRouterAdvert && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Manual", 1, NULL))
./soapC.c:			if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__IPv6NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv6NetworkInterfaceSetConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__IPv4NetworkInterfaceSetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv4NetworkInterfaceSetConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Manual", 1, NULL))
./soapC.c:			if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__IPv4NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv4NetworkInterfaceSetConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__DynamicDNSInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(struct tt__DynamicDNSInformationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__DynamicDNSInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSInformationExtension, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(struct tt__DynamicDNSInformationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__NTPInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NTPInformationExtension, sizeof(struct tt__NTPInformationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__NTPInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NTPInformationExtension, SOAP_TYPE_tt__NTPInformationExtension, sizeof(struct tt__NTPInformationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__DNSInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSInformationExtension, sizeof(struct tt__DNSInformationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__DNSInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DNSInformationExtension, SOAP_TYPE_tt__DNSInformationExtension, sizeof(struct tt__DNSInformationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__HostnameInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(struct tt__HostnameInformationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__HostnameInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__HostnameInformationExtension, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(struct tt__HostnameInformationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__NetworkHostExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHostExtension, sizeof(struct tt__NetworkHostExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__NetworkHostExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHostExtension, SOAP_TYPE_tt__NetworkHostExtension, sizeof(struct tt__NetworkHostExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__NetworkProtocolExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(struct tt__NetworkProtocolExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__NetworkProtocolExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocolExtension, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(struct tt__NetworkProtocolExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__IPv6ConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(struct tt__IPv6ConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__IPv6ConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6ConfigurationExtension, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(struct tt__IPv6ConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PrefixedIPv6Address *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(struct tt__PrefixedIPv6Address), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PrefixLength && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address || soap_flag_PrefixLength > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PrefixedIPv6Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PrefixedIPv6Address, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(struct tt__PrefixedIPv6Address), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PrefixedIPv4Address *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(struct tt__PrefixedIPv4Address), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PrefixLength && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address || soap_flag_PrefixLength > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PrefixedIPv4Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PrefixedIPv4Address, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(struct tt__PrefixedIPv4Address), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__IPv4Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4Configuration, sizeof(struct tt__IPv4Configuration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Manual", 1, NULL))
./soapC.c:			if (soap_flag_LinkLocal && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DHCP > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__IPv4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4Configuration, SOAP_TYPE_tt__IPv4Configuration, sizeof(struct tt__IPv4Configuration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__IPv4NetworkInterface *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(struct tt__IPv4NetworkInterface), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Config && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0 || !a->Config))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__IPv4NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4NetworkInterface, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(struct tt__IPv4NetworkInterface), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__IPv6Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6Configuration, sizeof(struct tt__IPv6Configuration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AcceptRouterAdvert && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Manual", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:LinkLocal", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:FromDHCP", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:FromRA", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DHCP > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__IPv6Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6Configuration, SOAP_TYPE_tt__IPv6Configuration, sizeof(struct tt__IPv6Configuration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__IPv6NetworkInterface *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(struct tt__IPv6NetworkInterface), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Config && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__IPv6NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6NetworkInterface, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(struct tt__IPv6NetworkInterface), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__NetworkInterfaceInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(struct tt__NetworkInterfaceInfo), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_HwAddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_MTU && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->HwAddress))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__NetworkInterfaceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceInfo, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(struct tt__NetworkInterfaceInfo), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__NetworkInterfaceConnectionSetting *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(struct tt__NetworkInterfaceConnectionSetting), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AutoNegotiation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Duplex && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoNegotiation > 0 || soap_flag_Speed > 0 || soap_flag_Duplex > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__NetworkInterfaceConnectionSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(struct tt__NetworkInterfaceConnectionSetting), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__NetworkInterfaceLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(struct tt__NetworkInterfaceLink), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AdminSettings && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_OperSettings && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_InterfaceType && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->AdminSettings || !a->OperSettings || soap_flag_InterfaceType > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__NetworkInterfaceLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceLink, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(struct tt__NetworkInterfaceLink), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__NetworkInterfaceExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceExtension2, sizeof(struct tt__NetworkInterfaceExtension2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__NetworkInterfaceExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceExtension2, SOAP_TYPE_tt__NetworkInterfaceExtension2, sizeof(struct tt__NetworkInterfaceExtension2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__Dot11Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Configuration, sizeof(struct tt__Dot11Configuration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SSID && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Priority && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Security && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID > 0 || soap_flag_Mode > 0 || !a->Alias || !a->Priority || !a->Security))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Dot11Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Configuration, SOAP_TYPE_tt__Dot11Configuration, sizeof(struct tt__Dot11Configuration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__Dot3Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot3Configuration, sizeof(struct tt__Dot3Configuration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__Dot3Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot3Configuration, SOAP_TYPE_tt__Dot3Configuration, sizeof(struct tt__Dot3Configuration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__NetworkInterfaceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(struct tt__NetworkInterfaceExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_InterfaceType && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Dot3", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Dot11", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceType > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__NetworkInterfaceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceExtension, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(struct tt__NetworkInterfaceExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__MediaUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaUri, sizeof(struct tt__MediaUri), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_InvalidAfterConnect && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_InvalidAfterReboot && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Timeout && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Uri || soap_flag_InvalidAfterConnect > 0 || soap_flag_InvalidAfterReboot > 0 || soap_flag_Timeout > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__MediaUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaUri, SOAP_TYPE_tt__MediaUri, sizeof(struct tt__MediaUri), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Transport *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Transport, sizeof(struct tt__Transport), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Protocol && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Tunnel && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Protocol > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Transport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Transport, SOAP_TYPE_tt__Transport, sizeof(struct tt__Transport), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__StreamSetup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StreamSetup, sizeof(struct tt__StreamSetup), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Stream && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Transport && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Stream > 0 || !a->Transport))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__StreamSetup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StreamSetup, SOAP_TYPE_tt__StreamSetup, sizeof(struct tt__StreamSetup), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__MulticastConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(struct tt__MulticastConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Address && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Port && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_TTL && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AutoStart && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address || soap_flag_Port > 0 || soap_flag_TTL > 0 || soap_flag_AutoStart > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__MulticastConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MulticastConfiguration, SOAP_TYPE_tt__MulticastConfiguration, sizeof(struct tt__MulticastConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AudioDecoderConfigurationOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, sizeof(struct tt__AudioDecoderConfigurationOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__AudioDecoderConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, sizeof(struct tt__AudioDecoderConfigurationOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__G726DecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__G726DecOptions, sizeof(struct tt__G726DecOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SampleRateRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Bitrate || !a->SampleRateRange))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__G726DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__G726DecOptions, SOAP_TYPE_tt__G726DecOptions, sizeof(struct tt__G726DecOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__G711DecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__G711DecOptions, sizeof(struct tt__G711DecOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SampleRateRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Bitrate || !a->SampleRateRange))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__G711DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__G711DecOptions, SOAP_TYPE_tt__G711DecOptions, sizeof(struct tt__G711DecOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AACDecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AACDecOptions, sizeof(struct tt__AACDecOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SampleRateRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Bitrate || !a->SampleRateRange))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AACDecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AACDecOptions, SOAP_TYPE_tt__AACDecOptions, sizeof(struct tt__AACDecOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__AudioDecoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, sizeof(struct tt__AudioDecoderConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AACDecOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_G711DecOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_G726DecOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__AudioDecoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, sizeof(struct tt__AudioDecoderConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AudioOutputConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(struct tt__AudioOutputConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:OutputTokensAvailable", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SendPrimacyOptions", 1, NULL))
./soapC.c:			if (soap_flag_OutputLevelRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeOutputTokensAvailable < 1 || !a->OutputLevelRange))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AudioOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutputConfigurationOptions, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(struct tt__AudioOutputConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__VideoDecoderConfigurationOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension, sizeof(struct tt__VideoDecoderConfigurationOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__VideoDecoderConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension, sizeof(struct tt__VideoDecoderConfigurationOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__Mpeg4DecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4DecOptions, sizeof(struct tt__Mpeg4DecOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SupportedMpeg4Profiles", 1, NULL))
./soapC.c:			if (soap_flag_SupportedInputBitrate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SupportedFrameRate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || a->__sizeSupportedMpeg4Profiles < 1 || !a->SupportedInputBitrate || !a->SupportedFrameRate))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Mpeg4DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4DecOptions, SOAP_TYPE_tt__Mpeg4DecOptions, sizeof(struct tt__Mpeg4DecOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__H264DecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264DecOptions, sizeof(struct tt__H264DecOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SupportedH264Profiles", 1, NULL))
./soapC.c:			if (soap_flag_SupportedInputBitrate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SupportedFrameRate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || a->__sizeSupportedH264Profiles < 1 || !a->SupportedInputBitrate || !a->SupportedFrameRate))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__H264DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264DecOptions, SOAP_TYPE_tt__H264DecOptions, sizeof(struct tt__H264DecOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__JpegDecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegDecOptions, sizeof(struct tt__JpegDecOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
./soapC.c:			if (soap_flag_SupportedInputBitrate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SupportedFrameRate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || !a->SupportedInputBitrate || !a->SupportedFrameRate))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__JpegDecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegDecOptions, SOAP_TYPE_tt__JpegDecOptions, sizeof(struct tt__JpegDecOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__VideoDecoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, sizeof(struct tt__VideoDecoderConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_JpegDecOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_H264DecOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Mpeg4DecOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__VideoDecoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, sizeof(struct tt__VideoDecoderConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__VideoOutputConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutputConfigurationOptions, sizeof(struct tt__VideoOutputConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__VideoOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutputConfigurationOptions, SOAP_TYPE_tt__VideoOutputConfigurationOptions, sizeof(struct tt__VideoOutputConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__VideoOutputExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutputExtension, sizeof(struct tt__VideoOutputExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__VideoOutputExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutputExtension, SOAP_TYPE_tt__VideoOutputExtension, sizeof(struct tt__VideoOutputExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__PTZStatusFilterOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, sizeof(struct tt__PTZStatusFilterOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__PTZStatusFilterOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, sizeof(struct tt__PTZStatusFilterOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__MetadataConfigurationOptionsExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, sizeof(struct tt__MetadataConfigurationOptionsExtension2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__MetadataConfigurationOptionsExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, sizeof(struct tt__MetadataConfigurationOptionsExtension2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__MetadataConfigurationOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, sizeof(struct tt__MetadataConfigurationOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:CompressionType", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__MetadataConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, sizeof(struct tt__MetadataConfigurationOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZStatusFilterOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatusFilterOptions, sizeof(struct tt__PTZStatusFilterOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PanTiltStatusSupported && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ZoomStatusSupported && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_PanTiltPositionSupported && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ZoomPositionSupported && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PanTiltStatusSupported > 0 || soap_flag_ZoomStatusSupported > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PTZStatusFilterOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStatusFilterOptions, SOAP_TYPE_tt__PTZStatusFilterOptions, sizeof(struct tt__PTZStatusFilterOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__MetadataConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationOptions, sizeof(struct tt__MetadataConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PTZStatusFilterOptions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PTZStatusFilterOptions))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__MetadataConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationOptions, SOAP_TYPE_tt__MetadataConfigurationOptions, sizeof(struct tt__MetadataConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tt__EventSubscription_SubscriptionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, sizeof(struct _tt__EventSubscription_SubscriptionPolicy), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tt__EventSubscription_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, sizeof(struct _tt__EventSubscription_SubscriptionPolicy), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct wsnt__FilterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__FilterType, sizeof(struct wsnt__FilterType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsnt__FilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__FilterType, SOAP_TYPE_wsnt__FilterType, sizeof(struct wsnt__FilterType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__EventSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventSubscription, sizeof(struct tt__EventSubscription), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__EventSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventSubscription, SOAP_TYPE_tt__EventSubscription, sizeof(struct tt__EventSubscription), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZFilter, sizeof(struct tt__PTZFilter), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status > 0 || soap_flag_Position > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PTZFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZFilter, SOAP_TYPE_tt__PTZFilter, sizeof(struct tt__PTZFilter), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__MetadataConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(struct tt__MetadataConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__MetadataConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationExtension, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(struct tt__MetadataConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AudioEncoder2ConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions, sizeof(struct tt__AudioEncoder2ConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Encoding && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_BitrateList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SampleRateList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Encoding || !a->BitrateList || !a->SampleRateList))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AudioEncoder2ConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions, SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions, sizeof(struct tt__AudioEncoder2ConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AudioEncoderConfigurationOption *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOption, sizeof(struct tt__AudioEncoderConfigurationOption), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_BitrateList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SampleRateList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Encoding > 0 || !a->BitrateList || !a->SampleRateList))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AudioEncoderConfigurationOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfigurationOption, SOAP_TYPE_tt__AudioEncoderConfigurationOption, sizeof(struct tt__AudioEncoderConfigurationOption), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AudioEncoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, sizeof(struct tt__AudioEncoderConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Options", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__AudioEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, sizeof(struct tt__AudioEncoderConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AudioSourceOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceOptionsExtension, sizeof(struct tt__AudioSourceOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__AudioSourceOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceOptionsExtension, SOAP_TYPE_tt__AudioSourceOptionsExtension, sizeof(struct tt__AudioSourceOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__AudioSourceConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(struct tt__AudioSourceConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:InputTokensAvailable", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeInputTokensAvailable < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AudioSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfigurationOptions, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(struct tt__AudioSourceConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__VideoEncoder2ConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions, sizeof(struct tt__VideoEncoder2ConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Encoding && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_QualityRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
./soapC.c:			if (soap_flag_BitrateRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Encoding || !a->QualityRange || a->__sizeResolutionsAvailable < 1 || !a->BitrateRange))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__VideoEncoder2ConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions, SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions, sizeof(struct tt__VideoEncoder2ConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__VideoRateControl2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoRateControl2, sizeof(struct tt__VideoRateControl2), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_FrameRateLimit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_BitrateLimit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FrameRateLimit > 0 || soap_flag_BitrateLimit > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__VideoRateControl2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoRateControl2, SOAP_TYPE_tt__VideoRateControl2, sizeof(struct tt__VideoRateControl2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__VideoResolution2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoResolution2, sizeof(struct tt__VideoResolution2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Width && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Height && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width > 0 || soap_flag_Height > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__VideoResolution2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoResolution2, SOAP_TYPE_tt__VideoResolution2, sizeof(struct tt__VideoResolution2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__VideoEncoderOptionsExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(struct tt__VideoEncoderOptionsExtension2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__VideoEncoderOptionsExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(struct tt__VideoEncoderOptionsExtension2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__H264Options2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Options2, sizeof(struct tt__H264Options2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
./soapC.c:			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:H264ProfilesSupported", 1, NULL))
./soapC.c:			if (soap_flag_BitrateRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || !a->GovLengthRange || !a->FrameRateRange || !a->EncodingIntervalRange || a->__sizeH264ProfilesSupported < 1 || !a->BitrateRange))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__H264Options2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Options2, SOAP_TYPE_tt__H264Options2, sizeof(struct tt__H264Options2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__Mpeg4Options2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Options2, sizeof(struct tt__Mpeg4Options2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
./soapC.c:			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mpeg4ProfilesSupported", 1, NULL))
./soapC.c:			if (soap_flag_BitrateRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || !a->GovLengthRange || !a->FrameRateRange || !a->EncodingIntervalRange || a->__sizeMpeg4ProfilesSupported < 1 || !a->BitrateRange))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Mpeg4Options2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Options2, SOAP_TYPE_tt__Mpeg4Options2, sizeof(struct tt__Mpeg4Options2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__JpegOptions2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegOptions2, sizeof(struct tt__JpegOptions2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
./soapC.c:			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_BitrateRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || !a->FrameRateRange || !a->EncodingIntervalRange || !a->BitrateRange))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__JpegOptions2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegOptions2, SOAP_TYPE_tt__JpegOptions2, sizeof(struct tt__JpegOptions2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__VideoEncoderOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(struct tt__VideoEncoderOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_JPEG && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__VideoEncoderOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderOptionsExtension, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(struct tt__VideoEncoderOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__H264Options *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Options, sizeof(struct tt__H264Options), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
./soapC.c:			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:H264ProfilesSupported", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || !a->GovLengthRange || !a->FrameRateRange || !a->EncodingIntervalRange || a->__sizeH264ProfilesSupported < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__H264Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Options, SOAP_TYPE_tt__H264Options, sizeof(struct tt__H264Options), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__Mpeg4Options *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Options, sizeof(struct tt__Mpeg4Options), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
./soapC.c:			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mpeg4ProfilesSupported", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || !a->GovLengthRange || !a->FrameRateRange || !a->EncodingIntervalRange || a->__sizeMpeg4ProfilesSupported < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Mpeg4Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Options, SOAP_TYPE_tt__Mpeg4Options, sizeof(struct tt__Mpeg4Options), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__JpegOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegOptions, sizeof(struct tt__JpegOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
./soapC.c:			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || !a->FrameRateRange || !a->EncodingIntervalRange))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__JpegOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegOptions, SOAP_TYPE_tt__JpegOptions, sizeof(struct tt__JpegOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__VideoEncoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(struct tt__VideoEncoderConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_QualityRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_JPEG && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->QualityRange))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__VideoEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(struct tt__VideoEncoderConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__H264Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Configuration, sizeof(struct tt__H264Configuration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_GovLength && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_H264Profile && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength > 0 || soap_flag_H264Profile > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__H264Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Configuration, SOAP_TYPE_tt__H264Configuration, sizeof(struct tt__H264Configuration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Mpeg4Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(struct tt__Mpeg4Configuration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_GovLength && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Mpeg4Profile && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength > 0 || soap_flag_Mpeg4Profile > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Mpeg4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Configuration, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(struct tt__Mpeg4Configuration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__VideoRateControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoRateControl, sizeof(struct tt__VideoRateControl), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_FrameRateLimit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_EncodingInterval && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_BitrateLimit && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FrameRateLimit > 0 || soap_flag_EncodingInterval > 0 || soap_flag_BitrateLimit > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__VideoRateControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoRateControl, SOAP_TYPE_tt__VideoRateControl, sizeof(struct tt__VideoRateControl), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__VideoResolution *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoResolution, sizeof(struct tt__VideoResolution), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Width && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Height && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width > 0 || soap_flag_Height > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__VideoResolution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoResolution, SOAP_TYPE_tt__VideoResolution, sizeof(struct tt__VideoResolution), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RotateOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateOptionsExtension, sizeof(struct tt__RotateOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__RotateOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateOptionsExtension, SOAP_TYPE_tt__RotateOptionsExtension, sizeof(struct tt__RotateOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__VideoSourceConfigurationOptionsExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, sizeof(struct tt__VideoSourceConfigurationOptionsExtension2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SceneOrientationMode", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__VideoSourceConfigurationOptionsExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, sizeof(struct tt__VideoSourceConfigurationOptionsExtension2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__RotateOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateOptions, sizeof(struct tt__RotateOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
./soapC.c:			if (soap_flag_DegreeList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__RotateOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateOptions, SOAP_TYPE_tt__RotateOptions, sizeof(struct tt__RotateOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__VideoSourceConfigurationOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, sizeof(struct tt__VideoSourceConfigurationOptionsExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Rotate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__VideoSourceConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, sizeof(struct tt__VideoSourceConfigurationOptionsExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__VideoSourceConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(struct tt__VideoSourceConfigurationOptions), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_BoundsRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:VideoSourceTokensAvailable", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->BoundsRange || a->__sizeVideoSourceTokensAvailable < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__VideoSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptions, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(struct tt__VideoSourceConfigurationOptions), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__LensOffset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LensOffset, sizeof(struct tt__LensOffset), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__LensOffset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LensOffset, SOAP_TYPE_tt__LensOffset, sizeof(struct tt__LensOffset), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__LensProjection *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LensProjection, sizeof(struct tt__LensProjection), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Angle && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Radius && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Transmittance && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Angle > 0 || soap_flag_Radius > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__LensProjection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LensProjection, SOAP_TYPE_tt__LensProjection, sizeof(struct tt__LensProjection), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RotateExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateExtension, sizeof(struct tt__RotateExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__RotateExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateExtension, SOAP_TYPE_tt__RotateExtension, sizeof(struct tt__RotateExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__SceneOrientation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SceneOrientation, sizeof(struct tt__SceneOrientation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Orientation && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__SceneOrientation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SceneOrientation, SOAP_TYPE_tt__SceneOrientation, sizeof(struct tt__SceneOrientation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__LensDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LensDescription, sizeof(struct tt__LensDescription), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Offset && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Projection", 1, NULL))
./soapC.c:			if (soap_flag_XFactor && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Offset || a->__sizeProjection < 1 || soap_flag_XFactor > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__LensDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LensDescription, SOAP_TYPE_tt__LensDescription, sizeof(struct tt__LensDescription), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__VideoSourceConfigurationExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, sizeof(struct tt__VideoSourceConfigurationExtension2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:LensDescription", 1, NULL))
./soapC.c:			if (soap_flag_SceneOrientation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__VideoSourceConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, sizeof(struct tt__VideoSourceConfigurationExtension2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Rotate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rotate, sizeof(struct tt__Rotate), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Degree && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Rotate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Rotate, SOAP_TYPE_tt__Rotate, sizeof(struct tt__Rotate), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__VideoSourceConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(struct tt__VideoSourceConfigurationExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Rotate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__VideoSourceConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationExtension, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(struct tt__VideoSourceConfigurationExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ConfigurationEntity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigurationEntity, sizeof(struct tt__ConfigurationEntity), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__ConfigurationEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigurationEntity, SOAP_TYPE_tt__ConfigurationEntity, sizeof(struct tt__ConfigurationEntity), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__ProfileExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileExtension2, sizeof(struct tt__ProfileExtension2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ProfileExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileExtension2, SOAP_TYPE_tt__ProfileExtension2, sizeof(struct tt__ProfileExtension2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AudioDecoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(struct tt__AudioDecoderConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDecoderConfiguration, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(struct tt__AudioDecoderConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AudioOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(struct tt__AudioOutputConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_OutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_SendPrimacy && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_OutputLevel && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->OutputToken || soap_flag_OutputLevel > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutputConfiguration, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(struct tt__AudioOutputConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ProfileExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileExtension, sizeof(struct tt__ProfileExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ProfileExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileExtension, SOAP_TYPE_tt__ProfileExtension, sizeof(struct tt__ProfileExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__MetadataConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfiguration, sizeof(struct tt__MetadataConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_PTZStatus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Events && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Analytics && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SessionTimeout && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AnalyticsEngineConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->Multicast || soap_flag_SessionTimeout > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__MetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfiguration, SOAP_TYPE_tt__MetadataConfiguration, sizeof(struct tt__MetadataConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__PTZConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfiguration, sizeof(struct tt__PTZConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_NodeToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_DefaultAbsolutePantTiltPositionSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_DefaultAbsoluteZoomPositionSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_DefaultRelativePanTiltTranslationSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_DefaultRelativeZoomTranslationSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_DefaultContinuousPanTiltVelocitySpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_DefaultContinuousZoomVelocitySpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_DefaultPTZSpeed && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DefaultPTZTimeout && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_PanTiltLimits && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ZoomLimits && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->NodeToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__PTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfiguration, SOAP_TYPE_tt__PTZConfiguration, sizeof(struct tt__PTZConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__VideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(struct tt__VideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AnalyticsEngineConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RuleEngineConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->AnalyticsEngineConfiguration || !a->RuleEngineConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__VideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAnalyticsConfiguration, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(struct tt__VideoAnalyticsConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AudioEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(struct tt__AudioEncoderConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SampleRate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SessionTimeout && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || soap_flag_Encoding > 0 || soap_flag_Bitrate > 0 || soap_flag_SampleRate > 0 || !a->Multicast || soap_flag_SessionTimeout > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfiguration, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(struct tt__AudioEncoderConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__VideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(struct tt__VideoEncoderConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Quality && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RateControl && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SessionTimeout && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || soap_flag_Encoding > 0 || !a->Resolution || soap_flag_Quality > 0 || !a->Multicast || soap_flag_SessionTimeout > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__VideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfiguration, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(struct tt__VideoEncoderConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AudioSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(struct tt__AudioSourceConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->SourceToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfiguration, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(struct tt__AudioSourceConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__VideoSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(struct tt__VideoSourceConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Bounds && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->SourceToken || !a->Bounds))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__VideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfiguration, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(struct tt__VideoSourceConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Profile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Profile, sizeof(struct tt__Profile), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_VideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_VideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_VideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_PTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Profile, SOAP_TYPE_tt__Profile, sizeof(struct tt__Profile), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__VideoSourceExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceExtension2, sizeof(struct tt__VideoSourceExtension2), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__VideoSourceExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceExtension2, SOAP_TYPE_tt__VideoSourceExtension2, sizeof(struct tt__VideoSourceExtension2), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__ImagingSettings20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettings20, sizeof(struct tt__ImagingSettings20), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_IrCutFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__ImagingSettings20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettings20, SOAP_TYPE_tt__ImagingSettings20, sizeof(struct tt__ImagingSettings20), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__VideoSourceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceExtension, sizeof(struct tt__VideoSourceExtension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Imaging && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__VideoSourceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceExtension, SOAP_TYPE_tt__VideoSourceExtension, sizeof(struct tt__VideoSourceExtension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__AnyHolder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnyHolder, sizeof(struct tt__AnyHolder), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__AnyHolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnyHolder, SOAP_TYPE_tt__AnyHolder, sizeof(struct tt__AnyHolder), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__FloatList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FloatList, sizeof(struct tt__FloatList), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Items", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__FloatList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FloatList, SOAP_TYPE_tt__FloatList, sizeof(struct tt__FloatList), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__IntList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntList, sizeof(struct tt__IntList), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Items", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__IntList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntList, SOAP_TYPE_tt__IntList, sizeof(struct tt__IntList), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__DurationRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DurationRange, sizeof(struct tt__DurationRange), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Min && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Max && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min > 0 || soap_flag_Max > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__DurationRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DurationRange, SOAP_TYPE_tt__DurationRange, sizeof(struct tt__DurationRange), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__FloatRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FloatRange, sizeof(struct tt__FloatRange), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Min && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Max && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min > 0 || soap_flag_Max > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__FloatRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FloatRange, SOAP_TYPE_tt__FloatRange, sizeof(struct tt__FloatRange), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__IntRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRange, sizeof(struct tt__IntRange), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Min && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Max && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min > 0 || soap_flag_Max > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__IntRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRange, SOAP_TYPE_tt__IntRange, sizeof(struct tt__IntRange), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__IntRectangleRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangleRange, sizeof(struct tt__IntRectangleRange), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_YRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_WidthRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_HeightRange && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->XRange || !a->YRange || !a->WidthRange || !a->HeightRange))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__IntRectangleRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRectangleRange, SOAP_TYPE_tt__IntRectangleRange, sizeof(struct tt__IntRectangleRange), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__IntRectangle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangle, sizeof(struct tt__IntRectangle), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__IntRectangle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRectangle, SOAP_TYPE_tt__IntRectangle, sizeof(struct tt__IntRectangle), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__DeviceEntity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceEntity, sizeof(struct tt__DeviceEntity), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__DeviceEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceEntity, SOAP_TYPE_tt__DeviceEntity, sizeof(struct tt__DeviceEntity), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__DeleteGeoLocationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteGeoLocationResponse, sizeof(struct _tds__DeleteGeoLocationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__DeleteGeoLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteGeoLocationResponse, SOAP_TYPE__tds__DeleteGeoLocationResponse, sizeof(struct _tds__DeleteGeoLocationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__DeleteGeoLocation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteGeoLocation, sizeof(struct _tds__DeleteGeoLocation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Location", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeLocation < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__DeleteGeoLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteGeoLocation, SOAP_TYPE__tds__DeleteGeoLocation, sizeof(struct _tds__DeleteGeoLocation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetGeoLocationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetGeoLocationResponse, sizeof(struct _tds__SetGeoLocationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetGeoLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetGeoLocationResponse, SOAP_TYPE__tds__SetGeoLocationResponse, sizeof(struct _tds__SetGeoLocationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__SetGeoLocation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetGeoLocation, sizeof(struct _tds__SetGeoLocation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Location", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeLocation < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetGeoLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetGeoLocation, SOAP_TYPE__tds__SetGeoLocation, sizeof(struct _tds__SetGeoLocation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__LocationEntity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LocationEntity, sizeof(struct tt__LocationEntity), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_GeoLocation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_GeoOrientation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_LocalLocation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_LocalOrientation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__LocationEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LocationEntity, SOAP_TYPE_tt__LocationEntity, sizeof(struct tt__LocationEntity), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetGeoLocationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetGeoLocationResponse, sizeof(struct _tds__GetGeoLocationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Location", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetGeoLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetGeoLocationResponse, SOAP_TYPE__tds__GetGeoLocationResponse, sizeof(struct _tds__GetGeoLocationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetGeoLocation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetGeoLocation, sizeof(struct _tds__GetGeoLocation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetGeoLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetGeoLocation, SOAP_TYPE__tds__GetGeoLocation, sizeof(struct _tds__GetGeoLocation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__DeleteStorageConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, sizeof(struct _tds__DeleteStorageConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__DeleteStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, sizeof(struct _tds__DeleteStorageConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__DeleteStorageConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteStorageConfiguration, sizeof(struct _tds__DeleteStorageConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__DeleteStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteStorageConfiguration, SOAP_TYPE__tds__DeleteStorageConfiguration, sizeof(struct _tds__DeleteStorageConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetStorageConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetStorageConfigurationResponse, sizeof(struct _tds__SetStorageConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetStorageConfigurationResponse, SOAP_TYPE__tds__SetStorageConfigurationResponse, sizeof(struct _tds__SetStorageConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetStorageConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetStorageConfiguration, sizeof(struct _tds__SetStorageConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_StorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->StorageConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetStorageConfiguration, SOAP_TYPE__tds__SetStorageConfiguration, sizeof(struct _tds__SetStorageConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetStorageConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfigurationResponse, sizeof(struct _tds__GetStorageConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_StorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->StorageConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfigurationResponse, SOAP_TYPE__tds__GetStorageConfigurationResponse, sizeof(struct _tds__GetStorageConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetStorageConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfiguration, sizeof(struct _tds__GetStorageConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfiguration, SOAP_TYPE__tds__GetStorageConfiguration, sizeof(struct _tds__GetStorageConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__CreateStorageConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateStorageConfigurationResponse, sizeof(struct _tds__CreateStorageConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__CreateStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateStorageConfigurationResponse, SOAP_TYPE__tds__CreateStorageConfigurationResponse, sizeof(struct _tds__CreateStorageConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__CreateStorageConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateStorageConfiguration, sizeof(struct _tds__CreateStorageConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_StorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->StorageConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__CreateStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateStorageConfiguration, SOAP_TYPE__tds__CreateStorageConfiguration, sizeof(struct _tds__CreateStorageConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tds__StorageConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__StorageConfiguration, sizeof(struct tds__StorageConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Data))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tds__StorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__StorageConfiguration, SOAP_TYPE_tds__StorageConfiguration, sizeof(struct tds__StorageConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetStorageConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfigurationsResponse, sizeof(struct _tds__GetStorageConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:StorageConfigurations", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetStorageConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfigurationsResponse, SOAP_TYPE__tds__GetStorageConfigurationsResponse, sizeof(struct _tds__GetStorageConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetStorageConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfigurations, sizeof(struct _tds__GetStorageConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetStorageConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfigurations, SOAP_TYPE__tds__GetStorageConfigurations, sizeof(struct _tds__GetStorageConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__StartSystemRestoreResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(struct _tds__StartSystemRestoreResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_UploadUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ExpectedDownTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->UploadUri || soap_flag_ExpectedDownTime > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__StartSystemRestoreResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestoreResponse, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(struct _tds__StartSystemRestoreResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__StartSystemRestore *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestore, sizeof(struct _tds__StartSystemRestore), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__StartSystemRestore *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestore, SOAP_TYPE__tds__StartSystemRestore, sizeof(struct _tds__StartSystemRestore), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__StartFirmwareUpgradeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(struct _tds__StartFirmwareUpgradeResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_UploadUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UploadDelay && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ExpectedDownTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->UploadUri || soap_flag_UploadDelay > 0 || soap_flag_ExpectedDownTime > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__StartFirmwareUpgradeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(struct _tds__StartFirmwareUpgradeResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__StartFirmwareUpgrade *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(struct _tds__StartFirmwareUpgrade), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__StartFirmwareUpgrade *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgrade, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(struct _tds__StartFirmwareUpgrade), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetSystemUrisResponse_Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, sizeof(struct _tds__GetSystemUrisResponse_Extension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetSystemUrisResponse_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, sizeof(struct _tds__GetSystemUrisResponse_Extension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__SystemLogUriList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogUriList, sizeof(struct tt__SystemLogUriList), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SystemLog", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__SystemLogUriList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogUriList, SOAP_TYPE_tt__SystemLogUriList, sizeof(struct tt__SystemLogUriList), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetSystemUrisResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(struct _tds__GetSystemUrisResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SystemLogUris && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SupportInfoUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_SystemBackupUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetSystemUrisResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUrisResponse, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(struct _tds__GetSystemUrisResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetSystemUris *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUris, sizeof(struct _tds__GetSystemUris), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetSystemUris *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUris, SOAP_TYPE__tds__GetSystemUris, sizeof(struct _tds__GetSystemUris), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Dot11AvailableNetworks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(struct tt__Dot11AvailableNetworks), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SSID && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_BSSID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AuthAndMangementSuite", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PairCipher", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:GroupCipher", 1, NULL))
./soapC.c:			if (soap_flag_SignalStrength && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Dot11AvailableNetworks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11AvailableNetworks, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(struct tt__Dot11AvailableNetworks), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__ScanAvailableDot11NetworksResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(struct _tds__ScanAvailableDot11NetworksResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Networks", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__ScanAvailableDot11NetworksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(struct _tds__ScanAvailableDot11NetworksResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__ScanAvailableDot11Networks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(struct _tds__ScanAvailableDot11Networks), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->InterfaceToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__ScanAvailableDot11Networks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11Networks, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(struct _tds__ScanAvailableDot11Networks), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__Dot11Status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Status, sizeof(struct tt__Dot11Status), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SSID && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_BSSID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PairCipher && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_GroupCipher && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SignalStrength && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ActiveConfigAlias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID > 0 || !a->ActiveConfigAlias))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Dot11Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Status, SOAP_TYPE_tt__Dot11Status, sizeof(struct tt__Dot11Status), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetDot11StatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(struct _tds__GetDot11StatusResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Status))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetDot11StatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11StatusResponse, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(struct _tds__GetDot11StatusResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetDot11Status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Status, sizeof(struct _tds__GetDot11Status), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->InterfaceToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetDot11Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Status, SOAP_TYPE__tds__GetDot11Status, sizeof(struct _tds__GetDot11Status), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__Dot11Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Capabilities, sizeof(struct tt__Dot11Capabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_TKIP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ScanAvailableNetworks && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MultipleConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_AdHocStationMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_WEP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TKIP > 0 || soap_flag_ScanAvailableNetworks > 0 || soap_flag_MultipleConfiguration > 0 || soap_flag_AdHocStationMode > 0 || soap_flag_WEP > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Dot11Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Capabilities, SOAP_TYPE_tt__Dot11Capabilities, sizeof(struct tt__Dot11Capabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetDot11CapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(struct _tds__GetDot11CapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetDot11CapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(struct _tds__GetDot11CapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetDot11Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(struct _tds__GetDot11Capabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetDot11Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Capabilities, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(struct _tds__GetDot11Capabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SendAuxiliaryCommandResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(struct _tds__SendAuxiliaryCommandResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AuxiliaryCommandResponse && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SendAuxiliaryCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(struct _tds__SendAuxiliaryCommandResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SendAuxiliaryCommand *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(struct _tds__SendAuxiliaryCommand), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_AuxiliaryCommand && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->AuxiliaryCommand))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SendAuxiliaryCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommand, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(struct _tds__SendAuxiliaryCommand), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetRelayOutputStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(struct _tds__SetRelayOutputStateResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetRelayOutputStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputStateResponse, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(struct _tds__SetRelayOutputStateResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetRelayOutputState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputState, sizeof(struct _tds__SetRelayOutputState), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RelayOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_LogicalState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RelayOutputToken || soap_flag_LogicalState > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetRelayOutputState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputState, SOAP_TYPE__tds__SetRelayOutputState, sizeof(struct _tds__SetRelayOutputState), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetRelayOutputSettingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(struct _tds__SetRelayOutputSettingsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetRelayOutputSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(struct _tds__SetRelayOutputSettingsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__RelayOutputSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(struct tt__RelayOutputSettings), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DelayTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_IdleState && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_DelayTime > 0 || soap_flag_IdleState > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__RelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutputSettings, SOAP_TYPE_tt__RelayOutputSettings, sizeof(struct tt__RelayOutputSettings), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetRelayOutputSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(struct _tds__SetRelayOutputSettings), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RelayOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->RelayOutputToken || !a->Properties))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetRelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettings, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(struct _tds__SetRelayOutputSettings), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RelayOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutput, sizeof(struct tt__RelayOutput), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Properties))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__RelayOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutput, SOAP_TYPE_tt__RelayOutput, sizeof(struct tt__RelayOutput), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetRelayOutputsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(struct _tds__GetRelayOutputsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:RelayOutputs", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetRelayOutputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputsResponse, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(struct _tds__GetRelayOutputsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetRelayOutputs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputs, sizeof(struct _tds__GetRelayOutputs), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetRelayOutputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputs, SOAP_TYPE__tds__GetRelayOutputs, sizeof(struct _tds__GetRelayOutputs), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__DeleteDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(struct _tds__DeleteDot1XConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__DeleteDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(struct _tds__DeleteDot1XConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__DeleteDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(struct _tds__DeleteDot1XConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Dot1XConfigurationToken", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__DeleteDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfiguration, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(struct _tds__DeleteDot1XConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetDot1XConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, sizeof(struct _tds__GetDot1XConfigurationsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Dot1XConfiguration", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetDot1XConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, sizeof(struct _tds__GetDot1XConfigurationsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetDot1XConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(struct _tds__GetDot1XConfigurations), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetDot1XConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurations, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(struct _tds__GetDot1XConfigurations), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurationResponse, sizeof(struct _tds__GetDot1XConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Dot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Dot1XConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurationResponse, SOAP_TYPE__tds__GetDot1XConfigurationResponse, sizeof(struct _tds__GetDot1XConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(struct _tds__GetDot1XConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Dot1XConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Dot1XConfigurationToken))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfiguration, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(struct _tds__GetDot1XConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDot1XConfigurationResponse, sizeof(struct _tds__SetDot1XConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDot1XConfigurationResponse, SOAP_TYPE__tds__SetDot1XConfigurationResponse, sizeof(struct _tds__SetDot1XConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(struct _tds__SetDot1XConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Dot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Dot1XConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDot1XConfiguration, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(struct _tds__SetDot1XConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__CreateDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, sizeof(struct _tds__CreateDot1XConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__CreateDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, sizeof(struct _tds__CreateDot1XConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Dot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(struct tt__Dot1XConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Dot1XConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Identity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_AnonymousID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_EAPMethod && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:CACertificateID", 1, NULL))
./soapC.c:			if (soap_flag_EAPMethodConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Dot1XConfigurationToken || !a->Identity || soap_flag_EAPMethod > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Dot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot1XConfiguration, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(struct tt__Dot1XConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__CreateDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(struct _tds__CreateDot1XConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Dot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Dot1XConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__CreateDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateDot1XConfiguration, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(struct _tds__CreateDot1XConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__LoadCACertificatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCACertificatesResponse, sizeof(struct _tds__LoadCACertificatesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__LoadCACertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCACertificatesResponse, SOAP_TYPE__tds__LoadCACertificatesResponse, sizeof(struct _tds__LoadCACertificatesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__LoadCACertificates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCACertificates, sizeof(struct _tds__LoadCACertificates), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CACertificate", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeCACertificate < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__LoadCACertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCACertificates, SOAP_TYPE__tds__LoadCACertificates, sizeof(struct _tds__LoadCACertificates), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__CertificateInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateInformation, sizeof(struct tt__CertificateInformation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_IssuerDN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_SubjectDN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_KeyUsage && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ExtendedKeyUsage && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_KeyLength && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_SerialNum && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_SignatureAlgorithm && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Validity && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__CertificateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateInformation, SOAP_TYPE_tt__CertificateInformation, sizeof(struct tt__CertificateInformation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetCertificateInformationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificateInformationResponse, sizeof(struct _tds__GetCertificateInformationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificateInformation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateInformation))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetCertificateInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificateInformationResponse, SOAP_TYPE__tds__GetCertificateInformationResponse, sizeof(struct _tds__GetCertificateInformationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetCertificateInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificateInformation, sizeof(struct _tds__GetCertificateInformation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetCertificateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificateInformation, SOAP_TYPE__tds__GetCertificateInformation, sizeof(struct _tds__GetCertificateInformation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__LoadCertificateWithPrivateKeyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, sizeof(struct _tds__LoadCertificateWithPrivateKeyResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__LoadCertificateWithPrivateKeyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, sizeof(struct _tds__LoadCertificateWithPrivateKeyResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__CertificateWithPrivateKey *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(struct tt__CertificateWithPrivateKey), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Certificate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_PrivateKey && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Certificate || !a->PrivateKey))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__CertificateWithPrivateKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateWithPrivateKey, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(struct tt__CertificateWithPrivateKey), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__LoadCertificateWithPrivateKey *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(struct _tds__LoadCertificateWithPrivateKey), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateWithPrivateKey", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeCertificateWithPrivateKey < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__LoadCertificateWithPrivateKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(struct _tds__LoadCertificateWithPrivateKey), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetCACertificatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCACertificatesResponse, sizeof(struct _tds__GetCACertificatesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CACertificate", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetCACertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCACertificatesResponse, SOAP_TYPE__tds__GetCACertificatesResponse, sizeof(struct _tds__GetCACertificatesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetCACertificates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCACertificates, sizeof(struct _tds__GetCACertificates), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetCACertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCACertificates, SOAP_TYPE__tds__GetCACertificates, sizeof(struct _tds__GetCACertificates), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetClientCertificateModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetClientCertificateModeResponse, sizeof(struct _tds__SetClientCertificateModeResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetClientCertificateModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetClientCertificateModeResponse, SOAP_TYPE__tds__SetClientCertificateModeResponse, sizeof(struct _tds__SetClientCertificateModeResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetClientCertificateMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(struct _tds__SetClientCertificateMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetClientCertificateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetClientCertificateMode, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(struct _tds__SetClientCertificateMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetClientCertificateModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetClientCertificateModeResponse, sizeof(struct _tds__GetClientCertificateModeResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetClientCertificateModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetClientCertificateModeResponse, SOAP_TYPE__tds__GetClientCertificateModeResponse, sizeof(struct _tds__GetClientCertificateModeResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetClientCertificateMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(struct _tds__GetClientCertificateMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetClientCertificateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetClientCertificateMode, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(struct _tds__GetClientCertificateMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__LoadCertificatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificatesResponse, sizeof(struct _tds__LoadCertificatesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__LoadCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificatesResponse, SOAP_TYPE__tds__LoadCertificatesResponse, sizeof(struct _tds__LoadCertificatesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__LoadCertificates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificates, sizeof(struct _tds__LoadCertificates), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NVTCertificate", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNVTCertificate < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__LoadCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificates, SOAP_TYPE__tds__LoadCertificates, sizeof(struct _tds__LoadCertificates), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetPkcs10RequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPkcs10RequestResponse, sizeof(struct _tds__GetPkcs10RequestResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Pkcs10Request && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Pkcs10Request))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetPkcs10RequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPkcs10RequestResponse, SOAP_TYPE__tds__GetPkcs10RequestResponse, sizeof(struct _tds__GetPkcs10RequestResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetPkcs10Request *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPkcs10Request, sizeof(struct _tds__GetPkcs10Request), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Subject && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Attributes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetPkcs10Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPkcs10Request, SOAP_TYPE__tds__GetPkcs10Request, sizeof(struct _tds__GetPkcs10Request), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__DeleteCertificatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteCertificatesResponse, sizeof(struct _tds__DeleteCertificatesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__DeleteCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteCertificatesResponse, SOAP_TYPE__tds__DeleteCertificatesResponse, sizeof(struct _tds__DeleteCertificatesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__DeleteCertificates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteCertificates, sizeof(struct _tds__DeleteCertificates), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateID", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeCertificateID < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__DeleteCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteCertificates, SOAP_TYPE__tds__DeleteCertificates, sizeof(struct _tds__DeleteCertificates), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetCertificatesStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetCertificatesStatusResponse, sizeof(struct _tds__SetCertificatesStatusResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetCertificatesStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetCertificatesStatusResponse, SOAP_TYPE__tds__SetCertificatesStatusResponse, sizeof(struct _tds__SetCertificatesStatusResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__SetCertificatesStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(struct _tds__SetCertificatesStatus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateStatus", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetCertificatesStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetCertificatesStatus, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(struct _tds__SetCertificatesStatus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__CertificateStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateStatus, sizeof(struct tt__CertificateStatus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID || soap_flag_Status > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__CertificateStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateStatus, SOAP_TYPE_tt__CertificateStatus, sizeof(struct tt__CertificateStatus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetCertificatesStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesStatusResponse, sizeof(struct _tds__GetCertificatesStatusResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateStatus", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetCertificatesStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesStatusResponse, SOAP_TYPE__tds__GetCertificatesStatusResponse, sizeof(struct _tds__GetCertificatesStatusResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetCertificatesStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(struct _tds__GetCertificatesStatus), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetCertificatesStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesStatus, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(struct _tds__GetCertificatesStatus), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetCertificatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesResponse, sizeof(struct _tds__GetCertificatesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NvtCertificate", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesResponse, SOAP_TYPE__tds__GetCertificatesResponse, sizeof(struct _tds__GetCertificatesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetCertificates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificates, sizeof(struct _tds__GetCertificates), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificates, SOAP_TYPE__tds__GetCertificates, sizeof(struct _tds__GetCertificates), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Certificate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Certificate, sizeof(struct tt__Certificate), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Certificate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID || !a->Certificate))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Certificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Certificate, SOAP_TYPE_tt__Certificate, sizeof(struct tt__Certificate), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__CreateCertificateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateCertificateResponse, sizeof(struct _tds__CreateCertificateResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_NvtCertificate && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->NvtCertificate))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__CreateCertificateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateCertificateResponse, SOAP_TYPE__tds__CreateCertificateResponse, sizeof(struct _tds__CreateCertificateResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__CreateCertificate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateCertificate, sizeof(struct _tds__CreateCertificate), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Subject && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ValidNotBefore && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ValidNotAfter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__CreateCertificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateCertificate, SOAP_TYPE__tds__CreateCertificate, sizeof(struct _tds__CreateCertificate), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetAccessPolicyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAccessPolicyResponse, sizeof(struct _tds__SetAccessPolicyResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetAccessPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAccessPolicyResponse, SOAP_TYPE__tds__SetAccessPolicyResponse, sizeof(struct _tds__SetAccessPolicyResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetAccessPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAccessPolicy, sizeof(struct _tds__SetAccessPolicy), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PolicyFile && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PolicyFile))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetAccessPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAccessPolicy, SOAP_TYPE__tds__SetAccessPolicy, sizeof(struct _tds__SetAccessPolicy), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__BinaryData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BinaryData, sizeof(struct tt__BinaryData), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__BinaryData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BinaryData, SOAP_TYPE_tt__BinaryData, sizeof(struct tt__BinaryData), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetAccessPolicyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAccessPolicyResponse, sizeof(struct _tds__GetAccessPolicyResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_PolicyFile && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->PolicyFile))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetAccessPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAccessPolicyResponse, SOAP_TYPE__tds__GetAccessPolicyResponse, sizeof(struct _tds__GetAccessPolicyResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetAccessPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAccessPolicy, sizeof(struct _tds__GetAccessPolicy), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetAccessPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAccessPolicy, SOAP_TYPE__tds__GetAccessPolicy, sizeof(struct _tds__GetAccessPolicy), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__RemoveIPAddressFilterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(struct _tds__RemoveIPAddressFilterResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__RemoveIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(struct _tds__RemoveIPAddressFilterResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__RemoveIPAddressFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(struct _tds__RemoveIPAddressFilter), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_IPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->IPAddressFilter))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__RemoveIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveIPAddressFilter, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(struct _tds__RemoveIPAddressFilter), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__AddIPAddressFilterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(struct _tds__AddIPAddressFilterResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__AddIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddIPAddressFilterResponse, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(struct _tds__AddIPAddressFilterResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__AddIPAddressFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(struct _tds__AddIPAddressFilter), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_IPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->IPAddressFilter))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__AddIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddIPAddressFilter, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(struct _tds__AddIPAddressFilter), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetIPAddressFilterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(struct _tds__SetIPAddressFilterResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetIPAddressFilterResponse, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(struct _tds__SetIPAddressFilterResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetIPAddressFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(struct _tds__SetIPAddressFilter), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_IPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->IPAddressFilter))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetIPAddressFilter, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(struct _tds__SetIPAddressFilter), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__IPAddressFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilter, sizeof(struct tt__IPAddressFilter), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv4Address", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv6Address", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__IPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilter, SOAP_TYPE_tt__IPAddressFilter, sizeof(struct tt__IPAddressFilter), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetIPAddressFilterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(struct _tds__GetIPAddressFilterResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_IPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->IPAddressFilter))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetIPAddressFilterResponse, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(struct _tds__GetIPAddressFilterResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetIPAddressFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(struct _tds__GetIPAddressFilter), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetIPAddressFilter, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(struct _tds__GetIPAddressFilter), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetZeroConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetZeroConfigurationResponse, sizeof(struct _tds__SetZeroConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetZeroConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetZeroConfigurationResponse, SOAP_TYPE__tds__SetZeroConfigurationResponse, sizeof(struct _tds__SetZeroConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetZeroConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(struct _tds__SetZeroConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->InterfaceToken || soap_flag_Enabled > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetZeroConfiguration, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(struct _tds__SetZeroConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__NetworkZeroConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(struct tt__NetworkZeroConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Addresses", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->InterfaceToken || soap_flag_Enabled > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__NetworkZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfiguration, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(struct tt__NetworkZeroConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetZeroConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetZeroConfigurationResponse, sizeof(struct _tds__GetZeroConfigurationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->ZeroConfiguration))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetZeroConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetZeroConfigurationResponse, SOAP_TYPE__tds__GetZeroConfigurationResponse, sizeof(struct _tds__GetZeroConfigurationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetZeroConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(struct _tds__GetZeroConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetZeroConfiguration, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(struct _tds__GetZeroConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetNetworkDefaultGatewayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(struct _tds__SetNetworkDefaultGatewayResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(struct _tds__SetNetworkDefaultGatewayResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetNetworkDefaultGateway *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(struct _tds__SetNetworkDefaultGateway), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:IPv4Address", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:IPv6Address", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGateway, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(struct _tds__SetNetworkDefaultGateway), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__NetworkGateway *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkGateway, sizeof(struct tt__NetworkGateway), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv4Address", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv6Address", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__NetworkGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkGateway, SOAP_TYPE_tt__NetworkGateway, sizeof(struct tt__NetworkGateway), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetNetworkDefaultGatewayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(struct _tds__GetNetworkDefaultGatewayResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_NetworkGateway && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->NetworkGateway))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(struct _tds__GetNetworkDefaultGatewayResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetNetworkDefaultGateway *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(struct _tds__GetNetworkDefaultGateway), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGateway, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(struct _tds__GetNetworkDefaultGateway), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetNetworkProtocolsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(struct _tds__SetNetworkProtocolsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocolsResponse, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(struct _tds__SetNetworkProtocolsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__SetNetworkProtocols *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(struct _tds__SetNetworkProtocols), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkProtocols", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNetworkProtocols < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocols, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(struct _tds__SetNetworkProtocols), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__NetworkProtocol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocol, sizeof(struct tt__NetworkProtocol), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Port", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_Enabled > 0 || a->__sizePort < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__NetworkProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocol, SOAP_TYPE_tt__NetworkProtocol, sizeof(struct tt__NetworkProtocol), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetNetworkProtocolsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(struct _tds__GetNetworkProtocolsResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkProtocols", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocolsResponse, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(struct _tds__GetNetworkProtocolsResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetNetworkProtocols *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(struct _tds__GetNetworkProtocols), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocols, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(struct _tds__GetNetworkProtocols), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetNetworkInterfacesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(struct _tds__SetNetworkInterfacesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RebootNeeded && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfacesResponse, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(struct _tds__SetNetworkInterfacesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__NetworkInterfaceSetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(struct tt__NetworkInterfaceSetConfiguration), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Link && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_MTU && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_IPv4 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_IPv6 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(struct tt__NetworkInterfaceSetConfiguration), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetNetworkInterfaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(struct _tds__SetNetworkInterfaces), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_NetworkInterface && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->InterfaceToken || !a->NetworkInterface))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfaces, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(struct _tds__SetNetworkInterfaces), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__NetworkInterface *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterface, sizeof(struct tt__NetworkInterface), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Info && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Link && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_IPv4 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_IPv6 && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterface, SOAP_TYPE_tt__NetworkInterface, sizeof(struct tt__NetworkInterface), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetNetworkInterfacesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(struct _tds__GetNetworkInterfacesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkInterfaces", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNetworkInterfaces < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfacesResponse, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(struct _tds__GetNetworkInterfacesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetNetworkInterfaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(struct _tds__GetNetworkInterfaces), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfaces, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(struct _tds__GetNetworkInterfaces), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetDynamicDNSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(struct _tds__SetDynamicDNSResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNSResponse, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(struct _tds__SetDynamicDNSResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetDynamicDNS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNS, sizeof(struct _tds__SetDynamicDNS), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_TTL && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNS, SOAP_TYPE__tds__SetDynamicDNS, sizeof(struct _tds__SetDynamicDNS), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__DynamicDNSInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(struct tt__DynamicDNSInformation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_TTL && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__DynamicDNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSInformation, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(struct tt__DynamicDNSInformation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetDynamicDNSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(struct _tds__GetDynamicDNSResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_DynamicDNSInformation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->DynamicDNSInformation))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNSResponse, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(struct _tds__GetDynamicDNSResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetDynamicDNS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNS, sizeof(struct _tds__GetDynamicDNS), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNS, SOAP_TYPE__tds__GetDynamicDNS, sizeof(struct _tds__GetDynamicDNS), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetNTPResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTPResponse, sizeof(struct _tds__SetNTPResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTPResponse, SOAP_TYPE__tds__SetNTPResponse, sizeof(struct _tds__SetNTPResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__SetNTP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTP, sizeof(struct _tds__SetNTP), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NTPManual", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTP, SOAP_TYPE__tds__SetNTP, sizeof(struct _tds__SetNTP), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__NTPInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NTPInformation, sizeof(struct tt__NTPInformation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:NTPFromDHCP", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:NTPManual", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__NTPInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NTPInformation, SOAP_TYPE_tt__NTPInformation, sizeof(struct tt__NTPInformation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetNTPResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTPResponse, sizeof(struct _tds__GetNTPResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_NTPInformation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->NTPInformation))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTPResponse, SOAP_TYPE__tds__GetNTPResponse, sizeof(struct _tds__GetNTPResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetNTP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTP, sizeof(struct _tds__GetNTP), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTP, SOAP_TYPE__tds__GetNTP, sizeof(struct _tds__GetNTP), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetDNSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNSResponse, sizeof(struct _tds__SetDNSResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNSResponse, SOAP_TYPE__tds__SetDNSResponse, sizeof(struct _tds__SetDNSResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__IPAddress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddress, sizeof(struct tt__IPAddress), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_IPv4Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_IPv6Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__IPAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddress, SOAP_TYPE_tt__IPAddress, sizeof(struct tt__IPAddress), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__SetDNS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNS, sizeof(struct _tds__SetDNS), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:SearchDomain", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:DNSManual", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNS, SOAP_TYPE__tds__SetDNS, sizeof(struct _tds__SetDNS), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__DNSInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSInformation, sizeof(struct tt__DNSInformation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SearchDomain", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:DNSFromDHCP", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:DNSManual", 1, NULL))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__DNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DNSInformation, SOAP_TYPE_tt__DNSInformation, sizeof(struct tt__DNSInformation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetDNSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNSResponse, sizeof(struct _tds__GetDNSResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_DNSInformation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->DNSInformation))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNSResponse, SOAP_TYPE__tds__GetDNSResponse, sizeof(struct _tds__GetDNSResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetDNS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNS, sizeof(struct _tds__GetDNS), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNS, SOAP_TYPE__tds__GetDNS, sizeof(struct _tds__GetDNS), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetHostnameFromDHCPResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(struct _tds__SetHostnameFromDHCPResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RebootNeeded && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetHostnameFromDHCPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(struct _tds__SetHostnameFromDHCPResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetHostnameFromDHCP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(struct _tds__SetHostnameFromDHCP), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetHostnameFromDHCP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCP, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(struct _tds__SetHostnameFromDHCP), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetHostnameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameResponse, sizeof(struct _tds__SetHostnameResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameResponse, SOAP_TYPE__tds__SetHostnameResponse, sizeof(struct _tds__SetHostnameResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetHostname *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostname, sizeof(struct _tds__SetHostname), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostname, SOAP_TYPE__tds__SetHostname, sizeof(struct _tds__SetHostname), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__HostnameInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HostnameInformation, sizeof(struct tt__HostnameInformation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__HostnameInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__HostnameInformation, SOAP_TYPE_tt__HostnameInformation, sizeof(struct tt__HostnameInformation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetHostnameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostnameResponse, sizeof(struct _tds__GetHostnameResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_HostnameInformation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->HostnameInformation))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostnameResponse, SOAP_TYPE__tds__GetHostnameResponse, sizeof(struct _tds__GetHostnameResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetHostname *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostname, sizeof(struct _tds__GetHostname), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostname, SOAP_TYPE__tds__GetHostname, sizeof(struct _tds__GetHostname), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Analytics && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Device && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Events && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Imaging && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Media && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_PTZ && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Capabilities, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(struct _tds__GetCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilitiesResponse, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(struct _tds__GetCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilities, sizeof(struct _tds__GetCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Category", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilities, SOAP_TYPE__tds__GetCapabilities, sizeof(struct _tds__GetCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetWsdlUrlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(struct _tds__GetWsdlUrlResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_WsdlUrl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->WsdlUrl))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetWsdlUrlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetWsdlUrlResponse, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(struct _tds__GetWsdlUrlResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetWsdlUrl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetWsdlUrl, sizeof(struct _tds__GetWsdlUrl), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetWsdlUrl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetWsdlUrl, SOAP_TYPE__tds__GetWsdlUrl, sizeof(struct _tds__GetWsdlUrl), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUserResponse, sizeof(struct _tds__SetUserResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUserResponse, SOAP_TYPE__tds__SetUserResponse, sizeof(struct _tds__SetUserResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__SetUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUser, sizeof(struct _tds__SetUser), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUser < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUser, SOAP_TYPE__tds__SetUser, sizeof(struct _tds__SetUser), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__DeleteUsersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(struct _tds__DeleteUsersResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__DeleteUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsersResponse, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(struct _tds__DeleteUsersResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__DeleteUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsers, sizeof(struct _tds__DeleteUsers), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Username", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUsername < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__DeleteUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsers, SOAP_TYPE__tds__DeleteUsers, sizeof(struct _tds__DeleteUsers), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__CreateUsersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateUsersResponse, sizeof(struct _tds__CreateUsersResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__CreateUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateUsersResponse, SOAP_TYPE__tds__CreateUsersResponse, sizeof(struct _tds__CreateUsersResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__CreateUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateUsers, sizeof(struct _tds__CreateUsers), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUser < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__CreateUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateUsers, SOAP_TYPE__tds__CreateUsers, sizeof(struct _tds__CreateUsers), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__User *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__User, sizeof(struct tt__User), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UserLevel && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Username || soap_flag_UserLevel > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__User, SOAP_TYPE_tt__User, sizeof(struct tt__User), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetUsersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetUsersResponse, sizeof(struct _tds__GetUsersResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetUsersResponse, SOAP_TYPE__tds__GetUsersResponse, sizeof(struct _tds__GetUsersResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetUsers, sizeof(struct _tds__GetUsers), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetUsers, SOAP_TYPE__tds__GetUsers, sizeof(struct _tds__GetUsers), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetRemoteUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteUserResponse, sizeof(struct _tds__SetRemoteUserResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetRemoteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteUserResponse, SOAP_TYPE__tds__SetRemoteUserResponse, sizeof(struct _tds__SetRemoteUserResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetRemoteUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteUser, sizeof(struct _tds__SetRemoteUser), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RemoteUser && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetRemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteUser, SOAP_TYPE__tds__SetRemoteUser, sizeof(struct _tds__SetRemoteUser), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tt__RemoteUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RemoteUser, sizeof(struct tt__RemoteUser), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_UseDerivedPassword && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Username || soap_flag_UseDerivedPassword > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__RemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RemoteUser, SOAP_TYPE_tt__RemoteUser, sizeof(struct tt__RemoteUser), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetRemoteUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteUserResponse, sizeof(struct _tds__GetRemoteUserResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RemoteUser && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetRemoteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteUserResponse, SOAP_TYPE__tds__GetRemoteUserResponse, sizeof(struct _tds__GetRemoteUserResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetRemoteUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteUser, sizeof(struct _tds__GetRemoteUser), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetRemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteUser, SOAP_TYPE__tds__GetRemoteUser, sizeof(struct _tds__GetRemoteUser), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetEndpointReferenceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetEndpointReferenceResponse, sizeof(struct _tds__GetEndpointReferenceResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_GUID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->GUID))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetEndpointReferenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetEndpointReferenceResponse, SOAP_TYPE__tds__GetEndpointReferenceResponse, sizeof(struct _tds__GetEndpointReferenceResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetEndpointReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetEndpointReference, sizeof(struct _tds__GetEndpointReference), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetEndpointReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetEndpointReference, SOAP_TYPE__tds__GetEndpointReference, sizeof(struct _tds__GetEndpointReference), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetDPAddressesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDPAddressesResponse, sizeof(struct _tds__SetDPAddressesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetDPAddressesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDPAddressesResponse, SOAP_TYPE__tds__SetDPAddressesResponse, sizeof(struct _tds__SetDPAddressesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__SetDPAddresses *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDPAddresses, sizeof(struct _tds__SetDPAddresses), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:DPAddress", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetDPAddresses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDPAddresses, SOAP_TYPE__tds__SetDPAddresses, sizeof(struct _tds__SetDPAddresses), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__NetworkHost *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHost, sizeof(struct tt__NetworkHost), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_IPv4Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_IPv6Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_DNSname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__NetworkHost *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHost, SOAP_TYPE_tt__NetworkHost, sizeof(struct tt__NetworkHost), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetDPAddressesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDPAddressesResponse, sizeof(struct _tds__GetDPAddressesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:DPAddress", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetDPAddressesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDPAddressesResponse, SOAP_TYPE__tds__GetDPAddressesResponse, sizeof(struct _tds__GetDPAddressesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetDPAddresses *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDPAddresses, sizeof(struct _tds__GetDPAddresses), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetDPAddresses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDPAddresses, SOAP_TYPE__tds__GetDPAddresses, sizeof(struct _tds__GetDPAddresses), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetRemoteDiscoveryModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, sizeof(struct _tds__SetRemoteDiscoveryModeResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetRemoteDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, sizeof(struct _tds__SetRemoteDiscoveryModeResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetRemoteDiscoveryMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(struct _tds__SetRemoteDiscoveryMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RemoteDiscoveryMode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetRemoteDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteDiscoveryMode, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(struct _tds__SetRemoteDiscoveryMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetRemoteDiscoveryModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, sizeof(struct _tds__GetRemoteDiscoveryModeResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_RemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RemoteDiscoveryMode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetRemoteDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, sizeof(struct _tds__GetRemoteDiscoveryModeResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetRemoteDiscoveryMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(struct _tds__GetRemoteDiscoveryMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetRemoteDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteDiscoveryMode, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(struct _tds__GetRemoteDiscoveryMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetDiscoveryModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDiscoveryModeResponse, sizeof(struct _tds__SetDiscoveryModeResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDiscoveryModeResponse, SOAP_TYPE__tds__SetDiscoveryModeResponse, sizeof(struct _tds__SetDiscoveryModeResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetDiscoveryMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(struct _tds__SetDiscoveryMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_DiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryMode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDiscoveryMode, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(struct _tds__SetDiscoveryMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetDiscoveryModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDiscoveryModeResponse, sizeof(struct _tds__GetDiscoveryModeResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_DiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryMode > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDiscoveryModeResponse, SOAP_TYPE__tds__GetDiscoveryModeResponse, sizeof(struct _tds__GetDiscoveryModeResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetDiscoveryMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(struct _tds__GetDiscoveryMode), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDiscoveryMode, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(struct _tds__GetDiscoveryMode), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__RemoveScopesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveScopesResponse, sizeof(struct _tds__RemoveScopesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:ScopeItem", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__RemoveScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveScopesResponse, SOAP_TYPE__tds__RemoveScopesResponse, sizeof(struct _tds__RemoveScopesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__RemoveScopes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveScopes, sizeof(struct _tds__RemoveScopes), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:ScopeItem", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopeItem < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__RemoveScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveScopes, SOAP_TYPE__tds__RemoveScopes, sizeof(struct _tds__RemoveScopes), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__AddScopesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddScopesResponse, sizeof(struct _tds__AddScopesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__AddScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddScopesResponse, SOAP_TYPE__tds__AddScopesResponse, sizeof(struct _tds__AddScopesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__AddScopes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddScopes, sizeof(struct _tds__AddScopes), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:ScopeItem", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopeItem < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__AddScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddScopes, SOAP_TYPE__tds__AddScopes, sizeof(struct _tds__AddScopes), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetScopesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetScopesResponse, sizeof(struct _tds__SetScopesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetScopesResponse, SOAP_TYPE__tds__SetScopesResponse, sizeof(struct _tds__SetScopesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetScopes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetScopes, sizeof(struct _tds__SetScopes), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Scopes", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopes < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetScopes, SOAP_TYPE__tds__SetScopes, sizeof(struct _tds__SetScopes), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__Scope *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Scope, sizeof(struct tt__Scope), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ScopeDef && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ScopeItem && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ScopeDef > 0 || !a->ScopeItem))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__Scope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Scope, SOAP_TYPE_tt__Scope, sizeof(struct tt__Scope), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetScopesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetScopesResponse, sizeof(struct _tds__GetScopesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Scopes", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopes < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetScopesResponse, SOAP_TYPE__tds__GetScopesResponse, sizeof(struct _tds__GetScopesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetScopes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetScopes, sizeof(struct _tds__GetScopes), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetScopes, SOAP_TYPE__tds__GetScopes, sizeof(struct _tds__GetScopes), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__SystemLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLog, sizeof(struct tt__SystemLog), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Binary && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_String && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__SystemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLog, SOAP_TYPE_tt__SystemLog, sizeof(struct tt__SystemLog), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetSystemLogResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemLogResponse, sizeof(struct _tds__GetSystemLogResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SystemLog && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SystemLog))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetSystemLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemLogResponse, SOAP_TYPE__tds__GetSystemLogResponse, sizeof(struct _tds__GetSystemLogResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetSystemLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemLog, sizeof(struct _tds__GetSystemLog), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_LogType && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LogType > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetSystemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemLog, SOAP_TYPE__tds__GetSystemLog, sizeof(struct _tds__GetSystemLog), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__SupportInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportInformation, sizeof(struct tt__SupportInformation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Binary && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_String && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tt__SupportInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportInformation, SOAP_TYPE_tt__SupportInformation, sizeof(struct tt__SupportInformation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetSystemSupportInformationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemSupportInformationResponse, sizeof(struct _tds__GetSystemSupportInformationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SupportInformation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SupportInformation))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetSystemSupportInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemSupportInformationResponse, SOAP_TYPE__tds__GetSystemSupportInformationResponse, sizeof(struct _tds__GetSystemSupportInformationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetSystemSupportInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(struct _tds__GetSystemSupportInformation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetSystemSupportInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemSupportInformation, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(struct _tds__GetSystemSupportInformation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetSystemBackupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(struct _tds__GetSystemBackupResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:BackupFiles", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeBackupFiles < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetSystemBackupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemBackupResponse, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(struct _tds__GetSystemBackupResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetSystemBackup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemBackup, sizeof(struct _tds__GetSystemBackup), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetSystemBackup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemBackup, SOAP_TYPE__tds__GetSystemBackup, sizeof(struct _tds__GetSystemBackup), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__RestoreSystemResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RestoreSystemResponse, sizeof(struct _tds__RestoreSystemResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__RestoreSystemResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RestoreSystemResponse, SOAP_TYPE__tds__RestoreSystemResponse, sizeof(struct _tds__RestoreSystemResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__BackupFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BackupFile, sizeof(struct tt__BackupFile), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || !a->Data))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__BackupFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BackupFile, SOAP_TYPE_tt__BackupFile, sizeof(struct tt__BackupFile), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__RestoreSystem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RestoreSystem, sizeof(struct _tds__RestoreSystem), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:BackupFiles", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeBackupFiles < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__RestoreSystem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RestoreSystem, SOAP_TYPE__tds__RestoreSystem, sizeof(struct _tds__RestoreSystem), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SystemRebootResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SystemRebootResponse, sizeof(struct _tds__SystemRebootResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Message))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SystemRebootResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SystemRebootResponse, SOAP_TYPE__tds__SystemRebootResponse, sizeof(struct _tds__SystemRebootResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SystemReboot *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SystemReboot, sizeof(struct _tds__SystemReboot), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SystemReboot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SystemReboot, SOAP_TYPE__tds__SystemReboot, sizeof(struct _tds__SystemReboot), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__UpgradeSystemFirmwareResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, sizeof(struct _tds__UpgradeSystemFirmwareResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__UpgradeSystemFirmwareResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, sizeof(struct _tds__UpgradeSystemFirmwareResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__AttachmentData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AttachmentData, sizeof(struct tt__AttachmentData), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_xop__Include && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_xop__Include > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__AttachmentData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AttachmentData, SOAP_TYPE_tt__AttachmentData, sizeof(struct tt__AttachmentData), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__UpgradeSystemFirmware *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(struct _tds__UpgradeSystemFirmware), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Firmware && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Firmware))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__UpgradeSystemFirmware *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__UpgradeSystemFirmware, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(struct _tds__UpgradeSystemFirmware), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetSystemFactoryDefaultResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(struct _tds__SetSystemFactoryDefaultResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetSystemFactoryDefaultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(struct _tds__SetSystemFactoryDefaultResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetSystemFactoryDefault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(struct _tds__SetSystemFactoryDefault), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_FactoryDefault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FactoryDefault > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetSystemFactoryDefault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemFactoryDefault, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(struct _tds__SetSystemFactoryDefault), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__SystemDateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTime, sizeof(struct tt__SystemDateTime), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_DateTimeType && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DaylightSavings && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_TimeZone && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_UTCDateTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_LocalDateTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DateTimeType > 0 || soap_flag_DaylightSavings > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__SystemDateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemDateTime, SOAP_TYPE_tt__SystemDateTime, sizeof(struct tt__SystemDateTime), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetSystemDateAndTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(struct _tds__GetSystemDateAndTimeResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->SystemDateAndTime))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetSystemDateAndTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(struct _tds__GetSystemDateAndTimeResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetSystemDateAndTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(struct _tds__GetSystemDateAndTime), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetSystemDateAndTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemDateAndTime, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(struct _tds__GetSystemDateAndTime), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetSystemDateAndTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(struct _tds__SetSystemDateAndTimeResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__SetSystemDateAndTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(struct _tds__SetSystemDateAndTimeResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__DateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DateTime, sizeof(struct tt__DateTime), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Date && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Time || !a->Date))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__DateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DateTime, SOAP_TYPE_tt__DateTime, sizeof(struct tt__DateTime), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__TimeZone *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TimeZone, sizeof(struct tt__TimeZone), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_TZ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->TZ))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__TimeZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TimeZone, SOAP_TYPE_tt__TimeZone, sizeof(struct tt__TimeZone), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__SetSystemDateAndTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(struct _tds__SetSystemDateAndTime), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_DateTimeType && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DaylightSavings && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_TimeZone && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_UTCDateTime && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DateTimeType > 0 || soap_flag_DaylightSavings > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__SetSystemDateAndTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemDateAndTime, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(struct _tds__SetSystemDateAndTime), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetDeviceInformationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(struct _tds__GetDeviceInformationResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Manufacturer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Model && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_FirmwareVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_SerialNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_HardwareId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Manufacturer || !a->Model || !a->FirmwareVersion || !a->SerialNumber || !a->HardwareId))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetDeviceInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDeviceInformationResponse, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(struct _tds__GetDeviceInformationResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetDeviceInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(struct _tds__GetDeviceInformation), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetDeviceInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDeviceInformation, SOAP_TYPE__tds__GetDeviceInformation, sizeof(struct _tds__GetDeviceInformation), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(struct _tds__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(struct _tds__GetServiceCapabilitiesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(struct _tds__GetServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServiceCapabilities, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(struct _tds__GetServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__GetServicesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServicesResponse, sizeof(struct _tds__GetServicesResponse), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Service", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeService < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetServicesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServicesResponse, SOAP_TYPE__tds__GetServicesResponse, sizeof(struct _tds__GetServicesResponse), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__GetServices *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServices, sizeof(struct _tds__GetServices), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_IncludeCapability && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IncludeCapability > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _tds__GetServices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServices, SOAP_TYPE__tds__GetServices, sizeof(struct _tds__GetServices), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__StorageConfigurationData_Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StorageConfigurationData_Extension, sizeof(struct _tds__StorageConfigurationData_Extension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__StorageConfigurationData_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StorageConfigurationData_Extension, SOAP_TYPE__tds__StorageConfigurationData_Extension, sizeof(struct _tds__StorageConfigurationData_Extension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tds__StorageConfigurationData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__StorageConfigurationData, sizeof(struct tds__StorageConfigurationData), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_LocalPath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_StorageUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_User && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tds__StorageConfigurationData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__StorageConfigurationData, SOAP_TYPE_tds__StorageConfigurationData, sizeof(struct tds__StorageConfigurationData), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _tds__UserCredential_Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__UserCredential_Extension, sizeof(struct _tds__UserCredential_Extension), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__UserCredential_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__UserCredential_Extension, SOAP_TYPE__tds__UserCredential_Extension, sizeof(struct _tds__UserCredential_Extension), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tds__UserCredential *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__UserCredential, sizeof(struct tds__UserCredential), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_UserName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->UserName))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tds__UserCredential *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__UserCredential, SOAP_TYPE_tds__UserCredential, sizeof(struct tds__UserCredential), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tds__MiscCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__MiscCapabilities, sizeof(struct tds__MiscCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tds__MiscCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__MiscCapabilities, SOAP_TYPE_tds__MiscCapabilities, sizeof(struct tds__MiscCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tds__SystemCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__SystemCapabilities, sizeof(struct tds__SystemCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tds__SystemCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__SystemCapabilities, SOAP_TYPE_tds__SystemCapabilities, sizeof(struct tds__SystemCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tds__SecurityCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__SecurityCapabilities, sizeof(struct tds__SecurityCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tds__SecurityCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__SecurityCapabilities, SOAP_TYPE_tds__SecurityCapabilities, sizeof(struct tds__SecurityCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tds__NetworkCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__NetworkCapabilities, sizeof(struct tds__NetworkCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct tds__NetworkCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__NetworkCapabilities, SOAP_TYPE_tds__NetworkCapabilities, sizeof(struct tds__NetworkCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tds__DeviceServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(struct tds__DeviceServiceCapabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Network && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Security && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_System && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Misc && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Network || !a->Security || !a->System))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tds__DeviceServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__DeviceServiceCapabilities, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(struct tds__DeviceServiceCapabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct tt__OnvifVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OnvifVersion, sizeof(struct tt__OnvifVersion), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Major && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Minor && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Major > 0 || soap_flag_Minor > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tt__OnvifVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OnvifVersion, SOAP_TYPE_tt__OnvifVersion, sizeof(struct tt__OnvifVersion), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _tds__Service_Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__Service_Capabilities, sizeof(struct _tds__Service_Capabilities), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _tds__Service_Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__Service_Capabilities, SOAP_TYPE__tds__Service_Capabilities, sizeof(struct _tds__Service_Capabilities), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct tds__Service *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__Service, sizeof(struct tds__Service), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Namespace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Version && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Namespace || !a->XAddr || !a->Version))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct tds__Service *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__Service, SOAP_TYPE_tds__Service, sizeof(struct tds__Service), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:			soap->mode |= SOAP_ENC_DIME;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
./soapC.c:	{	soap->error = SOAP_TYPE;
./soapC.c:	a = (struct xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Base64DERencodedASN1Value, sizeof(struct xsd__base64Binary), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
./soapC.c:		if (*soap->href != '#')
./soapC.c:			a = (struct xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Base64DERencodedASN1Value, SOAP_TYPE_ns5__Base64DERencodedASN1Value, sizeof(struct xsd__base64Binary), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error = SOAP_LENGTH;
./soapC.c:		return soap->error = SOAP_LENGTH;
./soapC.c:	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
./soapC.c:	{	soap->error = SOAP_TYPE;
./soapC.c:	a = (struct xsd__hexBinary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSK, sizeof(struct xsd__hexBinary), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
./soapC.c:		{	soap->error = SOAP_LENGTH;
./soapC.c:		{	soap->error = SOAP_LENGTH;
./soapC.c:	{	a = (struct xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSK, SOAP_TYPE_tt__Dot11PSK, sizeof(struct xsd__hexBinary), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error = SOAP_LENGTH;
./soapC.c:		return soap->error = SOAP_LENGTH;
./soapC.c:	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
./soapC.c:	{	soap->error = SOAP_TYPE;
./soapC.c:	a = (struct xsd__hexBinary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SSIDType, sizeof(struct xsd__hexBinary), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
./soapC.c:		{	soap->error = SOAP_LENGTH;
./soapC.c:		{	soap->error = SOAP_LENGTH;
./soapC.c:	{	a = (struct xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SSIDType, SOAP_TYPE_tt__Dot11SSIDType, sizeof(struct xsd__hexBinary), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
./soapC.c:	{	soap->error = SOAP_TYPE;
./soapC.c:	a = (struct xsd__hexBinary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__hexBinary, sizeof(struct xsd__hexBinary), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
./soapC.c:	{	a = (struct xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__hexBinary, SOAP_TYPE_xsd__hexBinary, sizeof(struct xsd__hexBinary), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:			soap->mode |= SOAP_ENC_DIME;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
./soapC.c:	{	soap->error = SOAP_TYPE;
./soapC.c:	a = (struct xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
./soapC.c:		if (*soap->href != '#')
./soapC.c:			a = (struct xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct SOAP_ENV__Envelope *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SOAP_ENV__Header && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SOAP_ENV__Body && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct SOAP_ENV__Envelope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Envelope, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsse__Security *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_xenc__EncryptedKey && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_xenc__ReferenceList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsc__SecurityContextToken && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml1__Assertion && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__Assertion && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml2__Attribute && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__EncryptedAttribute && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml2__AssertionIDRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_saml2__AssertionURIRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_saml2__Assertion && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__EncryptedAssertion && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml2__AssertionIDRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_saml2__AssertionURIRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_saml2__Assertion && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__EncryptedAssertion && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml2__Condition && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__AudienceRestriction && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__OneTimeUse && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__ProxyRestriction && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml2__Statement && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__AuthnStatement && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__AuthzDecisionStatement && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__AttributeStatement && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml2__AttributeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AttributeType, sizeof(struct saml2__AttributeType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:AttributeValue", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml2__AttributeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AttributeType, SOAP_TYPE_saml2__AttributeType, sizeof(struct saml2__AttributeType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct saml2__AttributeStatementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AttributeStatementType, sizeof(struct saml2__AttributeStatementType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml2__AttributeStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AttributeStatementType, SOAP_TYPE_saml2__AttributeStatementType, sizeof(struct saml2__AttributeStatementType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct saml2__EvidenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__EvidenceType, sizeof(struct saml2__EvidenceType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml2__EvidenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__EvidenceType, SOAP_TYPE_saml2__EvidenceType, sizeof(struct saml2__EvidenceType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct saml2__ActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ActionType, sizeof(struct saml2__ActionType), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml2__AuthzDecisionStatementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AuthzDecisionStatementType, sizeof(struct saml2__AuthzDecisionStatementType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:Action", 1, NULL))
./soapC.c:			if (soap_flag_saml2__Evidence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAction < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct saml2__AuthzDecisionStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AuthzDecisionStatementType, SOAP_TYPE_saml2__AuthzDecisionStatementType, sizeof(struct saml2__AuthzDecisionStatementType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml2__AuthnContextType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AuthnContextType, sizeof(struct saml2__AuthnContextType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml2__AuthnContextClassRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_saml2__AuthnContextDecl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_saml2__AuthnContextDeclRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:AuthenticatingAuthority", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml2__AuthnContextType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AuthnContextType, SOAP_TYPE_saml2__AuthnContextType, sizeof(struct saml2__AuthnContextType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml2__SubjectLocalityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectLocalityType, sizeof(struct saml2__SubjectLocalityType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml2__SubjectLocalityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectLocalityType, SOAP_TYPE_saml2__SubjectLocalityType, sizeof(struct saml2__SubjectLocalityType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml2__AuthnStatementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AuthnStatementType, sizeof(struct saml2__AuthnStatementType), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml2__SubjectLocality && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__AuthnContext && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml2__AuthnContext))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct saml2__AuthnStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AuthnStatementType, SOAP_TYPE_saml2__AuthnStatementType, sizeof(struct saml2__AuthnStatementType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml2__StatementAbstractType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__StatementAbstractType, sizeof(struct saml2__StatementAbstractType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml2__StatementAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__StatementAbstractType, SOAP_TYPE_saml2__StatementAbstractType, sizeof(struct saml2__StatementAbstractType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct saml2__AdviceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AdviceType, sizeof(struct saml2__AdviceType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml2__AdviceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AdviceType, SOAP_TYPE_saml2__AdviceType, sizeof(struct saml2__AdviceType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml2__ProxyRestrictionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ProxyRestrictionType, sizeof(struct saml2__ProxyRestrictionType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:Audience", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml2__ProxyRestrictionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__ProxyRestrictionType, SOAP_TYPE_saml2__ProxyRestrictionType, sizeof(struct saml2__ProxyRestrictionType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml2__OneTimeUseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__OneTimeUseType, sizeof(struct saml2__OneTimeUseType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml2__OneTimeUseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__OneTimeUseType, SOAP_TYPE_saml2__OneTimeUseType, sizeof(struct saml2__OneTimeUseType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml2__AudienceRestrictionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AudienceRestrictionType, sizeof(struct saml2__AudienceRestrictionType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:Audience", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAudience < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct saml2__AudienceRestrictionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AudienceRestrictionType, SOAP_TYPE_saml2__AudienceRestrictionType, sizeof(struct saml2__AudienceRestrictionType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml2__ConditionAbstractType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ConditionAbstractType, sizeof(struct saml2__ConditionAbstractType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml2__ConditionAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__ConditionAbstractType, SOAP_TYPE_saml2__ConditionAbstractType, sizeof(struct saml2__ConditionAbstractType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct saml2__ConditionsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ConditionsType, sizeof(struct saml2__ConditionsType), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml2__ConditionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__ConditionsType, SOAP_TYPE_saml2__ConditionsType, sizeof(struct saml2__ConditionsType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct saml2__KeyInfoConfirmationDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__KeyInfoConfirmationDataType, sizeof(struct saml2__KeyInfoConfirmationDataType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:KeyInfo", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeds__KeyInfo < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct saml2__KeyInfoConfirmationDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__KeyInfoConfirmationDataType, SOAP_TYPE_saml2__KeyInfoConfirmationDataType, sizeof(struct saml2__KeyInfoConfirmationDataType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml2__SubjectConfirmationDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectConfirmationDataType, sizeof(struct saml2__SubjectConfirmationDataType), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml2__SubjectConfirmationDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectConfirmationDataType, SOAP_TYPE_saml2__SubjectConfirmationDataType, sizeof(struct saml2__SubjectConfirmationDataType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml2__SubjectConfirmationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectConfirmationType, sizeof(struct saml2__SubjectConfirmationType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml2__BaseID && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__NameID && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__EncryptedID && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__SubjectConfirmationData && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml2__SubjectConfirmationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectConfirmationType, SOAP_TYPE_saml2__SubjectConfirmationType, sizeof(struct saml2__SubjectConfirmationType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct saml2__SubjectType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectType, sizeof(struct saml2__SubjectType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml2__BaseID && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__NameID && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__EncryptedID && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:SubjectConfirmation", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml2__SubjectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectType, SOAP_TYPE_saml2__SubjectType, sizeof(struct saml2__SubjectType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct saml2__AssertionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AssertionType, sizeof(struct saml2__AssertionType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml2__Issuer && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__Subject && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__Conditions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml2__Advice && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml2__Issuer))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct saml2__AssertionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AssertionType, SOAP_TYPE_saml2__AssertionType, sizeof(struct saml2__AssertionType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct saml2__EncryptedElementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__EncryptedElementType, sizeof(struct saml2__EncryptedElementType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_xenc__EncryptedData && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "xenc:EncryptedKey", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_xenc__EncryptedData > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct saml2__EncryptedElementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__EncryptedElementType, SOAP_TYPE_saml2__EncryptedElementType, sizeof(struct saml2__EncryptedElementType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct saml2__NameIDType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__NameIDType, sizeof(struct saml2__NameIDType), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml2__BaseIDAbstractType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__BaseIDAbstractType, sizeof(struct saml2__BaseIDAbstractType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml2__BaseIDAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__BaseIDAbstractType, SOAP_TYPE_saml2__BaseIDAbstractType, sizeof(struct saml2__BaseIDAbstractType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml1__AssertionIDReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_saml1__Assertion && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml1__AssertionIDReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_saml1__Assertion && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml1__AudienceRestrictionCondition && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml1__DoNotCacheCondition && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml1__Condition && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml1__Statement && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml1__SubjectStatement && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml1__AuthenticationStatement && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml1__AuthorizationDecisionStatement && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml1__AttributeStatement && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml1__AttributeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AttributeType, sizeof(struct saml1__AttributeType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:AttributeValue", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAttributeValue < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct saml1__AttributeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AttributeType, SOAP_TYPE_saml1__AttributeType, sizeof(struct saml1__AttributeType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml1__AttributeDesignatorType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AttributeDesignatorType, sizeof(struct saml1__AttributeDesignatorType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml1__AttributeDesignatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AttributeDesignatorType, SOAP_TYPE_saml1__AttributeDesignatorType, sizeof(struct saml1__AttributeDesignatorType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct saml1__AttributeStatementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AttributeStatementType, sizeof(struct saml1__AttributeStatementType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:Attribute", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml1__Subject || a->__sizeAttribute < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct saml1__AttributeStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AttributeStatementType, SOAP_TYPE_saml1__AttributeStatementType, sizeof(struct saml1__AttributeStatementType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct saml1__EvidenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__EvidenceType, sizeof(struct saml1__EvidenceType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml1__EvidenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__EvidenceType, SOAP_TYPE_saml1__EvidenceType, sizeof(struct saml1__EvidenceType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct saml1__ActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__ActionType, sizeof(struct saml1__ActionType), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml1__AuthorizationDecisionStatementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, sizeof(struct saml1__AuthorizationDecisionStatementType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:Action", 1, NULL))
./soapC.c:			if (soap_flag_saml1__Evidence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml1__Subject || a->__sizeAction < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct saml1__AuthorizationDecisionStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, sizeof(struct saml1__AuthorizationDecisionStatementType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml1__AuthorityBindingType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AuthorityBindingType, sizeof(struct saml1__AuthorityBindingType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml1__AuthorityBindingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AuthorityBindingType, SOAP_TYPE_saml1__AuthorityBindingType, sizeof(struct saml1__AuthorityBindingType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml1__SubjectLocalityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectLocalityType, sizeof(struct saml1__SubjectLocalityType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml1__SubjectLocalityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectLocalityType, SOAP_TYPE_saml1__SubjectLocalityType, sizeof(struct saml1__SubjectLocalityType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct saml1__AuthenticationStatementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AuthenticationStatementType, sizeof(struct saml1__AuthenticationStatementType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml1__SubjectLocality && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:AuthorityBinding", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml1__Subject))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct saml1__AuthenticationStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AuthenticationStatementType, SOAP_TYPE_saml1__AuthenticationStatementType, sizeof(struct saml1__AuthenticationStatementType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml1__SubjectConfirmationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectConfirmationType, sizeof(struct saml1__SubjectConfirmationType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:ConfirmationMethod", 1, NULL))
./soapC.c:			if (soap_flag_saml1__SubjectConfirmationData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfirmationMethod < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct saml1__SubjectConfirmationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectConfirmationType, SOAP_TYPE_saml1__SubjectConfirmationType, sizeof(struct saml1__SubjectConfirmationType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct saml1__NameIdentifierType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__NameIdentifierType, sizeof(struct saml1__NameIdentifierType), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml1__SubjectType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectType, sizeof(struct saml1__SubjectType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml1__NameIdentifier && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml1__SubjectConfirmation && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml1__SubjectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectType, SOAP_TYPE_saml1__SubjectType, sizeof(struct saml1__SubjectType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml1__SubjectStatementAbstractType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectStatementAbstractType, sizeof(struct saml1__SubjectStatementAbstractType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml1__Subject))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct saml1__SubjectStatementAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectStatementAbstractType, SOAP_TYPE_saml1__SubjectStatementAbstractType, sizeof(struct saml1__SubjectStatementAbstractType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml1__StatementAbstractType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__StatementAbstractType, sizeof(struct saml1__StatementAbstractType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml1__StatementAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__StatementAbstractType, SOAP_TYPE_saml1__StatementAbstractType, sizeof(struct saml1__StatementAbstractType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct saml1__AdviceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AdviceType, sizeof(struct saml1__AdviceType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml1__AdviceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AdviceType, SOAP_TYPE_saml1__AdviceType, sizeof(struct saml1__AdviceType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml1__DoNotCacheConditionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__DoNotCacheConditionType, sizeof(struct saml1__DoNotCacheConditionType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml1__DoNotCacheConditionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__DoNotCacheConditionType, SOAP_TYPE_saml1__DoNotCacheConditionType, sizeof(struct saml1__DoNotCacheConditionType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml1__AudienceRestrictionConditionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AudienceRestrictionConditionType, sizeof(struct saml1__AudienceRestrictionConditionType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:Audience", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAudience < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct saml1__AudienceRestrictionConditionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AudienceRestrictionConditionType, SOAP_TYPE_saml1__AudienceRestrictionConditionType, sizeof(struct saml1__AudienceRestrictionConditionType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml1__ConditionAbstractType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__ConditionAbstractType, sizeof(struct saml1__ConditionAbstractType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml1__ConditionAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__ConditionAbstractType, SOAP_TYPE_saml1__ConditionAbstractType, sizeof(struct saml1__ConditionAbstractType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct saml1__ConditionsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__ConditionsType, sizeof(struct saml1__ConditionsType), NULL, NULL, NULL, NULL);
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:			{	soap->error = SOAP_EOM;
./soapC.c:		else if (soap->error)
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml1__ConditionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__ConditionsType, SOAP_TYPE_saml1__ConditionsType, sizeof(struct saml1__ConditionsType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct saml1__AssertionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AssertionType, sizeof(struct saml1__AssertionType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_saml1__Conditions && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_saml1__Advice && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct saml1__AssertionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AssertionType, SOAP_TYPE_saml1__AssertionType, sizeof(struct saml1__AssertionType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_union_DerivedKeyTokenType && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Length && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_DerivedKeyTokenType))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsc__PropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsc__PropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__PropertiesType, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsc__DerivedKeyTokenType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__DerivedKeyTokenType, sizeof(struct wsc__DerivedKeyTokenType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Label && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag___DerivedKeyTokenType_sequence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsc__DerivedKeyTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__DerivedKeyTokenType, SOAP_TYPE_wsc__DerivedKeyTokenType, sizeof(struct wsc__DerivedKeyTokenType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsc__SecurityContextTokenType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Instance && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsc__SecurityContextTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__SecurityContextTokenType, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_DataReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_KeyReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct _xenc__ReferenceList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__size_ReferenceList < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct _xenc__ReferenceList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xenc__ReferenceList, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct xenc__EncryptionPropertyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct xenc__EncryptionPropertyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertyType, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct xenc__EncryptionPropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "xenc:EncryptionProperty", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeEncryptionProperty < 1))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct xenc__EncryptionPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertiesType, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct xenc__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct xenc__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__ReferenceType, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct xenc__AgreementMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__AgreementMethodType, sizeof(struct xenc__AgreementMethodType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_KA_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_OriginatorKeyInfo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RecipientKeyInfo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct xenc__AgreementMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__AgreementMethodType, SOAP_TYPE_xenc__AgreementMethodType, sizeof(struct xenc__AgreementMethodType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct xenc__EncryptedKeyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ReferenceList && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CarriedKeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CipherData))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct xenc__EncryptedKeyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedKeyType, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct xenc__EncryptedDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedDataType, sizeof(struct xenc__EncryptedDataType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CipherData))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct xenc__EncryptedDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedDataType, SOAP_TYPE_xenc__EncryptedDataType, sizeof(struct xenc__EncryptedDataType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct xenc__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ds__Transform && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ds__Transform > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct xenc__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__TransformsType, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct xenc__CipherReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct xenc__CipherReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherReferenceType, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct xenc__CipherDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CipherValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_CipherReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct xenc__CipherDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherDataType, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct xenc__EncryptionMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_KeySize && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_OAEPparams && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ds__DigestMethod && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct xenc__EncryptionMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionMethodType, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct xenc__EncryptedType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedType, sizeof(struct xenc__EncryptedType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CipherData))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct xenc__EncryptedType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedType, SOAP_TYPE_xenc__EncryptedType, sizeof(struct xenc__EncryptedType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ds__RSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Modulus || !a->Exponent))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ds__DSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Y || !a->P || !a->Q || !a->Seed || !a->PgenCounter))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ds__X509IssuerSerialType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_X509SerialNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->X509IssuerName || !a->X509SerialNumber))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ds__RetrievalMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ds__KeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ds__DigestMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ds__TransformType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _c14n__InclusiveNamespaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ds__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Transform", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ds__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->DigestMethod || !a->DigestValue))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ds__SignatureMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ds__CanonicalizationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ds__KeyInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_KeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_KeyValue && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_RetrievalMethod && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_X509Data && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ds__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyInfoType, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct ds__SignedInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_CanonicalizationMethod && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SignatureMethod && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Reference", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->CanonicalizationMethod || !a->SignatureMethod))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct ds__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignedInfoType, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ds__SignatureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SignedInfo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SignatureValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_KeyInfo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ds__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureType, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct ds__X509DataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_X509IssuerSerial && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_X509SKI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_X509SubjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_X509Certificate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_X509CRL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct ds__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509DataType, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsse__SecurityTokenReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_KeyIdentifier && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Embedded && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ds__X509Data && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsse__SecurityTokenReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__SecurityTokenReference, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsse__KeyIdentifier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsse__Embedded *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsse__Embedded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Embedded, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsse__Reference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsse__Reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Reference, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsse__BinarySecurityToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct _wsse__Password *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsse__UsernameToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Password && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Nonce && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsse__UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__UsernameToken, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct wsse__EncodedString *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__EncodedString, sizeof(struct wsse__EncodedString), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct _wsu__Timestamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct _wsu__Timestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsu__Timestamp, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct chan__ChannelInstanceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsa5__ProblemActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct wsa5__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsa5__MetadataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsa5__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsa5__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:			soap->mode |= SOAP_ENC_DIME;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
./soapC.c:	{	soap->error = SOAP_TYPE;
./soapC.c:	a = (struct _xop__Include *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
./soapC.c:		if (*soap->href != '#')
./soapC.c:			a = (struct _xop__Include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xop__Include, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsdd__ResolveMatches && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsdd__Resolve && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsdd__ProbeMatches && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsdd__Probe && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsdd__Bye && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsdd__Hello && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
./soapC.c:			{	soap->error = SOAP_OK;
./soapC.c:			if (soap_flag && soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsdd__AppSequenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__AppSequenceType, sizeof(struct wsdd__AppSequenceType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsdd__AppSequenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__AppSequenceType, SOAP_TYPE_wsdd__AppSequenceType, sizeof(struct wsdd__AppSequenceType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsdd__SigType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__SigType, sizeof(struct wsdd__SigType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsdd__SigType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__SigType, SOAP_TYPE_wsdd__SigType, sizeof(struct wsdd__SigType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsdd__SecurityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__SecurityType, sizeof(struct wsdd__SecurityType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Sig && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsdd__SecurityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__SecurityType, SOAP_TYPE_wsdd__SecurityType, sizeof(struct wsdd__SecurityType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct wsdd__ScopesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ScopesType, sizeof(struct wsdd__ScopesType), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsdd__ResolveMatchType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveMatchType, sizeof(struct wsdd__ResolveMatchType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsdd__ResolveMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveMatchType, SOAP_TYPE_wsdd__ResolveMatchType, sizeof(struct wsdd__ResolveMatchType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsdd__ResolveMatchesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveMatchesType, sizeof(struct wsdd__ResolveMatchesType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_ResolveMatch && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsdd__ResolveMatchesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveMatchesType, SOAP_TYPE_wsdd__ResolveMatchesType, sizeof(struct wsdd__ResolveMatchesType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsdd__ResolveType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveType, sizeof(struct wsdd__ResolveType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsdd__ResolveType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveType, SOAP_TYPE_wsdd__ResolveType, sizeof(struct wsdd__ResolveType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsdd__ProbeMatchType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeMatchType, sizeof(struct wsdd__ProbeMatchType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsdd__ProbeMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeMatchType, SOAP_TYPE_wsdd__ProbeMatchType, sizeof(struct wsdd__ProbeMatchType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:				return soap->error;
./soapC.c:	a = (struct wsdd__ProbeMatchesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeMatchesType, sizeof(struct wsdd__ProbeMatchesType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsdd:ProbeMatch", 1, NULL))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsdd__ProbeMatchesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeMatchesType, SOAP_TYPE_wsdd__ProbeMatchesType, sizeof(struct wsdd__ProbeMatchesType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsdd__ProbeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeType, sizeof(struct wsdd__ProbeType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsdd__ProbeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeType, SOAP_TYPE_wsdd__ProbeType, sizeof(struct wsdd__ProbeType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsdd__ByeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ByeType, sizeof(struct wsdd__ByeType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsdd__ByeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ByeType, SOAP_TYPE_wsdd__ByeType, sizeof(struct wsdd__ByeType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsdd__HelloType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__HelloType, sizeof(struct wsdd__HelloType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsdd__HelloType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__HelloType, SOAP_TYPE_wsdd__HelloType, sizeof(struct wsdd__HelloType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (soap->lang)
./soapC.c:		soap_set_attr(soap, "xml:lang", soap->lang, 1);
./soapC.c:		return soap->error;
./soapC.c:	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsnt__InvalidFilterFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__InvalidMessageContentExpressionFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__InvalidProducerPropertiesExpressionFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__InvalidTopicExpressionFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__MultipleTopicsSpecifiedFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__NoCurrentMessageOnTopicFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__NotifyMessageNotSupportedFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__PauseFailedFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_tev__PullMessagesFaultResponse && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsrfr__ResourceUnknownFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__ResumeFailedFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__SubscribeCreationFailedFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__TopicExpressionDialectUnknownFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__TopicNotSupportedFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__UnableToCreatePullPointFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__UnableToDestroyPullPointFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__UnableToDestroySubscriptionFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__UnableToGetMessagesFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__UnacceptableInitialTerminationTimeFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__UnacceptableTerminationTimeFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__UnrecognizedPolicyRequestFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsnt__UnsupportedPolicyRequestFault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	soap->mustUnderstand = 1;
./soapC.c:		return soap->error;
./soapC.c:	soap->mustUnderstand = 1;
./soapC.c:		return soap->error;
./soapC.c:	soap->mustUnderstand = 1;
./soapC.c:		return soap->error;
./soapC.c:	soap->mustUnderstand = 1;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	soap->mustUnderstand = 1;
./soapC.c:		return soap->error;
./soapC.c:	soap->mustUnderstand = 1;
./soapC.c:		return soap->error;
./soapC.c:	soap->mustUnderstand = 1;
./soapC.c:		return soap->error;
./soapC.c:	soap->mustUnderstand = 1;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	soap->mustUnderstand = 1;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_wsa__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_wsa__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsa__From && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsa__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsa__FaultTo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsa__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_wsa__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_wsdd__AppSequence && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct wsa__Relationship *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__Relationship, sizeof(struct wsa__Relationship), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:	if (!(a = (struct wsa__ServiceNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), NULL, NULL, NULL, NULL)))
./soapC.c:	*soap->id = '\0';
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsa__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsa__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferenceParametersType, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsa__ReferencePropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:	{	a = (struct wsa__ReferencePropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferencePropertiesType, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:			return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), NULL, NULL, NULL, NULL);
./soapC.c:	if (soap->body && !*soap->href)
./soapC.c:		{	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
./soapC.c:			if (soap_flag_ReferenceProperties && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_PortType && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap_flag_ServiceName && soap->error == SOAP_TAG_MISMATCH)
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
./soapC.c:			if (soap->error == SOAP_TAG_MISMATCH)
./soapC.c:				soap->error = soap_ignore_element(soap);
./soapC.c:			if (soap->error == SOAP_NO_TAG)
./soapC.c:			if (soap->error)
./soapC.c:		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address))
./soapC.c:		{	soap->error = SOAP_OCCURS;
./soapC.c:	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
./soapC.c:	{	soap->error = SOAP_OCCURS;
./soapC.c:	{	a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__EndpointReferenceType, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons5__X509v3Extension(soap, "ns5:X509v3Extension", &a->X509v3Extension, "ns5:X509v3Extension"))
./soapC.c:	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons5__BasicRequestAttribute(soap, "ns5:BasicRequestAttribute", &a->BasicRequestAttribute, "ns5:BasicRequestAttribute"))
./soapC.c:	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTo_ns5__CSRAttribute_anyAttribute(soap, "ns5:anyAttribute", &a->anyAttribute, ""))
./soapC.c:	if (!soap->error)
./soapC.c:		soap->error = SOAP_TAG_MISMATCH;
./soapC.c:	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__FtpContentConfigurationUploadImages(soap, "ns1:UploadImages", &a->UploadImages, "ns1:FtpContentConfigurationUploadImages"))
./soapC.c:	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__FtpContentConfigurationUploadFile(soap, "ns1:UploadFile", &a->UploadFile, "ns1:FtpContentConfigurationUploadFile"))
./soapC.c:	if (!soap->error)
./soapC.c:		soap->error = SOAP_TAG_MISMATCH;
./soapC.c:	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:	if (soap->error == SOAP_TAG_MISMATCH && soap_in_xsd__base64Binary(soap, "tmd:Binary", &a->Binary, "xsd:base64Binary"))
./soapC.c:	if (soap->error == SOAP_TAG_MISMATCH && soap_in_string(soap, "tmd:String", &a->String, "xsd:string"))
./soapC.c:	if (!soap->error)
./soapC.c:		soap->error = SOAP_TAG_MISMATCH;
./soapC.c:	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:	if (soap->error == SOAP_TAG_MISMATCH && soap_in_tt__ReferenceToken(soap, "tt:PresetToken", &a->PresetToken, "tt:ReferenceToken"))
./soapC.c:	if (soap->error == SOAP_TAG_MISMATCH && soap_in_xsd__boolean(soap, "tt:Home", &a->Home, "xsd:boolean"))
./soapC.c:	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZVector(soap, "tt:PTZPosition", &a->PTZPosition, "tt:PTZVector"))
./soapC.c:	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZPresetTourTypeExtension(soap, "tt:TypeExtension", &a->TypeExtension, "tt:PTZPresetTourTypeExtension"))
./soapC.c:	if (!soap->error)
./soapC.c:		soap->error = SOAP_TAG_MISMATCH;
./soapC.c:	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
./soapC.c:	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ULONG64(soap, "wsc:Generation", &a->Generation, "xsd:unsignedLong"))
./soapC.c:	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ULONG64(soap, "wsc:Offset", &a->Offset, "xsd:unsignedLong"))
./soapC.c:	if (!soap->error)
./soapC.c:		soap->error = SOAP_TAG_MISMATCH;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetMetadataSearchResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetMetadataSearchResultsResponse, sizeof(struct _tse__GetMetadataSearchResultsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetMetadataSearchResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetMetadataSearchResults, sizeof(struct _tse__GetMetadataSearchResults), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__FindMetadataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindMetadataResponse, sizeof(struct _tse__FindMetadataResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__FindMetadata **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindMetadata, sizeof(struct _tse__FindMetadata), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__EndSearchResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__EndSearchResponse, sizeof(struct _tse__EndSearchResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__EndSearch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__EndSearch, sizeof(struct _tse__EndSearch), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetSearchStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetSearchStateResponse, sizeof(struct _tse__GetSearchStateResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetSearchState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetSearchState, sizeof(struct _tse__GetSearchState), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetPTZPositionSearchResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse, sizeof(struct _tse__GetPTZPositionSearchResultsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetPTZPositionSearchResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetPTZPositionSearchResults, sizeof(struct _tse__GetPTZPositionSearchResults), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__FindPTZPositionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindPTZPositionResponse, sizeof(struct _tse__FindPTZPositionResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__FindPTZPosition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindPTZPosition, sizeof(struct _tse__FindPTZPosition), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetEventSearchResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetEventSearchResultsResponse, sizeof(struct _tse__GetEventSearchResultsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetEventSearchResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetEventSearchResults, sizeof(struct _tse__GetEventSearchResults), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__FindEventsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindEventsResponse, sizeof(struct _tse__FindEventsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__FindEvents **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindEvents, sizeof(struct _tse__FindEvents), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetRecordingSearchResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingSearchResultsResponse, sizeof(struct _tse__GetRecordingSearchResultsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetRecordingSearchResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingSearchResults, sizeof(struct _tse__GetRecordingSearchResults), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__FindRecordingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindRecordingsResponse, sizeof(struct _tse__FindRecordingsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__FindRecordings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindRecordings, sizeof(struct _tse__FindRecordings), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetMediaAttributesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetMediaAttributesResponse, sizeof(struct _tse__GetMediaAttributesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetMediaAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetMediaAttributes, sizeof(struct _tse__GetMediaAttributes), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetRecordingInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingInformationResponse, sizeof(struct _tse__GetRecordingInformationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetRecordingInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingInformation, sizeof(struct _tse__GetRecordingInformation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetRecordingSummaryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingSummaryResponse, sizeof(struct _tse__GetRecordingSummaryResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetRecordingSummary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingSummary, sizeof(struct _tse__GetRecordingSummary), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetServiceCapabilitiesResponse, sizeof(struct _tse__GetServiceCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tse__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetServiceCapabilities, sizeof(struct _tse__GetServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trv__GetReceiverStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceiverStateResponse, sizeof(struct _trv__GetReceiverStateResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trv__GetReceiverState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceiverState, sizeof(struct _trv__GetReceiverState), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trv__SetReceiverModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__SetReceiverModeResponse, sizeof(struct _trv__SetReceiverModeResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trv__SetReceiverMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__SetReceiverMode, sizeof(struct _trv__SetReceiverMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trv__ConfigureReceiverResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__ConfigureReceiverResponse, sizeof(struct _trv__ConfigureReceiverResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trv__ConfigureReceiver **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__ConfigureReceiver, sizeof(struct _trv__ConfigureReceiver), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trv__DeleteReceiverResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__DeleteReceiverResponse, sizeof(struct _trv__DeleteReceiverResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trv__DeleteReceiver **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__DeleteReceiver, sizeof(struct _trv__DeleteReceiver), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trv__CreateReceiverResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__CreateReceiverResponse, sizeof(struct _trv__CreateReceiverResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trv__CreateReceiver **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__CreateReceiver, sizeof(struct _trv__CreateReceiver), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trv__GetReceiverResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceiverResponse, sizeof(struct _trv__GetReceiverResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trv__GetReceiver **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceiver, sizeof(struct _trv__GetReceiver), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trv__GetReceiversResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceiversResponse, sizeof(struct _trv__GetReceiversResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trv__GetReceivers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceivers, sizeof(struct _trv__GetReceivers), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trv__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetServiceCapabilitiesResponse, sizeof(struct _trv__GetServiceCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trv__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetServiceCapabilities, sizeof(struct _trv__GetServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__DeleteOSDResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__DeleteOSDResponse, sizeof(struct _trt__DeleteOSDResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__DeleteOSD **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__DeleteOSD, sizeof(struct _trt__DeleteOSD), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__CreateOSDResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__CreateOSDResponse, sizeof(struct _trt__CreateOSDResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__CreateOSD **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__CreateOSD, sizeof(struct _trt__CreateOSD), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetOSDResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetOSDResponse, sizeof(struct _trt__SetOSDResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetOSD **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetOSD, sizeof(struct _trt__SetOSD), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetOSDOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetOSDOptionsResponse, sizeof(struct _trt__GetOSDOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetOSDOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetOSDOptions, sizeof(struct _trt__GetOSDOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetOSDResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetOSDResponse, sizeof(struct _trt__GetOSDResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetOSD **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetOSD, sizeof(struct _trt__GetOSD), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetOSDsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetOSDsResponse, sizeof(struct _trt__GetOSDsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetOSDs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetOSDs, sizeof(struct _trt__GetOSDs), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetVideoSourceModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoSourceModeResponse, sizeof(struct _trt__SetVideoSourceModeResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetVideoSourceMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoSourceMode, sizeof(struct _trt__SetVideoSourceMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoSourceModesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceModesResponse, sizeof(struct _trt__GetVideoSourceModesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoSourceModes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceModes, sizeof(struct _trt__GetVideoSourceModes), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetSnapshotUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetSnapshotUriResponse, sizeof(struct _trt__GetSnapshotUriResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetSnapshotUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetSnapshotUri, sizeof(struct _trt__GetSnapshotUri), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetSynchronizationPointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetSynchronizationPointResponse, sizeof(struct _trt__SetSynchronizationPointResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetSynchronizationPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetSynchronizationPoint, sizeof(struct _trt__SetSynchronizationPoint), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__StopMulticastStreamingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StopMulticastStreamingResponse, sizeof(struct _trt__StopMulticastStreamingResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__StopMulticastStreaming **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StopMulticastStreaming, sizeof(struct _trt__StopMulticastStreaming), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__StartMulticastStreamingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StartMulticastStreamingResponse, sizeof(struct _trt__StartMulticastStreamingResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__StartMulticastStreaming **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StartMulticastStreaming, sizeof(struct _trt__StartMulticastStreaming), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetStreamUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetStreamUriResponse, sizeof(struct _trt__GetStreamUriResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetStreamUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetStreamUri, sizeof(struct _trt__GetStreamUri), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstances **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstances), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioDecoderConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioDecoderConfigurationOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioDecoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions, sizeof(struct _trt__GetAudioDecoderConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioOutputConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse, sizeof(struct _trt__GetAudioOutputConfigurationOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions, sizeof(struct _trt__GetAudioOutputConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetMetadataConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse, sizeof(struct _trt__GetMetadataConfigurationOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetMetadataConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurationOptions, sizeof(struct _trt__GetMetadataConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioEncoderConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions, sizeof(struct _trt__GetAudioEncoderConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioSourceConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse, sizeof(struct _trt__GetAudioSourceConfigurationOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions, sizeof(struct _trt__GetAudioSourceConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoEncoderConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions, sizeof(struct _trt__GetVideoEncoderConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoSourceConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse, sizeof(struct _trt__GetVideoSourceConfigurationOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions, sizeof(struct _trt__GetVideoSourceConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetAudioDecoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse, sizeof(struct _trt__SetAudioDecoderConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioDecoderConfiguration, sizeof(struct _trt__SetAudioDecoderConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioOutputConfigurationResponse, sizeof(struct _trt__SetAudioOutputConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioOutputConfiguration, sizeof(struct _trt__SetAudioOutputConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetMetadataConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetMetadataConfigurationResponse, sizeof(struct _trt__SetMetadataConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetMetadataConfiguration, sizeof(struct _trt__SetMetadataConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse, sizeof(struct _trt__SetVideoAnalyticsConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoAnalyticsConfiguration, sizeof(struct _trt__SetVideoAnalyticsConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetAudioEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse, sizeof(struct _trt__SetAudioEncoderConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioEncoderConfiguration, sizeof(struct _trt__SetAudioEncoderConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioSourceConfigurationResponse, sizeof(struct _trt__SetAudioSourceConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioSourceConfiguration, sizeof(struct _trt__SetAudioSourceConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse, sizeof(struct _trt__SetVideoEncoderConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoEncoderConfiguration, sizeof(struct _trt__SetVideoEncoderConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoSourceConfigurationResponse, sizeof(struct _trt__SetVideoSourceConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__SetVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoSourceConfiguration, sizeof(struct _trt__SetVideoSourceConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetCompatibleAudioDecoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetCompatibleAudioDecoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetCompatibleAudioOutputConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioOutputConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetCompatibleAudioOutputConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations, sizeof(struct _trt__GetCompatibleAudioOutputConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetCompatibleMetadataConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse, sizeof(struct _trt__GetCompatibleMetadataConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetCompatibleMetadataConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations, sizeof(struct _trt__GetCompatibleMetadataConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetCompatibleVideoAnalyticsConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetCompatibleAudioSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioSourceConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetCompatibleAudioSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations, sizeof(struct _trt__GetCompatibleAudioSourceConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetCompatibleAudioEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetCompatibleAudioEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetCompatibleVideoSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoSourceConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetCompatibleVideoSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations, sizeof(struct _trt__GetCompatibleVideoSourceConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetCompatibleVideoEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetCompatibleVideoEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioDecoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse, sizeof(struct _trt__GetAudioDecoderConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfiguration, sizeof(struct _trt__GetAudioDecoderConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurationResponse, sizeof(struct _trt__GetAudioOutputConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfiguration, sizeof(struct _trt__GetAudioOutputConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetMetadataConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurationResponse, sizeof(struct _trt__GetMetadataConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfiguration, sizeof(struct _trt__GetMetadataConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse, sizeof(struct _trt__GetVideoAnalyticsConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration, sizeof(struct _trt__GetVideoAnalyticsConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse, sizeof(struct _trt__GetAudioEncoderConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfiguration, sizeof(struct _trt__GetAudioEncoderConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurationResponse, sizeof(struct _trt__GetAudioSourceConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfiguration, sizeof(struct _trt__GetAudioSourceConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse, sizeof(struct _trt__GetVideoEncoderConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfiguration, sizeof(struct _trt__GetVideoEncoderConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurationResponse, sizeof(struct _trt__GetVideoSourceConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfiguration, sizeof(struct _trt__GetVideoSourceConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioDecoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse, sizeof(struct _trt__GetAudioDecoderConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioDecoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurations, sizeof(struct _trt__GetAudioDecoderConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioOutputConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse, sizeof(struct _trt__GetAudioOutputConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioOutputConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurations, sizeof(struct _trt__GetAudioOutputConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetMetadataConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurationsResponse, sizeof(struct _trt__GetMetadataConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetMetadataConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurations, sizeof(struct _trt__GetMetadataConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoAnalyticsConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse, sizeof(struct _trt__GetVideoAnalyticsConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoAnalyticsConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations, sizeof(struct _trt__GetVideoAnalyticsConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurations, sizeof(struct _trt__GetAudioEncoderConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse, sizeof(struct _trt__GetAudioSourceConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurations, sizeof(struct _trt__GetAudioSourceConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurations, sizeof(struct _trt__GetVideoEncoderConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse, sizeof(struct _trt__GetVideoSourceConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurations, sizeof(struct _trt__GetVideoSourceConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__DeleteProfileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__DeleteProfileResponse, sizeof(struct _trt__DeleteProfileResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__DeleteProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__DeleteProfile, sizeof(struct _trt__DeleteProfile), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemoveAudioDecoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse, sizeof(struct _trt__RemoveAudioDecoderConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemoveAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration, sizeof(struct _trt__RemoveAudioDecoderConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemoveAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse, sizeof(struct _trt__RemoveAudioOutputConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemoveAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioOutputConfiguration, sizeof(struct _trt__RemoveAudioOutputConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemoveMetadataConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse, sizeof(struct _trt__RemoveMetadataConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemoveMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveMetadataConfiguration, sizeof(struct _trt__RemoveMetadataConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemoveVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse, sizeof(struct _trt__RemoveVideoAnalyticsConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemoveVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration, sizeof(struct _trt__RemoveVideoAnalyticsConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemovePTZConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemovePTZConfigurationResponse, sizeof(struct _trt__RemovePTZConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemovePTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemovePTZConfiguration, sizeof(struct _trt__RemovePTZConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemoveAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse, sizeof(struct _trt__RemoveAudioSourceConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemoveAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioSourceConfiguration, sizeof(struct _trt__RemoveAudioSourceConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemoveAudioEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse, sizeof(struct _trt__RemoveAudioEncoderConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemoveAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration, sizeof(struct _trt__RemoveAudioEncoderConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemoveVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse, sizeof(struct _trt__RemoveVideoSourceConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemoveVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoSourceConfiguration, sizeof(struct _trt__RemoveVideoSourceConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemoveVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse, sizeof(struct _trt__RemoveVideoEncoderConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__RemoveVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration, sizeof(struct _trt__RemoveVideoEncoderConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddAudioDecoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse, sizeof(struct _trt__AddAudioDecoderConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioDecoderConfiguration, sizeof(struct _trt__AddAudioDecoderConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse, sizeof(struct _trt__AddAudioOutputConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioOutputConfiguration, sizeof(struct _trt__AddAudioOutputConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddMetadataConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddMetadataConfigurationResponse, sizeof(struct _trt__AddMetadataConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddMetadataConfiguration, sizeof(struct _trt__AddMetadataConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse, sizeof(struct _trt__AddVideoAnalyticsConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration, sizeof(struct _trt__AddVideoAnalyticsConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddPTZConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddPTZConfigurationResponse, sizeof(struct _trt__AddPTZConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddPTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddPTZConfiguration, sizeof(struct _trt__AddPTZConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse, sizeof(struct _trt__AddAudioSourceConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioSourceConfiguration, sizeof(struct _trt__AddAudioSourceConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddAudioEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse, sizeof(struct _trt__AddAudioEncoderConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioEncoderConfiguration, sizeof(struct _trt__AddAudioEncoderConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse, sizeof(struct _trt__AddVideoSourceConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoSourceConfiguration, sizeof(struct _trt__AddVideoSourceConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse, sizeof(struct _trt__AddVideoEncoderConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__AddVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoEncoderConfiguration, sizeof(struct _trt__AddVideoEncoderConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetProfilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfilesResponse, sizeof(struct _trt__GetProfilesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetProfiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfiles, sizeof(struct _trt__GetProfiles), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetProfileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfileResponse, sizeof(struct _trt__GetProfileResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfile, sizeof(struct _trt__GetProfile), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__CreateProfileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__CreateProfileResponse, sizeof(struct _trt__CreateProfileResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__CreateProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__CreateProfile, sizeof(struct _trt__CreateProfile), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioOutputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputsResponse, sizeof(struct _trt__GetAudioOutputsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioOutputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputs, sizeof(struct _trt__GetAudioOutputs), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioSourcesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourcesResponse, sizeof(struct _trt__GetAudioSourcesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetAudioSources **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSources, sizeof(struct _trt__GetAudioSources), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoSourcesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourcesResponse, sizeof(struct _trt__GetVideoSourcesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetVideoSources **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSources, sizeof(struct _trt__GetVideoSources), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetServiceCapabilitiesResponse, sizeof(struct _trt__GetServiceCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trt__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetServiceCapabilities, sizeof(struct _trt__GetServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trp__SetReplayConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trp__SetReplayConfigurationResponse, sizeof(struct _trp__SetReplayConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trp__SetReplayConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trp__SetReplayConfiguration, sizeof(struct _trp__SetReplayConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trp__GetReplayConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trp__GetReplayConfigurationResponse, sizeof(struct _trp__GetReplayConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trp__GetReplayConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trp__GetReplayConfiguration, sizeof(struct _trp__GetReplayConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trp__GetReplayUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trp__GetReplayUriResponse, sizeof(struct _trp__GetReplayUriResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trp__GetReplayUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trp__GetReplayUri, sizeof(struct _trp__GetReplayUri), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trp__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trp__GetServiceCapabilitiesResponse, sizeof(struct _trp__GetServiceCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trp__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trp__GetServiceCapabilities, sizeof(struct _trp__GetServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetExportRecordedDataStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetExportRecordedDataStateResponse, sizeof(struct _trc__GetExportRecordedDataStateResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetExportRecordedDataState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetExportRecordedDataState, sizeof(struct _trc__GetExportRecordedDataState), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__StopExportRecordedDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__StopExportRecordedDataResponse, sizeof(struct _trc__StopExportRecordedDataResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__StopExportRecordedData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__StopExportRecordedData, sizeof(struct _trc__StopExportRecordedData), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__ExportRecordedDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__ExportRecordedDataResponse, sizeof(struct _trc__ExportRecordedDataResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__ExportRecordedData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__ExportRecordedData, sizeof(struct _trc__ExportRecordedData), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetRecordingJobStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingJobStateResponse, sizeof(struct _trc__GetRecordingJobStateResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetRecordingJobState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingJobState, sizeof(struct _trc__GetRecordingJobState), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__SetRecordingJobModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetRecordingJobModeResponse, sizeof(struct _trc__SetRecordingJobModeResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__SetRecordingJobMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetRecordingJobMode, sizeof(struct _trc__SetRecordingJobMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetRecordingJobConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse, sizeof(struct _trc__GetRecordingJobConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetRecordingJobConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingJobConfiguration, sizeof(struct _trc__GetRecordingJobConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__SetRecordingJobConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse, sizeof(struct _trc__SetRecordingJobConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__SetRecordingJobConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetRecordingJobConfiguration, sizeof(struct _trc__SetRecordingJobConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetRecordingJobsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingJobsResponse, sizeof(struct _trc__GetRecordingJobsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetRecordingJobs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingJobs, sizeof(struct _trc__GetRecordingJobs), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__DeleteRecordingJobResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__DeleteRecordingJobResponse, sizeof(struct _trc__DeleteRecordingJobResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__DeleteRecordingJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__DeleteRecordingJob, sizeof(struct _trc__DeleteRecordingJob), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__CreateRecordingJobResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__CreateRecordingJobResponse, sizeof(struct _trc__CreateRecordingJobResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__CreateRecordingJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__CreateRecordingJob, sizeof(struct _trc__CreateRecordingJob), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__SetTrackConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetTrackConfigurationResponse, sizeof(struct _trc__SetTrackConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__SetTrackConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetTrackConfiguration, sizeof(struct _trc__SetTrackConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetTrackConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetTrackConfigurationResponse, sizeof(struct _trc__GetTrackConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetTrackConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetTrackConfiguration, sizeof(struct _trc__GetTrackConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__DeleteTrackResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__DeleteTrackResponse, sizeof(struct _trc__DeleteTrackResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__DeleteTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__DeleteTrack, sizeof(struct _trc__DeleteTrack), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__CreateTrackResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__CreateTrackResponse, sizeof(struct _trc__CreateTrackResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__CreateTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__CreateTrack, sizeof(struct _trc__CreateTrack), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetRecordingOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingOptionsResponse, sizeof(struct _trc__GetRecordingOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetRecordingOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingOptions, sizeof(struct _trc__GetRecordingOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetRecordingConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingConfigurationResponse, sizeof(struct _trc__GetRecordingConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetRecordingConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingConfiguration, sizeof(struct _trc__GetRecordingConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__SetRecordingConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetRecordingConfigurationResponse, sizeof(struct _trc__SetRecordingConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__SetRecordingConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetRecordingConfiguration, sizeof(struct _trc__SetRecordingConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetRecordingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingsResponse, sizeof(struct _trc__GetRecordingsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetRecordings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordings, sizeof(struct _trc__GetRecordings), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__DeleteRecordingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__DeleteRecordingResponse, sizeof(struct _trc__DeleteRecordingResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__DeleteRecording **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__DeleteRecording, sizeof(struct _trc__DeleteRecording), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__CreateRecordingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__CreateRecordingResponse, sizeof(struct _trc__CreateRecordingResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__CreateRecording **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__CreateRecording, sizeof(struct _trc__CreateRecording), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetServiceCapabilitiesResponse, sizeof(struct _trc__GetServiceCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetServiceCapabilities, sizeof(struct _trc__GetServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetCompatibleConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse, sizeof(struct _tptz__GetCompatibleConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetCompatibleConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetCompatibleConfigurations, sizeof(struct _tptz__GetCompatibleConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__RemovePresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePresetTourResponse, sizeof(struct _tptz__RemovePresetTourResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__RemovePresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePresetTour, sizeof(struct _tptz__RemovePresetTour), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__OperatePresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__OperatePresetTourResponse, sizeof(struct _tptz__OperatePresetTourResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__OperatePresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__OperatePresetTour, sizeof(struct _tptz__OperatePresetTour), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__ModifyPresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ModifyPresetTourResponse, sizeof(struct _tptz__ModifyPresetTourResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__ModifyPresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ModifyPresetTour, sizeof(struct _tptz__ModifyPresetTour), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__CreatePresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__CreatePresetTourResponse, sizeof(struct _tptz__CreatePresetTourResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__CreatePresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__CreatePresetTour, sizeof(struct _tptz__CreatePresetTour), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetPresetTourOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, sizeof(struct _tptz__GetPresetTourOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetPresetTourOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTourOptions, sizeof(struct _tptz__GetPresetTourOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetPresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTourResponse, sizeof(struct _tptz__GetPresetTourResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetPresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTour, sizeof(struct _tptz__GetPresetTour), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetPresetToursResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetToursResponse, sizeof(struct _tptz__GetPresetToursResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetPresetTours **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTours, sizeof(struct _tptz__GetPresetTours), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__StopResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__StopResponse, sizeof(struct _tptz__StopResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__Stop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__Stop, sizeof(struct _tptz__Stop), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__AbsoluteMoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__AbsoluteMoveResponse, sizeof(struct _tptz__AbsoluteMoveResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__AbsoluteMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__AbsoluteMove, sizeof(struct _tptz__AbsoluteMove), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__SendAuxiliaryCommandResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, sizeof(struct _tptz__SendAuxiliaryCommandResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__SendAuxiliaryCommand **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SendAuxiliaryCommand, sizeof(struct _tptz__SendAuxiliaryCommand), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__RelativeMoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RelativeMoveResponse, sizeof(struct _tptz__RelativeMoveResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__RelativeMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RelativeMove, sizeof(struct _tptz__RelativeMove), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__ContinuousMoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ContinuousMoveResponse, sizeof(struct _tptz__ContinuousMoveResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__ContinuousMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ContinuousMove, sizeof(struct _tptz__ContinuousMove), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__SetHomePositionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetHomePositionResponse, sizeof(struct _tptz__SetHomePositionResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__SetHomePosition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetHomePosition, sizeof(struct _tptz__SetHomePosition), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GotoHomePositionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoHomePositionResponse, sizeof(struct _tptz__GotoHomePositionResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GotoHomePosition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoHomePosition, sizeof(struct _tptz__GotoHomePosition), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, sizeof(struct _tptz__GetConfigurationOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurationOptions, sizeof(struct _tptz__GetConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__SetConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetConfigurationResponse, sizeof(struct _tptz__SetConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__SetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetConfiguration, sizeof(struct _tptz__SetConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetNodeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNodeResponse, sizeof(struct _tptz__GetNodeResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetNode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNode, sizeof(struct _tptz__GetNode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetNodesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNodesResponse, sizeof(struct _tptz__GetNodesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetNodes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNodes, sizeof(struct _tptz__GetNodes), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurationResponse, sizeof(struct _tptz__GetConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfiguration, sizeof(struct _tptz__GetConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetStatusResponse, sizeof(struct _tptz__GetStatusResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetStatus, sizeof(struct _tptz__GetStatus), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GotoPresetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoPresetResponse, sizeof(struct _tptz__GotoPresetResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GotoPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoPreset, sizeof(struct _tptz__GotoPreset), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__RemovePresetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePresetResponse, sizeof(struct _tptz__RemovePresetResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__RemovePreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePreset, sizeof(struct _tptz__RemovePreset), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__SetPresetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetPresetResponse, sizeof(struct _tptz__SetPresetResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__SetPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetPreset, sizeof(struct _tptz__SetPreset), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetPresetsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetsResponse, sizeof(struct _tptz__GetPresetsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetPresets **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresets, sizeof(struct _tptz__GetPresets), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurationsResponse, sizeof(struct _tptz__GetConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurations, sizeof(struct _tptz__GetConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, sizeof(struct _tptz__GetServiceCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tptz__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetServiceCapabilities, sizeof(struct _tptz__GetServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__SendReceiveSerialCommandResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SendReceiveSerialCommandResponse, sizeof(struct _tmd__SendReceiveSerialCommandResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__SendReceiveSerialCommand **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SendReceiveSerialCommand, sizeof(struct _tmd__SendReceiveSerialCommand), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetSerialPortConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse, sizeof(struct _tmd__GetSerialPortConfigurationOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetSerialPortConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetSerialPortConfigurationOptions, sizeof(struct _tmd__GetSerialPortConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__SetSerialPortConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetSerialPortConfigurationResponse, sizeof(struct _tmd__SetSerialPortConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__SetSerialPortConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetSerialPortConfiguration, sizeof(struct _tmd__SetSerialPortConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetSerialPortConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetSerialPortConfigurationResponse, sizeof(struct _tmd__GetSerialPortConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetSerialPortConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetSerialPortConfiguration, sizeof(struct _tmd__GetSerialPortConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetSerialPortsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetSerialPortsResponse, sizeof(struct _tmd__GetSerialPortsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetSerialPorts **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetSerialPorts, sizeof(struct _tmd__GetSerialPorts), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__SetDigitalInputConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse, sizeof(struct _tmd__SetDigitalInputConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__SetDigitalInputConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetDigitalInputConfigurations, sizeof(struct _tmd__SetDigitalInputConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetDigitalInputConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse, sizeof(struct _tmd__GetDigitalInputConfigurationOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetDigitalInputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions, sizeof(struct _tmd__GetDigitalInputConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetDigitalInputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetDigitalInputsResponse, sizeof(struct _tmd__GetDigitalInputsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetDigitalInputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetDigitalInputs, sizeof(struct _tmd__GetDigitalInputs), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__SetRelayOutputSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetRelayOutputSettingsResponse, sizeof(struct _tmd__SetRelayOutputSettingsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__SetRelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetRelayOutputSettings, sizeof(struct _tmd__SetRelayOutputSettings), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetAudioOutputConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse, sizeof(struct _tmd__GetAudioOutputConfigurationOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetAudioOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions, sizeof(struct _tmd__GetAudioOutputConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetAudioSourceConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse, sizeof(struct _tmd__GetAudioSourceConfigurationOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetAudioSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions, sizeof(struct _tmd__GetAudioSourceConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetVideoOutputConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse, sizeof(struct _tmd__GetVideoOutputConfigurationOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetVideoOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions, sizeof(struct _tmd__GetVideoOutputConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetVideoSourceConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse, sizeof(struct _tmd__GetVideoSourceConfigurationOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetVideoSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions, sizeof(struct _tmd__GetVideoSourceConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__SetAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse, sizeof(struct _tmd__SetAudioOutputConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__SetAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetAudioOutputConfiguration, sizeof(struct _tmd__SetAudioOutputConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__SetAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse, sizeof(struct _tmd__SetAudioSourceConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__SetAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetAudioSourceConfiguration, sizeof(struct _tmd__SetAudioSourceConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__SetVideoOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse, sizeof(struct _tmd__SetVideoOutputConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__SetVideoOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetVideoOutputConfiguration, sizeof(struct _tmd__SetVideoOutputConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__SetVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse, sizeof(struct _tmd__SetVideoSourceConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__SetVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetVideoSourceConfiguration, sizeof(struct _tmd__SetVideoSourceConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse, sizeof(struct _tmd__GetAudioOutputConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetAudioOutputConfiguration, sizeof(struct _tmd__GetAudioOutputConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse, sizeof(struct _tmd__GetAudioSourceConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetAudioSourceConfiguration, sizeof(struct _tmd__GetAudioSourceConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetVideoOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse, sizeof(struct _tmd__GetVideoOutputConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetVideoOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoOutputConfiguration, sizeof(struct _tmd__GetVideoOutputConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse, sizeof(struct _tmd__GetVideoSourceConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoSourceConfiguration, sizeof(struct _tmd__GetVideoSourceConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetVideoOutputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoOutputsResponse, sizeof(struct _tmd__GetVideoOutputsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetVideoOutputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoOutputs, sizeof(struct _tmd__GetVideoOutputs), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tmd__GetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__GetResponse, sizeof(struct tmd__GetResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tmd__Get **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__Get, sizeof(struct tmd__Get), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetRelayOutputOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetRelayOutputOptionsResponse, sizeof(struct _tmd__GetRelayOutputOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetRelayOutputOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetRelayOutputOptions, sizeof(struct _tmd__GetRelayOutputOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetServiceCapabilitiesResponse, sizeof(struct _tmd__GetServiceCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tmd__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetServiceCapabilities, sizeof(struct _tmd__GetServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__DeletePaneConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__DeletePaneConfigurationResponse, sizeof(struct _tls__DeletePaneConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__DeletePaneConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__DeletePaneConfiguration, sizeof(struct _tls__DeletePaneConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__CreatePaneConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__CreatePaneConfigurationResponse, sizeof(struct _tls__CreatePaneConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__CreatePaneConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__CreatePaneConfiguration, sizeof(struct _tls__CreatePaneConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__SetPaneConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__SetPaneConfigurationResponse, sizeof(struct _tls__SetPaneConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__SetPaneConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__SetPaneConfiguration, sizeof(struct _tls__SetPaneConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__SetPaneConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__SetPaneConfigurationsResponse, sizeof(struct _tls__SetPaneConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__SetPaneConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__SetPaneConfigurations, sizeof(struct _tls__SetPaneConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__GetPaneConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetPaneConfigurationResponse, sizeof(struct _tls__GetPaneConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__GetPaneConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetPaneConfiguration, sizeof(struct _tls__GetPaneConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__GetPaneConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetPaneConfigurationsResponse, sizeof(struct _tls__GetPaneConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__GetPaneConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetPaneConfigurations, sizeof(struct _tls__GetPaneConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__GetDisplayOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetDisplayOptionsResponse, sizeof(struct _tls__GetDisplayOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__GetDisplayOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetDisplayOptions, sizeof(struct _tls__GetDisplayOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__SetLayoutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__SetLayoutResponse, sizeof(struct _tls__SetLayoutResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__SetLayout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__SetLayout, sizeof(struct _tls__SetLayout), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__GetLayoutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetLayoutResponse, sizeof(struct _tls__GetLayoutResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__GetLayout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetLayout, sizeof(struct _tls__GetLayout), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetServiceCapabilitiesResponse, sizeof(struct _tls__GetServiceCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tls__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetServiceCapabilities, sizeof(struct _tls__GetServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__SetCurrentPresetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__SetCurrentPresetResponse, sizeof(struct _timg__SetCurrentPresetResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__SetCurrentPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__SetCurrentPreset, sizeof(struct _timg__SetCurrentPreset), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__GetCurrentPresetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetCurrentPresetResponse, sizeof(struct _timg__GetCurrentPresetResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__GetCurrentPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetCurrentPreset, sizeof(struct _timg__GetCurrentPreset), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__GetPresetsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetPresetsResponse, sizeof(struct _timg__GetPresetsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__GetPresets **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetPresets, sizeof(struct _timg__GetPresets), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__GetMoveOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetMoveOptionsResponse, sizeof(struct _timg__GetMoveOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__GetMoveOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetMoveOptions, sizeof(struct _timg__GetMoveOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__GetStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetStatusResponse, sizeof(struct _timg__GetStatusResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__GetStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetStatus, sizeof(struct _timg__GetStatus), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__StopResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__StopResponse, sizeof(struct _timg__StopResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__Stop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__Stop, sizeof(struct _timg__Stop), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__MoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__MoveResponse, sizeof(struct _timg__MoveResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__Move **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__Move, sizeof(struct _timg__Move), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__GetOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetOptionsResponse, sizeof(struct _timg__GetOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__GetOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetOptions, sizeof(struct _timg__GetOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__SetImagingSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__SetImagingSettingsResponse, sizeof(struct _timg__SetImagingSettingsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__SetImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__SetImagingSettings, sizeof(struct _timg__SetImagingSettings), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__GetImagingSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetImagingSettingsResponse, sizeof(struct _timg__GetImagingSettingsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__GetImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetImagingSettings, sizeof(struct _timg__GetImagingSettings), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, sizeof(struct _timg__GetServiceCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _timg__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetServiceCapabilities, sizeof(struct _timg__GetServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__ResumeSubscriptionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(struct _wsnt__ResumeSubscriptionResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__ResumeSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(struct _wsnt__ResumeSubscription), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__PauseSubscriptionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(struct _wsnt__PauseSubscriptionResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__PauseSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseSubscription, sizeof(struct _wsnt__PauseSubscription), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__CreatePullPointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(struct _wsnt__CreatePullPointResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__CreatePullPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(struct _wsnt__CreatePullPoint), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__DestroyPullPointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(struct _wsnt__DestroyPullPointResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__DestroyPullPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(struct _wsnt__DestroyPullPoint), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__GetMessagesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(struct _wsnt__GetMessagesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__GetMessages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__GetMessages, sizeof(struct _wsnt__GetMessages), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__Notify **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Notify, sizeof(struct _wsnt__Notify), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__GetCurrentMessageResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(struct _wsnt__GetCurrentMessageResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__GetCurrentMessage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(struct _wsnt__GetCurrentMessage), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__SubscribeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(struct _wsnt__SubscribeResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__Subscribe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Subscribe, sizeof(struct _wsnt__Subscribe), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnsubscribeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(struct _wsnt__UnsubscribeResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__Unsubscribe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Unsubscribe, sizeof(struct _wsnt__Unsubscribe), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__RenewResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__RenewResponse, sizeof(struct _wsnt__RenewResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__Renew **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Renew, sizeof(struct _wsnt__Renew), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tev__GetEventPropertiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__GetEventPropertiesResponse, sizeof(struct _tev__GetEventPropertiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tev__GetEventProperties **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__GetEventProperties, sizeof(struct _tev__GetEventProperties), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tev__CreatePullPointSubscriptionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, sizeof(struct _tev__CreatePullPointSubscriptionResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tev__CreatePullPointSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__CreatePullPointSubscription, sizeof(struct _tev__CreatePullPointSubscription), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tev__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, sizeof(struct _tev__GetServiceCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tev__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__GetServiceCapabilities, sizeof(struct _tev__GetServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tev__SetSynchronizationPointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__SetSynchronizationPointResponse, sizeof(struct _tev__SetSynchronizationPointResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tev__SetSynchronizationPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__SetSynchronizationPoint, sizeof(struct _tev__SetSynchronizationPoint), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tev__SeekResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__SeekResponse, sizeof(struct _tev__SeekResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tev__Seek **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__Seek, sizeof(struct _tev__Seek), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tev__PullMessagesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__PullMessagesResponse, sizeof(struct _tev__PullMessagesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tev__PullMessages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__PullMessages, sizeof(struct _tev__PullMessages), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__DeleteGeoLocationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteGeoLocationResponse, sizeof(struct _tds__DeleteGeoLocationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__DeleteGeoLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteGeoLocation, sizeof(struct _tds__DeleteGeoLocation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetGeoLocationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetGeoLocationResponse, sizeof(struct _tds__SetGeoLocationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetGeoLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetGeoLocation, sizeof(struct _tds__SetGeoLocation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetGeoLocationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetGeoLocationResponse, sizeof(struct _tds__GetGeoLocationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetGeoLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetGeoLocation, sizeof(struct _tds__GetGeoLocation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__DeleteStorageConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, sizeof(struct _tds__DeleteStorageConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__DeleteStorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteStorageConfiguration, sizeof(struct _tds__DeleteStorageConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetStorageConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetStorageConfigurationResponse, sizeof(struct _tds__SetStorageConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetStorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetStorageConfiguration, sizeof(struct _tds__SetStorageConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetStorageConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetStorageConfigurationResponse, sizeof(struct _tds__GetStorageConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetStorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetStorageConfiguration, sizeof(struct _tds__GetStorageConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__CreateStorageConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateStorageConfigurationResponse, sizeof(struct _tds__CreateStorageConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__CreateStorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateStorageConfiguration, sizeof(struct _tds__CreateStorageConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetStorageConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetStorageConfigurationsResponse, sizeof(struct _tds__GetStorageConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetStorageConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetStorageConfigurations, sizeof(struct _tds__GetStorageConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__StartSystemRestoreResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(struct _tds__StartSystemRestoreResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__StartSystemRestore **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartSystemRestore, sizeof(struct _tds__StartSystemRestore), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__StartFirmwareUpgradeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(struct _tds__StartFirmwareUpgradeResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__StartFirmwareUpgrade **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(struct _tds__StartFirmwareUpgrade), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetSystemUrisResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(struct _tds__GetSystemUrisResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetSystemUris **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemUris, sizeof(struct _tds__GetSystemUris), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__ScanAvailableDot11NetworksResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(struct _tds__ScanAvailableDot11NetworksResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__ScanAvailableDot11Networks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(struct _tds__ScanAvailableDot11Networks), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDot11StatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(struct _tds__GetDot11StatusResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDot11Status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11Status, sizeof(struct _tds__GetDot11Status), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDot11CapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(struct _tds__GetDot11CapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDot11Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(struct _tds__GetDot11Capabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__DeleteDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(struct _tds__DeleteDot1XConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__DeleteDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(struct _tds__DeleteDot1XConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDot1XConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, sizeof(struct _tds__GetDot1XConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDot1XConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(struct _tds__GetDot1XConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfigurationResponse, sizeof(struct _tds__GetDot1XConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(struct _tds__GetDot1XConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDot1XConfigurationResponse, sizeof(struct _tds__SetDot1XConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(struct _tds__SetDot1XConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__CreateDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, sizeof(struct _tds__CreateDot1XConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__CreateDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(struct _tds__CreateDot1XConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__LoadCACertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCACertificatesResponse, sizeof(struct _tds__LoadCACertificatesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__LoadCACertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCACertificates, sizeof(struct _tds__LoadCACertificates), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetCertificateInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificateInformationResponse, sizeof(struct _tds__GetCertificateInformationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetCertificateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificateInformation, sizeof(struct _tds__GetCertificateInformation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__LoadCertificateWithPrivateKeyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, sizeof(struct _tds__LoadCertificateWithPrivateKeyResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__LoadCertificateWithPrivateKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(struct _tds__LoadCertificateWithPrivateKey), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetCACertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCACertificatesResponse, sizeof(struct _tds__GetCACertificatesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetCACertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCACertificates, sizeof(struct _tds__GetCACertificates), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SendAuxiliaryCommandResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(struct _tds__SendAuxiliaryCommandResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SendAuxiliaryCommand **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(struct _tds__SendAuxiliaryCommand), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetRelayOutputStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(struct _tds__SetRelayOutputStateResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetRelayOutputState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputState, sizeof(struct _tds__SetRelayOutputState), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetRelayOutputSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(struct _tds__SetRelayOutputSettingsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetRelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(struct _tds__SetRelayOutputSettings), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetRelayOutputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(struct _tds__GetRelayOutputsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetRelayOutputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRelayOutputs, sizeof(struct _tds__GetRelayOutputs), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetClientCertificateModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetClientCertificateModeResponse, sizeof(struct _tds__SetClientCertificateModeResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetClientCertificateMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(struct _tds__SetClientCertificateMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetClientCertificateModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetClientCertificateModeResponse, sizeof(struct _tds__GetClientCertificateModeResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetClientCertificateMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(struct _tds__GetClientCertificateMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__LoadCertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificatesResponse, sizeof(struct _tds__LoadCertificatesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__LoadCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificates, sizeof(struct _tds__LoadCertificates), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetPkcs10RequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetPkcs10RequestResponse, sizeof(struct _tds__GetPkcs10RequestResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetPkcs10Request **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetPkcs10Request, sizeof(struct _tds__GetPkcs10Request), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__DeleteCertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteCertificatesResponse, sizeof(struct _tds__DeleteCertificatesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__DeleteCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteCertificates, sizeof(struct _tds__DeleteCertificates), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetCertificatesStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetCertificatesStatusResponse, sizeof(struct _tds__SetCertificatesStatusResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetCertificatesStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(struct _tds__SetCertificatesStatus), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetCertificatesStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificatesStatusResponse, sizeof(struct _tds__GetCertificatesStatusResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetCertificatesStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(struct _tds__GetCertificatesStatus), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetCertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificatesResponse, sizeof(struct _tds__GetCertificatesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificates, sizeof(struct _tds__GetCertificates), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__CreateCertificateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateCertificateResponse, sizeof(struct _tds__CreateCertificateResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__CreateCertificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateCertificate, sizeof(struct _tds__CreateCertificate), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetAccessPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetAccessPolicyResponse, sizeof(struct _tds__SetAccessPolicyResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetAccessPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetAccessPolicy, sizeof(struct _tds__SetAccessPolicy), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetAccessPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetAccessPolicyResponse, sizeof(struct _tds__GetAccessPolicyResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetAccessPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetAccessPolicy, sizeof(struct _tds__GetAccessPolicy), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__RemoveIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(struct _tds__RemoveIPAddressFilterResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__RemoveIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(struct _tds__RemoveIPAddressFilter), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__AddIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(struct _tds__AddIPAddressFilterResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__AddIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(struct _tds__AddIPAddressFilter), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(struct _tds__SetIPAddressFilterResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(struct _tds__SetIPAddressFilter), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(struct _tds__GetIPAddressFilterResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(struct _tds__GetIPAddressFilter), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetZeroConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetZeroConfigurationResponse, sizeof(struct _tds__SetZeroConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(struct _tds__SetZeroConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetZeroConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetZeroConfigurationResponse, sizeof(struct _tds__GetZeroConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(struct _tds__GetZeroConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetNetworkDefaultGatewayResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(struct _tds__SetNetworkDefaultGatewayResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetNetworkDefaultGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(struct _tds__SetNetworkDefaultGateway), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetNetworkDefaultGatewayResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(struct _tds__GetNetworkDefaultGatewayResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetNetworkDefaultGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(struct _tds__GetNetworkDefaultGateway), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetNetworkProtocolsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(struct _tds__SetNetworkProtocolsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetNetworkProtocols **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(struct _tds__SetNetworkProtocols), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetNetworkProtocolsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(struct _tds__GetNetworkProtocolsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetNetworkProtocols **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(struct _tds__GetNetworkProtocols), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetNetworkInterfacesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(struct _tds__SetNetworkInterfacesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetNetworkInterfaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(struct _tds__SetNetworkInterfaces), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetNetworkInterfacesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(struct _tds__GetNetworkInterfacesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetNetworkInterfaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(struct _tds__GetNetworkInterfaces), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetDynamicDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(struct _tds__SetDynamicDNSResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetDynamicDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDynamicDNS, sizeof(struct _tds__SetDynamicDNS), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDynamicDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(struct _tds__GetDynamicDNSResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDynamicDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDynamicDNS, sizeof(struct _tds__GetDynamicDNS), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetNTPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNTPResponse, sizeof(struct _tds__SetNTPResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetNTP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNTP, sizeof(struct _tds__SetNTP), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetNTPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNTPResponse, sizeof(struct _tds__GetNTPResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetNTP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNTP, sizeof(struct _tds__GetNTP), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDNSResponse, sizeof(struct _tds__SetDNSResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDNS, sizeof(struct _tds__SetDNS), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDNSResponse, sizeof(struct _tds__GetDNSResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDNS, sizeof(struct _tds__GetDNS), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetHostnameFromDHCPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(struct _tds__SetHostnameFromDHCPResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetHostnameFromDHCP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(struct _tds__SetHostnameFromDHCP), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetHostnameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostnameResponse, sizeof(struct _tds__SetHostnameResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetHostname **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostname, sizeof(struct _tds__SetHostname), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetHostnameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetHostnameResponse, sizeof(struct _tds__GetHostnameResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetHostname **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetHostname, sizeof(struct _tds__GetHostname), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetDPAddressesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDPAddressesResponse, sizeof(struct _tds__SetDPAddressesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetDPAddresses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDPAddresses, sizeof(struct _tds__SetDPAddresses), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(struct _tds__GetCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCapabilities, sizeof(struct _tds__GetCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetWsdlUrlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(struct _tds__GetWsdlUrlResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetWsdlUrl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetWsdlUrl, sizeof(struct _tds__GetWsdlUrl), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetUserResponse, sizeof(struct _tds__SetUserResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetUser, sizeof(struct _tds__SetUser), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__DeleteUsersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(struct _tds__DeleteUsersResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__DeleteUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteUsers, sizeof(struct _tds__DeleteUsers), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__CreateUsersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateUsersResponse, sizeof(struct _tds__CreateUsersResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__CreateUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateUsers, sizeof(struct _tds__CreateUsers), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetUsersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetUsersResponse, sizeof(struct _tds__GetUsersResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetUsers, sizeof(struct _tds__GetUsers), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetRemoteUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteUserResponse, sizeof(struct _tds__SetRemoteUserResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetRemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteUser, sizeof(struct _tds__SetRemoteUser), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetRemoteUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteUserResponse, sizeof(struct _tds__GetRemoteUserResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetRemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteUser, sizeof(struct _tds__GetRemoteUser), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetEndpointReferenceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetEndpointReferenceResponse, sizeof(struct _tds__GetEndpointReferenceResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetEndpointReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetEndpointReference, sizeof(struct _tds__GetEndpointReference), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDPAddressesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDPAddressesResponse, sizeof(struct _tds__GetDPAddressesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDPAddresses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDPAddresses, sizeof(struct _tds__GetDPAddresses), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetRemoteDiscoveryModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, sizeof(struct _tds__SetRemoteDiscoveryModeResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetRemoteDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(struct _tds__SetRemoteDiscoveryMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetRemoteDiscoveryModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, sizeof(struct _tds__GetRemoteDiscoveryModeResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetRemoteDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(struct _tds__GetRemoteDiscoveryMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetDiscoveryModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDiscoveryModeResponse, sizeof(struct _tds__SetDiscoveryModeResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(struct _tds__SetDiscoveryMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDiscoveryModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDiscoveryModeResponse, sizeof(struct _tds__GetDiscoveryModeResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(struct _tds__GetDiscoveryMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__RemoveScopesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveScopesResponse, sizeof(struct _tds__RemoveScopesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__RemoveScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveScopes, sizeof(struct _tds__RemoveScopes), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__AddScopesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddScopesResponse, sizeof(struct _tds__AddScopesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__AddScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddScopes, sizeof(struct _tds__AddScopes), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetScopesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetScopesResponse, sizeof(struct _tds__SetScopesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetScopes, sizeof(struct _tds__SetScopes), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetScopesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetScopesResponse, sizeof(struct _tds__GetScopesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetScopes, sizeof(struct _tds__GetScopes), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetSystemSupportInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemSupportInformationResponse, sizeof(struct _tds__GetSystemSupportInformationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetSystemSupportInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(struct _tds__GetSystemSupportInformation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetSystemLogResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemLogResponse, sizeof(struct _tds__GetSystemLogResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetSystemLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemLog, sizeof(struct _tds__GetSystemLog), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetSystemBackupResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(struct _tds__GetSystemBackupResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetSystemBackup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemBackup, sizeof(struct _tds__GetSystemBackup), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__RestoreSystemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RestoreSystemResponse, sizeof(struct _tds__RestoreSystemResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__RestoreSystem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RestoreSystem, sizeof(struct _tds__RestoreSystem), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SystemRebootResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SystemRebootResponse, sizeof(struct _tds__SystemRebootResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SystemReboot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SystemReboot, sizeof(struct _tds__SystemReboot), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__UpgradeSystemFirmwareResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, sizeof(struct _tds__UpgradeSystemFirmwareResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__UpgradeSystemFirmware **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(struct _tds__UpgradeSystemFirmware), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetSystemFactoryDefaultResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(struct _tds__SetSystemFactoryDefaultResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetSystemFactoryDefault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(struct _tds__SetSystemFactoryDefault), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetSystemDateAndTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(struct _tds__GetSystemDateAndTimeResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(struct _tds__GetSystemDateAndTime), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetSystemDateAndTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(struct _tds__SetSystemDateAndTimeResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__SetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(struct _tds__SetSystemDateAndTime), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDeviceInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(struct _tds__GetDeviceInformationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetDeviceInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(struct _tds__GetDeviceInformation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(struct _tds__GetServiceCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(struct _tds__GetServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetServicesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServicesResponse, sizeof(struct _tds__GetServicesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetServices **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServices, sizeof(struct _tds__GetServices), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__ModifyAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse, sizeof(struct _tan__ModifyAnalyticsModulesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__ModifyAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__ModifyAnalyticsModules, sizeof(struct _tan__ModifyAnalyticsModules), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__GetAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetAnalyticsModulesResponse, sizeof(struct _tan__GetAnalyticsModulesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__GetAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetAnalyticsModules, sizeof(struct _tan__GetAnalyticsModules), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__DeleteAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse, sizeof(struct _tan__DeleteAnalyticsModulesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__DeleteAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__DeleteAnalyticsModules, sizeof(struct _tan__DeleteAnalyticsModules), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__CreateAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__CreateAnalyticsModulesResponse, sizeof(struct _tan__CreateAnalyticsModulesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__CreateAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__CreateAnalyticsModules, sizeof(struct _tan__CreateAnalyticsModules), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__GetSupportedAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse, sizeof(struct _tan__GetSupportedAnalyticsModulesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__GetSupportedAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetSupportedAnalyticsModules, sizeof(struct _tan__GetSupportedAnalyticsModules), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetServiceCapabilitiesResponse, sizeof(struct _tan__GetServiceCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetServiceCapabilities, sizeof(struct _tan__GetServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__ModifyRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__ModifyRulesResponse, sizeof(struct _tan__ModifyRulesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__ModifyRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__ModifyRules, sizeof(struct _tan__ModifyRules), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__GetRuleOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetRuleOptionsResponse, sizeof(struct _tan__GetRuleOptionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__GetRuleOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetRuleOptions, sizeof(struct _tan__GetRuleOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__GetRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetRulesResponse, sizeof(struct _tan__GetRulesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__GetRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetRules, sizeof(struct _tan__GetRules), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__DeleteRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__DeleteRulesResponse, sizeof(struct _tan__DeleteRulesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__DeleteRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__DeleteRules, sizeof(struct _tan__DeleteRules), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__CreateRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__CreateRulesResponse, sizeof(struct _tan__CreateRulesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__CreateRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__CreateRules, sizeof(struct _tan__CreateRules), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__GetSupportedRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetSupportedRulesResponse, sizeof(struct _tan__GetSupportedRulesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tan__GetSupportedRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetSupportedRules, sizeof(struct _tan__GetSupportedRules), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetAnalyticsStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsStateResponse, sizeof(struct _tad__GetAnalyticsStateResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetAnalyticsState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsState, sizeof(struct _tad__GetAnalyticsState), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__DeleteAnalyticsEngineInputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse, sizeof(struct _tad__DeleteAnalyticsEngineInputsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__DeleteAnalyticsEngineInputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs, sizeof(struct _tad__DeleteAnalyticsEngineInputs), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__CreateAnalyticsEngineInputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse, sizeof(struct _tad__CreateAnalyticsEngineInputsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__CreateAnalyticsEngineInputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__CreateAnalyticsEngineInputs, sizeof(struct _tad__CreateAnalyticsEngineInputs), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse, sizeof(struct _tad__GetVideoAnalyticsConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetVideoAnalyticsConfiguration, sizeof(struct _tad__GetVideoAnalyticsConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetAnalyticsDeviceStreamUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse, sizeof(struct _tad__GetAnalyticsDeviceStreamUriResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetAnalyticsDeviceStreamUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri, sizeof(struct _tad__GetAnalyticsDeviceStreamUri), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineInputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse, sizeof(struct _tad__GetAnalyticsEngineInputsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineInputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineInputs, sizeof(struct _tad__GetAnalyticsEngineInputs), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineInputResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineInputResponse, sizeof(struct _tad__GetAnalyticsEngineInputResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineInput, sizeof(struct _tad__GetAnalyticsEngineInput), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__SetAnalyticsEngineInputResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__SetAnalyticsEngineInputResponse, sizeof(struct _tad__SetAnalyticsEngineInputResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__SetAnalyticsEngineInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__SetAnalyticsEngineInput, sizeof(struct _tad__SetAnalyticsEngineInput), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__SetVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse, sizeof(struct _tad__SetVideoAnalyticsConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__SetVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__SetVideoAnalyticsConfiguration, sizeof(struct _tad__SetVideoAnalyticsConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetAnalyticsEnginesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEnginesResponse, sizeof(struct _tad__GetAnalyticsEnginesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngines **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngines, sizeof(struct _tad__GetAnalyticsEngines), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineResponse, sizeof(struct _tad__GetAnalyticsEngineResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngine **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngine, sizeof(struct _tad__GetAnalyticsEngine), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineControlsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse, sizeof(struct _tad__GetAnalyticsEngineControlsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineControls **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineControls, sizeof(struct _tad__GetAnalyticsEngineControls), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineControlResponse, sizeof(struct _tad__GetAnalyticsEngineControlResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetAnalyticsEngineControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineControl, sizeof(struct _tad__GetAnalyticsEngineControl), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__SetAnalyticsEngineControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__SetAnalyticsEngineControlResponse, sizeof(struct _tad__SetAnalyticsEngineControlResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__SetAnalyticsEngineControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__SetAnalyticsEngineControl, sizeof(struct _tad__SetAnalyticsEngineControl), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__CreateAnalyticsEngineControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse, sizeof(struct _tad__CreateAnalyticsEngineControlResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__CreateAnalyticsEngineControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__CreateAnalyticsEngineControl, sizeof(struct _tad__CreateAnalyticsEngineControl), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__DeleteAnalyticsEngineControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse, sizeof(struct _tad__DeleteAnalyticsEngineControlResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__DeleteAnalyticsEngineControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__DeleteAnalyticsEngineControl, sizeof(struct _tad__DeleteAnalyticsEngineControl), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetServiceCapabilitiesResponse, sizeof(struct _tad__GetServiceCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tad__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetServiceCapabilities, sizeof(struct _tad__GetServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__DeleteNetworkInterfaceDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DeleteNetworkInterfaceDot1XConfigurationResponse, sizeof(struct _ns5__DeleteNetworkInterfaceDot1XConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__DeleteNetworkInterfaceDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DeleteNetworkInterfaceDot1XConfiguration, sizeof(struct _ns5__DeleteNetworkInterfaceDot1XConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetNetworkInterfaceDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetNetworkInterfaceDot1XConfigurationResponse, sizeof(struct _ns5__GetNetworkInterfaceDot1XConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetNetworkInterfaceDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetNetworkInterfaceDot1XConfiguration, sizeof(struct _ns5__GetNetworkInterfaceDot1XConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__SetNetworkInterfaceDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__SetNetworkInterfaceDot1XConfigurationResponse, sizeof(struct _ns5__SetNetworkInterfaceDot1XConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__SetNetworkInterfaceDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__SetNetworkInterfaceDot1XConfiguration, sizeof(struct _ns5__SetNetworkInterfaceDot1XConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__DeleteDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DeleteDot1XConfigurationResponse, sizeof(struct _ns5__DeleteDot1XConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__DeleteDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DeleteDot1XConfiguration, sizeof(struct _ns5__DeleteDot1XConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetDot1XConfigurationResponse, sizeof(struct _ns5__GetDot1XConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetDot1XConfiguration, sizeof(struct _ns5__GetDot1XConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAllDot1XConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAllDot1XConfigurationsResponse, sizeof(struct _ns5__GetAllDot1XConfigurationsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAllDot1XConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAllDot1XConfigurations, sizeof(struct _ns5__GetAllDot1XConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__AddDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__AddDot1XConfigurationResponse, sizeof(struct _ns5__AddDot1XConfigurationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__AddDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__AddDot1XConfiguration, sizeof(struct _ns5__AddDot1XConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAssignedCertPathValidationPoliciesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAssignedCertPathValidationPoliciesResponse, sizeof(struct _ns5__GetAssignedCertPathValidationPoliciesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAssignedCertPathValidationPolicies **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAssignedCertPathValidationPolicies, sizeof(struct _ns5__GetAssignedCertPathValidationPolicies), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__ReplaceCertPathValidationPolicyAssignmentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__ReplaceCertPathValidationPolicyAssignmentResponse, sizeof(struct _ns5__ReplaceCertPathValidationPolicyAssignmentResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__ReplaceCertPathValidationPolicyAssignment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__ReplaceCertPathValidationPolicyAssignment, sizeof(struct _ns5__ReplaceCertPathValidationPolicyAssignment), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__RemoveCertPathValidationPolicyAssignmentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__RemoveCertPathValidationPolicyAssignmentResponse, sizeof(struct _ns5__RemoveCertPathValidationPolicyAssignmentResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__RemoveCertPathValidationPolicyAssignment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__RemoveCertPathValidationPolicyAssignment, sizeof(struct _ns5__RemoveCertPathValidationPolicyAssignment), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__AddCertPathValidationPolicyAssignmentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__AddCertPathValidationPolicyAssignmentResponse, sizeof(struct _ns5__AddCertPathValidationPolicyAssignmentResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__AddCertPathValidationPolicyAssignment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__AddCertPathValidationPolicyAssignment, sizeof(struct _ns5__AddCertPathValidationPolicyAssignment), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetClientAuthenticationRequiredResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetClientAuthenticationRequiredResponse, sizeof(struct _ns5__GetClientAuthenticationRequiredResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetClientAuthenticationRequired **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetClientAuthenticationRequired, sizeof(struct _ns5__GetClientAuthenticationRequired), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__SetClientAuthenticationRequiredResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__SetClientAuthenticationRequiredResponse, sizeof(struct _ns5__SetClientAuthenticationRequiredResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__SetClientAuthenticationRequired **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__SetClientAuthenticationRequired, sizeof(struct _ns5__SetClientAuthenticationRequired), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAssignedServerCertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAssignedServerCertificatesResponse, sizeof(struct _ns5__GetAssignedServerCertificatesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAssignedServerCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAssignedServerCertificates, sizeof(struct _ns5__GetAssignedServerCertificates), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__ReplaceServerCertificateAssignmentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__ReplaceServerCertificateAssignmentResponse, sizeof(struct _ns5__ReplaceServerCertificateAssignmentResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__ReplaceServerCertificateAssignment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__ReplaceServerCertificateAssignment, sizeof(struct _ns5__ReplaceServerCertificateAssignment), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__RemoveServerCertificateAssignmentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__RemoveServerCertificateAssignmentResponse, sizeof(struct _ns5__RemoveServerCertificateAssignmentResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__RemoveServerCertificateAssignment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__RemoveServerCertificateAssignment, sizeof(struct _ns5__RemoveServerCertificateAssignment), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__AddServerCertificateAssignmentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__AddServerCertificateAssignmentResponse, sizeof(struct _ns5__AddServerCertificateAssignmentResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__AddServerCertificateAssignment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__AddServerCertificateAssignment, sizeof(struct _ns5__AddServerCertificateAssignment), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__DeleteCertPathValidationPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DeleteCertPathValidationPolicyResponse, sizeof(struct _ns5__DeleteCertPathValidationPolicyResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__DeleteCertPathValidationPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DeleteCertPathValidationPolicy, sizeof(struct _ns5__DeleteCertPathValidationPolicy), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAllCertPathValidationPoliciesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAllCertPathValidationPoliciesResponse, sizeof(struct _ns5__GetAllCertPathValidationPoliciesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAllCertPathValidationPolicies **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAllCertPathValidationPolicies, sizeof(struct _ns5__GetAllCertPathValidationPolicies), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetCertPathValidationPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetCertPathValidationPolicyResponse, sizeof(struct _ns5__GetCertPathValidationPolicyResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetCertPathValidationPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetCertPathValidationPolicy, sizeof(struct _ns5__GetCertPathValidationPolicy), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__CreateCertPathValidationPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__CreateCertPathValidationPolicyResponse, sizeof(struct _ns5__CreateCertPathValidationPolicyResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__CreateCertPathValidationPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__CreateCertPathValidationPolicy, sizeof(struct _ns5__CreateCertPathValidationPolicy), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__DeleteCRLResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DeleteCRLResponse, sizeof(struct _ns5__DeleteCRLResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__DeleteCRL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DeleteCRL, sizeof(struct _ns5__DeleteCRL), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAllCRLsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAllCRLsResponse, sizeof(struct _ns5__GetAllCRLsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAllCRLs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAllCRLs, sizeof(struct _ns5__GetAllCRLs), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetCRLResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetCRLResponse, sizeof(struct _ns5__GetCRLResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetCRL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetCRL, sizeof(struct _ns5__GetCRL), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__UploadCRLResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__UploadCRLResponse, sizeof(struct _ns5__UploadCRLResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__UploadCRL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__UploadCRL, sizeof(struct _ns5__UploadCRL), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__DeletePassphraseResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DeletePassphraseResponse, sizeof(struct _ns5__DeletePassphraseResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__DeletePassphrase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DeletePassphrase, sizeof(struct _ns5__DeletePassphrase), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAllPassphrasesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAllPassphrasesResponse, sizeof(struct _ns5__GetAllPassphrasesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAllPassphrases **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAllPassphrases, sizeof(struct _ns5__GetAllPassphrases), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__UploadPassphraseResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__UploadPassphraseResponse, sizeof(struct _ns5__UploadPassphraseResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__UploadPassphrase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__UploadPassphrase, sizeof(struct _ns5__UploadPassphrase), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__DeleteCertificationPathResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DeleteCertificationPathResponse, sizeof(struct _ns5__DeleteCertificationPathResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__DeleteCertificationPath **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DeleteCertificationPath, sizeof(struct _ns5__DeleteCertificationPath), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAllCertificationPathsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAllCertificationPathsResponse, sizeof(struct _ns5__GetAllCertificationPathsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAllCertificationPaths **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAllCertificationPaths, sizeof(struct _ns5__GetAllCertificationPaths), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetCertificationPathResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetCertificationPathResponse, sizeof(struct _ns5__GetCertificationPathResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetCertificationPath **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetCertificationPath, sizeof(struct _ns5__GetCertificationPath), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__CreateCertificationPathResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__CreateCertificationPathResponse, sizeof(struct _ns5__CreateCertificationPathResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__CreateCertificationPath **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__CreateCertificationPath, sizeof(struct _ns5__CreateCertificationPath), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__DeleteCertificateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DeleteCertificateResponse, sizeof(struct _ns5__DeleteCertificateResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__DeleteCertificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DeleteCertificate, sizeof(struct _ns5__DeleteCertificate), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAllCertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAllCertificatesResponse, sizeof(struct _ns5__GetAllCertificatesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAllCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAllCertificates, sizeof(struct _ns5__GetAllCertificates), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetCertificateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetCertificateResponse, sizeof(struct _ns5__GetCertificateResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetCertificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetCertificate, sizeof(struct _ns5__GetCertificate), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__UploadCertificateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__UploadCertificateResponse, sizeof(struct _ns5__UploadCertificateResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__UploadCertificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__UploadCertificate, sizeof(struct _ns5__UploadCertificate), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__CreateSelfSignedCertificateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__CreateSelfSignedCertificateResponse, sizeof(struct _ns5__CreateSelfSignedCertificateResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__CreateSelfSignedCertificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__CreateSelfSignedCertificate, sizeof(struct _ns5__CreateSelfSignedCertificate), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__CreatePKCS10CSRResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__CreatePKCS10CSRResponse, sizeof(struct _ns5__CreatePKCS10CSRResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__CreatePKCS10CSR **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__CreatePKCS10CSR, sizeof(struct _ns5__CreatePKCS10CSR), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__DeleteKeyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DeleteKeyResponse, sizeof(struct _ns5__DeleteKeyResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__DeleteKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DeleteKey, sizeof(struct _ns5__DeleteKey), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAllKeysResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAllKeysResponse, sizeof(struct _ns5__GetAllKeysResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetAllKeys **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetAllKeys, sizeof(struct _ns5__GetAllKeys), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetPrivateKeyStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetPrivateKeyStatusResponse, sizeof(struct _ns5__GetPrivateKeyStatusResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetPrivateKeyStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetPrivateKeyStatus, sizeof(struct _ns5__GetPrivateKeyStatus), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetKeyStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetKeyStatusResponse, sizeof(struct _ns5__GetKeyStatusResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetKeyStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetKeyStatus, sizeof(struct _ns5__GetKeyStatus), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__UploadCertificateWithPrivateKeyInPKCS12Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__UploadCertificateWithPrivateKeyInPKCS12Response, sizeof(struct _ns5__UploadCertificateWithPrivateKeyInPKCS12Response), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__UploadCertificateWithPrivateKeyInPKCS12 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__UploadCertificateWithPrivateKeyInPKCS12, sizeof(struct _ns5__UploadCertificateWithPrivateKeyInPKCS12), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__UploadKeyPairInPKCS8Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__UploadKeyPairInPKCS8Response, sizeof(struct _ns5__UploadKeyPairInPKCS8Response), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__UploadKeyPairInPKCS8 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__UploadKeyPairInPKCS8, sizeof(struct _ns5__UploadKeyPairInPKCS8), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__CreateRSAKeyPairResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__CreateRSAKeyPairResponse, sizeof(struct _ns5__CreateRSAKeyPairResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__CreateRSAKeyPair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__CreateRSAKeyPair, sizeof(struct _ns5__CreateRSAKeyPair), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetServiceCapabilitiesResponse, sizeof(struct _ns5__GetServiceCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetServiceCapabilities, sizeof(struct _ns5__GetServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__DoubleLockDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__DoubleLockDoorResponse, sizeof(struct _ns4__DoubleLockDoorResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__DoubleLockDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__DoubleLockDoor, sizeof(struct _ns4__DoubleLockDoor), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__LockOpenReleaseDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__LockOpenReleaseDoorResponse, sizeof(struct _ns4__LockOpenReleaseDoorResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__LockOpenReleaseDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__LockOpenReleaseDoor, sizeof(struct _ns4__LockOpenReleaseDoor), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__LockOpenDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__LockOpenDoorResponse, sizeof(struct _ns4__LockOpenDoorResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__LockOpenDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__LockOpenDoor, sizeof(struct _ns4__LockOpenDoor), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__LockDownReleaseDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__LockDownReleaseDoorResponse, sizeof(struct _ns4__LockDownReleaseDoorResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__LockDownReleaseDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__LockDownReleaseDoor, sizeof(struct _ns4__LockDownReleaseDoor), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__LockDownDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__LockDownDoorResponse, sizeof(struct _ns4__LockDownDoorResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__LockDownDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__LockDownDoor, sizeof(struct _ns4__LockDownDoor), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__BlockDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__BlockDoorResponse, sizeof(struct _ns4__BlockDoorResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__BlockDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__BlockDoor, sizeof(struct _ns4__BlockDoor), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__UnlockDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__UnlockDoorResponse, sizeof(struct _ns4__UnlockDoorResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__UnlockDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__UnlockDoor, sizeof(struct _ns4__UnlockDoor), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__LockDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__LockDoorResponse, sizeof(struct _ns4__LockDoorResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__LockDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__LockDoor, sizeof(struct _ns4__LockDoor), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__AccessDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__AccessDoorResponse, sizeof(struct _ns4__AccessDoorResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__AccessDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__AccessDoor, sizeof(struct _ns4__AccessDoor), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__GetDoorStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__GetDoorStateResponse, sizeof(struct _ns4__GetDoorStateResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__GetDoorState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__GetDoorState, sizeof(struct _ns4__GetDoorState), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__GetDoorInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__GetDoorInfoResponse, sizeof(struct _ns4__GetDoorInfoResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__GetDoorInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__GetDoorInfo, sizeof(struct _ns4__GetDoorInfo), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__GetDoorInfoListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__GetDoorInfoListResponse, sizeof(struct _ns4__GetDoorInfoListResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__GetDoorInfoList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__GetDoorInfoList, sizeof(struct _ns4__GetDoorInfoList), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__GetServiceCapabilitiesResponse, sizeof(struct _ns4__GetServiceCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns4__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__GetServiceCapabilities, sizeof(struct _ns4__GetServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__ExternalAuthorizationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__ExternalAuthorizationResponse, sizeof(struct _ns2__ExternalAuthorizationResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__ExternalAuthorization **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__ExternalAuthorization, sizeof(struct _ns2__ExternalAuthorization), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__DisableAccessPointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__DisableAccessPointResponse, sizeof(struct _ns2__DisableAccessPointResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__DisableAccessPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__DisableAccessPoint, sizeof(struct _ns2__DisableAccessPoint), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__EnableAccessPointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__EnableAccessPointResponse, sizeof(struct _ns2__EnableAccessPointResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__EnableAccessPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__EnableAccessPoint, sizeof(struct _ns2__EnableAccessPoint), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__GetAccessPointStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetAccessPointStateResponse, sizeof(struct _ns2__GetAccessPointStateResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__GetAccessPointState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetAccessPointState, sizeof(struct _ns2__GetAccessPointState), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__GetAreaInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetAreaInfoResponse, sizeof(struct _ns2__GetAreaInfoResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__GetAreaInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetAreaInfo, sizeof(struct _ns2__GetAreaInfo), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__GetAreaInfoListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetAreaInfoListResponse, sizeof(struct _ns2__GetAreaInfoListResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__GetAreaInfoList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetAreaInfoList, sizeof(struct _ns2__GetAreaInfoList), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__GetAccessPointInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetAccessPointInfoResponse, sizeof(struct _ns2__GetAccessPointInfoResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__GetAccessPointInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetAccessPointInfo, sizeof(struct _ns2__GetAccessPointInfo), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__GetAccessPointInfoListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetAccessPointInfoListResponse, sizeof(struct _ns2__GetAccessPointInfoListResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__GetAccessPointInfoList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetAccessPointInfoList, sizeof(struct _ns2__GetAccessPointInfoList), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetServiceCapabilitiesResponse, sizeof(struct _ns2__GetServiceCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns2__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetServiceCapabilities, sizeof(struct _ns2__GetServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__ModifyActionTriggersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ModifyActionTriggersResponse, sizeof(struct _ns1__ModifyActionTriggersResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__ModifyActionTriggers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ModifyActionTriggers, sizeof(struct _ns1__ModifyActionTriggers), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__DeleteActionTriggersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteActionTriggersResponse, sizeof(struct _ns1__DeleteActionTriggersResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__DeleteActionTriggers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteActionTriggers, sizeof(struct _ns1__DeleteActionTriggers), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__CreateActionTriggersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateActionTriggersResponse, sizeof(struct _ns1__CreateActionTriggersResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__CreateActionTriggers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateActionTriggers, sizeof(struct _ns1__CreateActionTriggers), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__GetActionTriggersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetActionTriggersResponse, sizeof(struct _ns1__GetActionTriggersResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__GetActionTriggers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetActionTriggers, sizeof(struct _ns1__GetActionTriggers), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetServiceCapabilitiesResponse, sizeof(struct _ns1__GetServiceCapabilitiesResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetServiceCapabilities, sizeof(struct _ns1__GetServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__ModifyActionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ModifyActionsResponse, sizeof(struct _ns1__ModifyActionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__ModifyActions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ModifyActions, sizeof(struct _ns1__ModifyActions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__DeleteActionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteActionsResponse, sizeof(struct _ns1__DeleteActionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__DeleteActions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteActions, sizeof(struct _ns1__DeleteActions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__CreateActionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateActionsResponse, sizeof(struct _ns1__CreateActionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__CreateActions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateActions, sizeof(struct _ns1__CreateActions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__GetActionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetActionsResponse, sizeof(struct _ns1__GetActionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__GetActions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetActions, sizeof(struct _ns1__GetActions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__GetSupportedActionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSupportedActionsResponse, sizeof(struct _ns1__GetSupportedActionsResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns1__GetSupportedActions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSupportedActions, sizeof(struct _ns1__GetSupportedActions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__UnsupportedPolicyRequestFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(struct wsnt__UnsupportedPolicyRequestFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__UnrecognizedPolicyRequestFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__UnacceptableTerminationTimeFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableTerminationTimeFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__UnacceptableInitialTerminationTimeFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableInitialTerminationTimeFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__UnableToGetMessagesFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(struct wsnt__UnableToGetMessagesFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__UnableToDestroySubscriptionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(struct wsnt__UnableToDestroySubscriptionFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__UnableToDestroyPullPointFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(struct wsnt__UnableToDestroyPullPointFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__UnableToCreatePullPointFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(struct wsnt__UnableToCreatePullPointFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__TopicNotSupportedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(struct wsnt__TopicNotSupportedFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__TopicExpressionDialectUnknownFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__SubscribeCreationFailedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(struct wsnt__SubscribeCreationFailedFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__ResumeFailedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(struct wsnt__ResumeFailedFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsrfr__ResourceUnknownFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, sizeof(struct wsrfr__ResourceUnknownFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tev__PullMessagesFaultResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(struct _tev__PullMessagesFaultResponse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__PauseFailedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(struct wsnt__PauseFailedFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__NotifyMessageNotSupportedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(struct wsnt__NotifyMessageNotSupportedFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__NoCurrentMessageOnTopicFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(struct wsnt__NoCurrentMessageOnTopicFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__MultipleTopicsSpecifiedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__InvalidTopicExpressionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(struct wsnt__InvalidTopicExpressionFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__InvalidMessageContentExpressionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(struct wsnt__InvalidMessageContentExpressionFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__InvalidFilterFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(struct wsnt__InvalidFilterFaultType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns4__DoorCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__DoorCapabilities, sizeof(struct ns4__DoorCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns2__AccessPointCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AccessPointCapabilities, sizeof(struct ns2__AccessPointCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsrfr__ResourceUnavailableFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnavailableFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsrfr__ResourceUnavailableFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_Description, sizeof(struct _wsrfr__ResourceUnavailableFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnavailableFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsrfr__ResourceUnknownFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnknownFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsrfr__ResourceUnknownFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_Description, sizeof(struct _wsrfr__ResourceUnknownFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsrfr__ResourceUnknownFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnknownFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wstop__TopicNamespaceType_Topic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wstop__TopicType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicType, sizeof(struct wstop__TopicType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wstop__QueryExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(struct wstop__QueryExpressionType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__ResumeFailedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__ResumeFailedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description, sizeof(struct _wsnt__ResumeFailedFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__ResumeFailedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__PauseFailedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__PauseFailedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseFailedFaultType_Description, sizeof(struct _wsnt__PauseFailedFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__PauseFailedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnableToGetMessagesFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__TopicNotSupportedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__InvalidFilterFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__InvalidFilterFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfigurationExtension, sizeof(struct tt__OSDConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDImgConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgConfiguration, sizeof(struct tt__OSDImgConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDTextConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextConfiguration, sizeof(struct tt__OSDTextConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDPosConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDPosConfiguration, sizeof(struct tt__OSDPosConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDReference, sizeof(struct tt__OSDReference), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MetadataInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataInput, sizeof(struct tt__MetadataInput), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SourceIdentification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceIdentification, sizeof(struct tt__SourceIdentification), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AnalyticsDeviceEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, sizeof(struct tt__AnalyticsDeviceEngineConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(struct tt__PTZConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ZoomLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ZoomLimits, sizeof(struct tt__ZoomLimits), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PanTiltLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PanTiltLimits, sizeof(struct tt__PanTiltLimits), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZNodeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNodeExtension, sizeof(struct tt__PTZNodeExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkInterfaceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(struct tt__NetworkInterfaceExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IPv6NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(struct tt__IPv6NetworkInterface), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IPv4NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(struct tt__IPv4NetworkInterface), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkInterfaceLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(struct tt__NetworkInterfaceLink), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkInterfaceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(struct tt__NetworkInterfaceInfo), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoOutputExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoOutputExtension, sizeof(struct tt__VideoOutputExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MetadataConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(struct tt__MetadataConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__EventSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventSubscription, sizeof(struct tt__EventSubscription), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZFilter, sizeof(struct tt__PTZFilter), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RuleEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(struct tt__RuleEngineConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AnalyticsEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(struct tt__AnalyticsEngineConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoRateControl2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoRateControl2, sizeof(struct tt__VideoRateControl2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MulticastConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(struct tt__MulticastConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__H264Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Configuration, sizeof(struct tt__H264Configuration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Mpeg4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(struct tt__Mpeg4Configuration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoRateControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoRateControl, sizeof(struct tt__VideoRateControl), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoSourceConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(struct tt__VideoSourceConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IntRectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRectangle, sizeof(struct tt__IntRectangle), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoSourceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceExtension, sizeof(struct tt__VideoSourceExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettings, sizeof(struct tt__ImagingSettings), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__Dot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__Dot1XConfiguration, sizeof(struct ns5__Dot1XConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CertPathValidationPolicyID, sizeof(char *), 1, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__CertPathValidationPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CertPathValidationPolicy, sizeof(struct ns5__CertPathValidationPolicy), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__CreateCertPathValidationPolicy_anyParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__CreateCertPathValidationPolicy_anyParameters, sizeof(struct _ns5__CreateCertPathValidationPolicy_anyParameters), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__CRL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CRL, sizeof(struct ns5__CRL), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__UploadCRL_anyParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__UploadCRL_anyParameters, sizeof(struct _ns5__UploadCRL_anyParameters), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__PassphraseAttribute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__PassphraseAttribute, sizeof(struct ns5__PassphraseAttribute), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CertificationPathID, sizeof(char *), 1, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__CertificationPath **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CertificationPath, sizeof(struct ns5__CertificationPath), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__CertificateIDs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CertificateIDs, sizeof(struct ns5__CertificateIDs), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__X509Certificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__X509Certificate, sizeof(struct ns5__X509Certificate), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__CSRAttribute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CSRAttribute, sizeof(struct ns5__CSRAttribute), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__DistinguishedName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__DistinguishedName, sizeof(struct ns5__DistinguishedName), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__KeyAttribute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__KeyAttribute, sizeof(struct ns5__KeyAttribute), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__Capabilities, sizeof(struct ns5__Capabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__Dot1XCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__Dot1XCapabilities, sizeof(struct ns5__Dot1XCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__TLSServerCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__TLSServerCapabilities, sizeof(struct ns5__TLSServerCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__KeystoreCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__KeystoreCapabilities, sizeof(struct ns5__KeystoreCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__KeystoreCapabilities_anyElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__KeystoreCapabilities_anyElement, sizeof(struct _ns5__KeystoreCapabilities_anyElement), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__AlgorithmIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__AlgorithmIdentifier, sizeof(struct ns5__AlgorithmIdentifier), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__CertPathValidationPolicy_anyParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__CertPathValidationPolicy_anyParameters, sizeof(struct _ns5__CertPathValidationPolicy_anyParameters), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__TrustAnchor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__TrustAnchor, sizeof(struct ns5__TrustAnchor), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__CertPathValidationParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CertPathValidationParameters, sizeof(struct ns5__CertPathValidationParameters), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__CertPathValidationParameters_anyParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__CertPathValidationParameters_anyParameters, sizeof(struct _ns5__CertPathValidationParameters_anyParameters), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__Dot1XStageExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__Dot1XStageExtension, sizeof(struct ns5__Dot1XStageExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__Dot1XStage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__Dot1XStage, sizeof(struct ns5__Dot1XStage), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__CertificationPath_anyElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__CertificationPath_anyElement, sizeof(struct _ns5__CertificationPath_anyElement), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CertificateID, sizeof(char *), 1, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__CSRAttribute_anyAttribute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__CSRAttribute_anyAttribute, sizeof(struct _ns5__CSRAttribute_anyAttribute), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__BasicRequestAttribute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__BasicRequestAttribute, sizeof(struct ns5__BasicRequestAttribute), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__X509v3Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__X509v3Extension, sizeof(struct ns5__X509v3Extension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__AlgorithmIdentifier_anyParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__AlgorithmIdentifier_anyParameters, sizeof(struct _ns5__AlgorithmIdentifier_anyParameters), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__DistinguishedName_anyAttribute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DistinguishedName_anyAttribute, sizeof(struct _ns5__DistinguishedName_anyAttribute), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__MultiValuedRDN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__MultiValuedRDN, sizeof(struct ns5__MultiValuedRDN), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__DNAttributeValue, sizeof(char *), 1, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns5__DNAttributeTypeAndValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__DNAttributeTypeAndValue, sizeof(struct ns5__DNAttributeTypeAndValue), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _ns5__KeyAttribute_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__KeyAttribute_Extension, sizeof(struct _ns5__KeyAttribute_Extension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns4__AccessDoorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__AccessDoorExtension, sizeof(struct ns4__AccessDoorExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns4__DoorState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__DoorState, sizeof(struct ns4__DoorState), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns4__DoorInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__DoorInfo, sizeof(struct ns4__DoorInfo), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns4__ServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ServiceCapabilities, sizeof(struct ns4__ServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns4__DoorFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__DoorFault, sizeof(struct ns4__DoorFault), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns4__DoorTamper **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__DoorTamper, sizeof(struct ns4__DoorTamper), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum ns4__DoorAlarmState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__DoorAlarmState, sizeof(enum ns4__DoorAlarmState), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum ns4__LockPhysicalState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__LockPhysicalState, sizeof(enum ns4__LockPhysicalState), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum ns4__DoorPhysicalState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__DoorPhysicalState, sizeof(enum ns4__DoorPhysicalState), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns2__AccessPointState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AccessPointState, sizeof(struct ns2__AccessPointState), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns2__AreaInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AreaInfo, sizeof(struct ns2__AreaInfo), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ReferenceToken, sizeof(char *), 1, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns2__AccessPointInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AccessPointInfo, sizeof(struct ns2__AccessPointInfo), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns2__ServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ServiceCapabilities, sizeof(struct ns2__ServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__ActionTrigger **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionTrigger, sizeof(struct ns1__ActionTrigger), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__ActionEngineCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionEngineCapabilities, sizeof(struct ns1__ActionEngineCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__Action **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Action, sizeof(struct ns1__Action), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__SupportedActions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SupportedActions, sizeof(struct ns1__SupportedActions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__TriggeredRecordingConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TriggeredRecordingConfiguration, sizeof(struct ns1__TriggeredRecordingConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__FtpFileNameConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpFileNameConfigurations, sizeof(struct ns1__FtpFileNameConfigurations), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__FtpContentConfigurationUploadFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpContentConfigurationUploadFile, sizeof(struct ns1__FtpContentConfigurationUploadFile), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__FtpContentConfigurationUploadImages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpContentConfigurationUploadImages, sizeof(struct ns1__FtpContentConfigurationUploadImages), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__FtpContentConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpContentConfiguration, sizeof(struct ns1__FtpContentConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__FtpAuthenticationConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpAuthenticationConfigurationExtension, sizeof(struct ns1__FtpAuthenticationConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__FtpDestinationConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpDestinationConfigurationExtension, sizeof(struct ns1__FtpDestinationConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__FtpAuthenticationConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpAuthenticationConfiguration, sizeof(struct ns1__FtpAuthenticationConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__FtpHostAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpHostAddress, sizeof(struct ns1__FtpHostAddress), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__FtpHostConfigurationsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpHostConfigurationsExtension, sizeof(struct ns1__FtpHostConfigurationsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__FtpDestinationConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpDestinationConfiguration, sizeof(struct ns1__FtpDestinationConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__PostBodyConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PostBodyConfiguration, sizeof(struct ns1__PostBodyConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__MediaSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MediaSource, sizeof(struct ns1__MediaSource), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__HttpAuthenticationConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HttpAuthenticationConfigurationExtension, sizeof(struct ns1__HttpAuthenticationConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__HttpDestinationConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HttpDestinationConfigurationExtension, sizeof(struct ns1__HttpDestinationConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__HttpAuthenticationConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HttpAuthenticationConfiguration, sizeof(struct ns1__HttpAuthenticationConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__HttpHostAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HttpHostAddress, sizeof(struct ns1__HttpHostAddress), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__HttpHostConfigurationsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HttpHostConfigurationsExtension, sizeof(struct ns1__HttpHostConfigurationsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__HttpDestinationConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HttpDestinationConfiguration, sizeof(struct ns1__HttpDestinationConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__EMailAttachmentConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EMailAttachmentConfigurationExtension, sizeof(struct ns1__EMailAttachmentConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum ns1__FileSuffixType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FileSuffixType, sizeof(enum ns1__FileSuffixType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__EMailReceiverConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EMailReceiverConfigurationExtension, sizeof(struct ns1__EMailReceiverConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__UserCredentials **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UserCredentials, sizeof(struct ns1__UserCredentials), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__UserCredentialsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UserCredentialsExtension, sizeof(struct ns1__UserCredentialsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__HostAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HostAddress, sizeof(struct ns1__HostAddress), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__AuthenticationConfig **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AuthenticationConfig, sizeof(struct ns1__AuthenticationConfig), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__POPConfig **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__POPConfig, sizeof(struct ns1__POPConfig), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__SMTPConfig **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SMTPConfig, sizeof(struct ns1__SMTPConfig), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__ActionTriggerConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionTriggerConfiguration, sizeof(struct ns1__ActionTriggerConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__ActionTriggerConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionTriggerConfigurationExtension, sizeof(struct ns1__ActionTriggerConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__QueryExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(struct wsnt__QueryExpressionType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__ActionConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionConfiguration, sizeof(struct ns1__ActionConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__ActionEngineCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionEngineCapabilitiesExtension, sizeof(struct ns1__ActionEngineCapabilitiesExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__ActionTypeLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionTypeLimits, sizeof(struct ns1__ActionTypeLimits), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__SupportedActionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SupportedActionsExtension, sizeof(struct ns1__SupportedActionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ns1__ActionConfigDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionConfigDescription, sizeof(struct ns1__ActionConfigDescription), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AnalyticsStateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsStateInformation, sizeof(struct tt__AnalyticsStateInformation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AnalyticsEngine **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngine, sizeof(struct tt__AnalyticsEngine), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AnalyticsEngineControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineControl, sizeof(struct tt__AnalyticsEngineControl), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AnalyticsEngineInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineInput, sizeof(struct tt__AnalyticsEngineInput), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tad__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tad__Capabilities, sizeof(struct tad__Capabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SupportedAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedAnalyticsModules, sizeof(struct tt__SupportedAnalyticsModules), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tan__ConfigOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tan__ConfigOptions, sizeof(struct tan__ConfigOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SupportedRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedRules, sizeof(struct tt__SupportedRules), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tan__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tan__Capabilities, sizeof(struct tan__Capabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ReplayConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReplayConfiguration, sizeof(struct tt__ReplayConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct trp__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trp__Capabilities, sizeof(struct trp__Capabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FindMetadataResultList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindMetadataResultList, sizeof(struct tt__FindMetadataResultList), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MetadataFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataFilter, sizeof(struct tt__MetadataFilter), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FindPTZPositionResultList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindPTZPositionResultList, sizeof(struct tt__FindPTZPositionResultList), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPositionFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPositionFilter, sizeof(struct tt__PTZPositionFilter), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FindEventResultList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindEventResultList, sizeof(struct tt__FindEventResultList), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__EventFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventFilter, sizeof(struct tt__EventFilter), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FindRecordingResultList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindRecordingResultList, sizeof(struct tt__FindRecordingResultList), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MediaAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaAttributes, sizeof(struct tt__MediaAttributes), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RecordingSummary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingSummary, sizeof(struct tt__RecordingSummary), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tse__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tse__Capabilities, sizeof(struct tse__Capabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ArrayOfFileProgress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ArrayOfFileProgress, sizeof(struct tt__ArrayOfFileProgress), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _trc__ExportRecordedDataResponse_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__ExportRecordedDataResponse_Extension, sizeof(struct _trc__ExportRecordedDataResponse_Extension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__StorageReferencePath **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StorageReferencePath, sizeof(struct tt__StorageReferencePath), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SearchScope **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SearchScope, sizeof(struct tt__SearchScope), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct trc__RecordingOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trc__RecordingOptions, sizeof(struct trc__RecordingOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RecordingJobStateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateInformation, sizeof(struct tt__RecordingJobStateInformation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__GetRecordingJobsResponseItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetRecordingJobsResponseItem, sizeof(struct tt__GetRecordingJobsResponseItem), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__GetRecordingsResponseItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetRecordingsResponseItem, sizeof(struct tt__GetRecordingsResponseItem), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct trc__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trc__Capabilities, sizeof(struct trc__Capabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct trc__TrackOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trc__TrackOptions, sizeof(struct trc__TrackOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct trc__JobOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trc__JobOptions, sizeof(struct trc__JobOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ReceiverStateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReceiverStateInformation, sizeof(struct tt__ReceiverStateInformation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Receiver **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Receiver, sizeof(struct tt__Receiver), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct trv__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trv__Capabilities, sizeof(struct trv__Capabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPresetTourOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourOptions, sizeof(struct tt__PTZPresetTourOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PresetTour, sizeof(struct tt__PresetTour), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStatus, sizeof(struct tt__PTZStatus), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPreset, sizeof(struct tt__PTZPreset), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationOptions, sizeof(struct tt__PTZConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct __tptz__SetConfigurationResponse_sequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___tptz__SetConfigurationResponse_sequence, sizeof(struct __tptz__SetConfigurationResponse_sequence), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZNode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNode, sizeof(struct tt__PTZNode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tptz__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tptz__Capabilities, sizeof(struct tptz__Capabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfigurationOptions, sizeof(struct tt__OSDConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfiguration, sizeof(struct tt__OSDConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct trt__VideoSourceMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__VideoSourceMode, sizeof(struct trt__VideoSourceMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MediaUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaUri, sizeof(struct tt__MediaUri), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MetadataConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationOptions, sizeof(struct tt__MetadataConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(struct tt__VideoEncoderConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Profile, sizeof(struct tt__Profile), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AudioOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutput, sizeof(struct tt__AudioOutput), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AudioSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSource, sizeof(struct tt__AudioSource), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSource, sizeof(struct tt__VideoSource), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct trt__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__Capabilities, sizeof(struct trt__Capabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct trt__VideoSourceModeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__VideoSourceModeExtension, sizeof(struct trt__VideoSourceModeExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct trt__StreamingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__StreamingCapabilities, sizeof(struct trt__StreamingCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct trt__ProfileCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__ProfileCapabilities, sizeof(struct trt__ProfileCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct timg__ImagingPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_timg__ImagingPreset, sizeof(struct timg__ImagingPreset), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImagingStatus20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingStatus20, sizeof(struct tt__ImagingStatus20), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MoveOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MoveOptions20, sizeof(struct tt__MoveOptions20), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FocusMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusMove, sizeof(struct tt__FocusMove), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImagingOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20, sizeof(struct tt__ImagingOptions20), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct timg__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_timg__Capabilities, sizeof(struct timg__Capabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tmd__SerialData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__SerialData, sizeof(struct tmd__SerialData), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tmd__SerialPortConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__SerialPortConfigurationOptions, sizeof(struct tmd__SerialPortConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tmd__SerialPortConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__SerialPortConfiguration, sizeof(struct tmd__SerialPortConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tmd__SerialPort **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__SerialPort, sizeof(struct tmd__SerialPort), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tmd__DigitalInputConfigurationInputOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__DigitalInputConfigurationInputOptions, sizeof(struct tmd__DigitalInputConfigurationInputOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__DigitalInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DigitalInput, sizeof(struct tt__DigitalInput), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AudioOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(struct tt__AudioOutputConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AudioSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(struct tt__AudioSourceConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoOutputConfigurationOptions, sizeof(struct tt__VideoOutputConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(struct tt__VideoSourceConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoOutputConfiguration, sizeof(struct tt__VideoOutputConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoOutput, sizeof(struct tt__VideoOutput), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tmd__RelayOutputOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__RelayOutputOptions, sizeof(struct tmd__RelayOutputOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tmd__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__Capabilities, sizeof(struct tmd__Capabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tmd__ParityBit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__ParityBit, sizeof(enum tmd__ParityBit), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FloatList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FloatList, sizeof(struct tt__FloatList), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tmd__ParityBitList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__ParityBitList, sizeof(struct tmd__ParityBitList), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__DigitalIdleState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DigitalIdleState, sizeof(enum tt__DigitalIdleState), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tmd__RelayOutputOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__RelayOutputOptionsExtension, sizeof(struct tmd__RelayOutputOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__RelayMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayMode, sizeof(enum tt__RelayMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PaneConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneConfiguration, sizeof(struct tt__PaneConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__CodingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CodingCapabilities, sizeof(struct tt__CodingCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__LayoutOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LayoutOptions, sizeof(struct tt__LayoutOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Layout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Layout, sizeof(struct tt__Layout), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tls__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tls__Capabilities, sizeof(struct tls__Capabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tev__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tev__Capabilities, sizeof(struct tev__Capabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wstop__Documentation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__Documentation, sizeof(struct wstop__Documentation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsrfbf__BaseFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(struct _wsrfbf__BaseFaultType_FaultCause), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsrfbf__BaseFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_Description, sizeof(struct _wsrfbf__BaseFaultType_Description), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsrfbf__BaseFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsnt__Subscribe_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__SubscriptionPolicyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(struct wsnt__SubscriptionPolicyType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wstop__TopicSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicSetType, sizeof(struct wstop__TopicSetType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__TopicExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(struct wsnt__TopicExpressionType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__PropertyOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PropertyOperation, sizeof(enum tt__PropertyOperation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MessageExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageExtension, sizeof(struct tt__MessageExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__TransformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TransformationExtension, sizeof(struct tt__TransformationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__MoveStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZMoveStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZMoveStatus, sizeof(struct tt__PTZMoveStatus), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__StorageReferencePathExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StorageReferencePathExtension, sizeof(struct tt__StorageReferencePathExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ArrayOfFileProgressExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ArrayOfFileProgressExtension, sizeof(struct tt__ArrayOfFileProgressExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FileProgress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FileProgress, sizeof(struct tt__FileProgress), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, sizeof(struct tt__OSDConfigurationOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDImgOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgOptions, sizeof(struct tt__OSDImgOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDTextOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextOptions, sizeof(struct tt__OSDTextOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__OSDType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDType, sizeof(enum tt__OSDType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MaximumNumberOfOSDs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MaximumNumberOfOSDs, sizeof(struct tt__MaximumNumberOfOSDs), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDImgOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgOptionsExtension, sizeof(struct tt__OSDImgOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDTextOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextOptionsExtension, sizeof(struct tt__OSDTextOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDColorOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDColorOptions, sizeof(struct tt__OSDColorOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDColorOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDColorOptionsExtension, sizeof(struct tt__OSDColorOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ColorOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorOptions, sizeof(struct tt__ColorOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ColorspaceRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorspaceRange, sizeof(struct tt__ColorspaceRange), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDImgConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgConfigurationExtension, sizeof(struct tt__OSDImgConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDTextConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextConfigurationExtension, sizeof(struct tt__OSDTextConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDColor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDColor, sizeof(struct tt__OSDColor), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Color **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Color, sizeof(struct tt__Color), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OSDPosConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDPosConfigurationExtension, sizeof(struct tt__OSDPosConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ProfileStatusExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileStatusExtension, sizeof(struct tt__ProfileStatusExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ActiveConnection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ActiveConnection, sizeof(struct tt__ActiveConnection), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AudioClassDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioClassDescriptorExtension, sizeof(struct tt__AudioClassDescriptorExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AudioClassCandidate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioClassCandidate, sizeof(struct tt__AudioClassCandidate), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ActionEngineEventPayloadExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, sizeof(struct tt__ActionEngineEventPayloadExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct SOAP_ENV__Fault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct SOAP_ENV__Envelope **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AnalyticsState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsState, sizeof(struct tt__AnalyticsState), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MetadataInputExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataInputExtension, sizeof(struct tt__MetadataInputExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SourceIdentificationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceIdentificationExtension, sizeof(struct tt__SourceIdentificationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AnalyticsEngineInputInfoExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, sizeof(struct tt__AnalyticsEngineInputInfoExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AnalyticsEngineInputInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineInputInfo, sizeof(struct tt__AnalyticsEngineInputInfo), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AnalyticsDeviceEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, sizeof(struct tt__AnalyticsDeviceEngineConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__EngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EngineConfiguration, sizeof(struct tt__EngineConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RecordingJobConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobConfiguration, sizeof(struct tt__RecordingJobConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RecordingJobStateTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateTrack, sizeof(struct tt__RecordingJobStateTrack), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RecordingJobStateTracks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateTracks, sizeof(struct tt__RecordingJobStateTracks), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RecordingJobStateInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateInformationExtension, sizeof(struct tt__RecordingJobStateInformationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RecordingJobStateSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateSource, sizeof(struct tt__RecordingJobStateSource), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RecordingJobSourceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobSourceExtension, sizeof(struct tt__RecordingJobSourceExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RecordingJobTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobTrack, sizeof(struct tt__RecordingJobTrack), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RecordingJobConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobConfigurationExtension, sizeof(struct tt__RecordingJobConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RecordingJobSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobSource, sizeof(struct tt__RecordingJobSource), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__TrackConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackConfiguration, sizeof(struct tt__TrackConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__GetTracksResponseItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetTracksResponseItem, sizeof(struct tt__GetTracksResponseItem), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__GetTracksResponseList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetTracksResponseList, sizeof(struct tt__GetTracksResponseList), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RecordingConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingConfiguration, sizeof(struct tt__RecordingConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__TrackAttributesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackAttributesExtension, sizeof(struct tt__TrackAttributesExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MetadataAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataAttributes, sizeof(struct tt__MetadataAttributes), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AudioAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioAttributes, sizeof(struct tt__AudioAttributes), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAttributes, sizeof(struct tt__VideoAttributes), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__TrackAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackAttributes, sizeof(struct tt__TrackAttributes), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__TrackInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackInformation, sizeof(struct tt__TrackInformation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RecordingSourceInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingSourceInformation, sizeof(struct tt__RecordingSourceInformation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FindMetadataResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindMetadataResult, sizeof(struct tt__FindMetadataResult), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FindPTZPositionResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindPTZPositionResult, sizeof(struct tt__FindPTZPositionResult), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__NotificationMessageHolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(struct wsnt__NotificationMessageHolderType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FindEventResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindEventResult, sizeof(struct tt__FindEventResult), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RecordingInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingInformation, sizeof(struct tt__RecordingInformation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SearchScopeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SearchScopeExtension, sizeof(struct tt__SearchScopeExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingReference, sizeof(char *), 1, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SourceReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceReference, sizeof(struct tt__SourceReference), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__StreamSetup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StreamSetup, sizeof(struct tt__StreamSetup), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ReceiverConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReceiverConfiguration, sizeof(struct tt__ReceiverConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PaneOptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneOptionExtension, sizeof(struct tt__PaneOptionExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__LayoutOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LayoutOptionsExtension, sizeof(struct tt__LayoutOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PaneLayoutOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneLayoutOptions, sizeof(struct tt__PaneLayoutOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoDecoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, sizeof(struct tt__VideoDecoderConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AudioDecoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, sizeof(struct tt__AudioDecoderConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AudioEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, sizeof(struct tt__AudioEncoderConfigurationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__LayoutExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LayoutExtension, sizeof(struct tt__LayoutExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PaneLayout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneLayout, sizeof(struct tt__PaneLayout), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Transformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Transformation, sizeof(struct tt__Transformation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MotionExpression **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MotionExpression, sizeof(struct tt__MotionExpression), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PolylineArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PolylineArray, sizeof(struct tt__PolylineArray), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PolylineArrayExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PolylineArrayExtension, sizeof(struct tt__PolylineArrayExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Polyline **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Polyline, sizeof(struct tt__Polyline), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Polygon **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Polygon, sizeof(struct tt__Polygon), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SupportedAnalyticsModulesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, sizeof(struct tt__SupportedAnalyticsModulesExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SupportedRulesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedRulesExtension, sizeof(struct tt__SupportedRulesExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ConfigDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ConfigDescription, sizeof(struct tt__ConfigDescription), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ConfigDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ConfigDescriptionExtension, sizeof(struct tt__ConfigDescriptionExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tt__ConfigDescription_Messages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ConfigDescription_Messages, sizeof(struct _tt__ConfigDescription_Messages), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemList, sizeof(struct tt__ItemList), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RuleEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(struct tt__RuleEngineConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AnalyticsEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(struct tt__AnalyticsEngineConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Config **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Config, sizeof(struct tt__Config), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Vector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector, sizeof(struct tt__Vector), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ItemListDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(struct tt__ItemListDescriptionExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tt__ItemListDescription_ElementItemDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tt__ItemListDescription_SimpleItemDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MessageDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(struct tt__MessageDescriptionExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ItemListDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListDescription, sizeof(struct tt__ItemListDescription), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ItemListExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListExtension, sizeof(struct tt__ItemListExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tt__ItemList_ElementItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(struct _tt__ItemList_ElementItem), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tt__ItemList_SimpleItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FocusOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(struct tt__FocusOptions20Extension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__WhiteBalanceOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(struct tt__WhiteBalanceOptions20Extension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FocusConfiguration20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(struct tt__FocusConfiguration20Extension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__WhiteBalance20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(struct tt__WhiteBalance20Extension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RelativeFocusOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(struct tt__RelativeFocusOptions20), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__BacklightCompensationMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensationMode, sizeof(enum tt__BacklightCompensationMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IrCutFilterAutoAdjustmentOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, sizeof(struct tt__IrCutFilterAutoAdjustmentOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImageStabilizationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, sizeof(struct tt__ImageStabilizationOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__ImageStabilizationMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationMode, sizeof(enum tt__ImageStabilizationMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImagingOptions20Extension4 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension4, sizeof(struct tt__ImagingOptions20Extension4), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NoiseReductionOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NoiseReductionOptions, sizeof(struct tt__NoiseReductionOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__DefoggingOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DefoggingOptions, sizeof(struct tt__DefoggingOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ToneCompensationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ToneCompensationOptions, sizeof(struct tt__ToneCompensationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImagingOptions20Extension3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension3, sizeof(struct tt__ImagingOptions20Extension3), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IrCutFilterAutoAdjustmentOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, sizeof(struct tt__IrCutFilterAutoAdjustmentOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImagingOptions20Extension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension2, sizeof(struct tt__ImagingOptions20Extension2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImageStabilizationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationOptions, sizeof(struct tt__ImageStabilizationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImagingOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(struct tt__ImagingOptions20Extension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__WhiteBalanceOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(struct tt__WhiteBalanceOptions20), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__WideDynamicRangeOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(struct tt__WideDynamicRangeOptions20), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FocusOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions20, sizeof(struct tt__FocusOptions20), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ExposureOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposureOptions20, sizeof(struct tt__ExposureOptions20), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__BacklightCompensationOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(struct tt__BacklightCompensationOptions20), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__DefoggingExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DefoggingExtension, sizeof(struct tt__DefoggingExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ToneCompensationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ToneCompensationExtension, sizeof(struct tt__ToneCompensationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IrCutFilterAutoAdjustmentExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, sizeof(struct tt__IrCutFilterAutoAdjustmentExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImageStabilizationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationExtension, sizeof(struct tt__ImageStabilizationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImagingSettingsExtension204 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension204, sizeof(struct tt__ImagingSettingsExtension204), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NoiseReduction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NoiseReduction, sizeof(struct tt__NoiseReduction), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Defogging **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Defogging, sizeof(struct tt__Defogging), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ToneCompensation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ToneCompensation, sizeof(struct tt__ToneCompensation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImagingSettingsExtension203 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension203, sizeof(struct tt__ImagingSettingsExtension203), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IrCutFilterAutoAdjustment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, sizeof(struct tt__IrCutFilterAutoAdjustment), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImagingSettingsExtension202 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension202, sizeof(struct tt__ImagingSettingsExtension202), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImageStabilization **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilization, sizeof(struct tt__ImageStabilization), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImagingSettingsExtension20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(struct tt__ImagingSettingsExtension20), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__WhiteBalance20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance20, sizeof(struct tt__WhiteBalance20), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__WideDynamicRange20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRange20, sizeof(struct tt__WideDynamicRange20), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FocusConfiguration20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration20, sizeof(struct tt__FocusConfiguration20), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Exposure20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Exposure20, sizeof(struct tt__Exposure20), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__BacklightCompensation20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensation20, sizeof(struct tt__BacklightCompensation20), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FocusStatus20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusStatus20Extension, sizeof(struct tt__FocusStatus20Extension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImagingStatus20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingStatus20Extension, sizeof(struct tt__ImagingStatus20Extension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FocusStatus20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusStatus20, sizeof(struct tt__FocusStatus20), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ContinuousFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(struct tt__ContinuousFocusOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RelativeFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocusOptions, sizeof(struct tt__RelativeFocusOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AbsoluteFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(struct tt__AbsoluteFocusOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ContinuousFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ContinuousFocus, sizeof(struct tt__ContinuousFocus), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RelativeFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocus, sizeof(struct tt__RelativeFocus), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AbsoluteFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AbsoluteFocus, sizeof(struct tt__AbsoluteFocus), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__WhiteBalanceMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceMode, sizeof(enum tt__WhiteBalanceMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__ExposurePriority **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposurePriority, sizeof(enum tt__ExposurePriority), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__ExposureMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposureMode, sizeof(enum tt__ExposureMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__AutoFocusMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AutoFocusMode, sizeof(enum tt__AutoFocusMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__WideDynamicMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicMode, sizeof(enum tt__WideDynamicMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__WhiteBalanceOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions, sizeof(struct tt__WhiteBalanceOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__WideDynamicRangeOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRangeOptions, sizeof(struct tt__WideDynamicRangeOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions, sizeof(struct tt__FocusOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ExposureOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposureOptions, sizeof(struct tt__ExposureOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__BacklightCompensationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensationOptions, sizeof(struct tt__BacklightCompensationOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Rectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Rectangle, sizeof(struct tt__Rectangle), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImagingSettingsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension, sizeof(struct tt__ImagingSettingsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__WhiteBalance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance, sizeof(struct tt__WhiteBalance), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__WideDynamicRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRange, sizeof(struct tt__WideDynamicRange), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__IrCutFilterMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterMode, sizeof(enum tt__IrCutFilterMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FocusConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration, sizeof(struct tt__FocusConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Exposure **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Exposure, sizeof(struct tt__Exposure), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__BacklightCompensation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensation, sizeof(struct tt__BacklightCompensation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FocusStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusStatus, sizeof(struct tt__FocusStatus), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPresetTourStartingConditionOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, sizeof(struct tt__PTZPresetTourStartingConditionOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPresetTourPresetDetailOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, sizeof(struct tt__PTZPresetTourPresetDetailOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPresetTourPresetDetailOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, sizeof(struct tt__PTZPresetTourPresetDetailOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPresetTourSpotOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSpotOptions, sizeof(struct tt__PTZPresetTourSpotOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPresetTourStartingConditionOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, sizeof(struct tt__PTZPresetTourStartingConditionOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPresetTourStartingConditionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, sizeof(struct tt__PTZPresetTourStartingConditionExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__PTZPresetTourDirection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourDirection, sizeof(enum tt__PTZPresetTourDirection), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPresetTourStatusExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStatusExtension, sizeof(struct tt__PTZPresetTourStatusExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPresetTourTypeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourTypeExtension, sizeof(struct tt__PTZPresetTourTypeExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPresetTourSpotExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSpotExtension, sizeof(struct tt__PTZPresetTourSpotExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZSpeed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpeed, sizeof(struct tt__PTZSpeed), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPresetTourPresetDetail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourPresetDetail, sizeof(struct tt__PTZPresetTourPresetDetail), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPresetTourExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourExtension, sizeof(struct tt__PTZPresetTourExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPresetTourSpot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSpot, sizeof(struct tt__PTZPresetTourSpot), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPresetTourStartingCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStartingCondition, sizeof(struct tt__PTZPresetTourStartingCondition), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPresetTourStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStatus, sizeof(struct tt__PTZPresetTourStatus), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZVector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZVector, sizeof(struct tt__PTZVector), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Vector1D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector1D, sizeof(struct tt__Vector1D), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Vector2D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector2D, sizeof(struct tt__Vector2D), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZSpacesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpacesExtension, sizeof(struct tt__PTZSpacesExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Space1DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space1DDescription, sizeof(struct tt__Space1DDescription), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Space2DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space2DDescription, sizeof(struct tt__Space2DDescription), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ReverseOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReverseOptionsExtension, sizeof(struct tt__ReverseOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__ReverseMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReverseMode, sizeof(enum tt__ReverseMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__EFlipOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EFlipOptionsExtension, sizeof(struct tt__EFlipOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__EFlipMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EFlipMode, sizeof(enum tt__EFlipMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTControlDirectionOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, sizeof(struct tt__PTControlDirectionOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ReverseOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReverseOptions, sizeof(struct tt__ReverseOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__EFlipOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EFlipOptions, sizeof(struct tt__EFlipOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZConfigurationOptions2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationOptions2, sizeof(struct tt__PTZConfigurationOptions2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTControlDirectionOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirectionOptions, sizeof(struct tt__PTControlDirectionOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__DurationRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DurationRange, sizeof(struct tt__DurationRange), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZSpaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpaces, sizeof(struct tt__PTZSpaces), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTControlDirectionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(struct tt__PTControlDirectionExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Reverse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Reverse, sizeof(struct tt__Reverse), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__EFlip **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EFlip, sizeof(struct tt__EFlip), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(struct tt__PTZConfigurationExtension2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTControlDirection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirection, sizeof(struct tt__PTControlDirection), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPresetTourSupportedExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, sizeof(struct tt__PTZPresetTourSupportedExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__PTZPresetTourOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourOperation, sizeof(enum tt__PTZPresetTourOperation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZNodeExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNodeExtension2, sizeof(struct tt__PTZNodeExtension2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZPresetTourSupported **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSupported, sizeof(struct tt__PTZPresetTourSupported), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__EapMethodExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EapMethodExtension, sizeof(struct tt__EapMethodExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__TLSConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TLSConfiguration, sizeof(struct tt__TLSConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Dot1XConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot1XConfigurationExtension, sizeof(struct tt__Dot1XConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__EAPMethodConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(struct tt__EAPMethodConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__CertificateInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateInformationExtension, sizeof(struct tt__CertificateInformationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__DateTimeRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DateTimeRange, sizeof(struct tt__DateTimeRange), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__CertificateUsage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateUsage, sizeof(struct tt__CertificateUsage), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__CertificateGenerationParametersExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateGenerationParametersExtension, sizeof(struct tt__CertificateGenerationParametersExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__UserExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__UserExtension, sizeof(struct tt__UserExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__LocalOrientation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LocalOrientation, sizeof(struct tt__LocalOrientation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__LocalLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LocalLocation, sizeof(struct tt__LocalLocation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__GeoOrientation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GeoOrientation, sizeof(struct tt__GeoOrientation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__GeoLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GeoLocation, sizeof(struct tt__GeoLocation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Date **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Date, sizeof(struct tt__Date), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Time **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Time, sizeof(struct tt__Time), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SystemDateTimeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(struct tt__SystemDateTimeExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SystemLogUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLogUri, sizeof(struct tt__SystemLogUri), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AnalyticsDeviceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceExtension, sizeof(struct tt__AnalyticsDeviceExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SystemCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(struct tt__SystemCapabilitiesExtension2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SystemCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(struct tt__SystemCapabilitiesExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SecurityCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(struct tt__SecurityCapabilitiesExtension2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SecurityCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(struct tt__SecurityCapabilitiesExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(struct tt__NetworkCapabilitiesExtension2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(struct tt__NetworkCapabilitiesExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RealTimeStreamingCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(struct tt__RealTimeStreamingCapabilitiesExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ProfileCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileCapabilities, sizeof(struct tt__ProfileCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MediaCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(struct tt__MediaCapabilitiesExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RealTimeStreamingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(struct tt__RealTimeStreamingCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IOCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilitiesExtension2, sizeof(struct tt__IOCapabilitiesExtension2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AuxiliaryData, sizeof(char *), 1, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IOCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(struct tt__IOCapabilitiesExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__DeviceCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(struct tt__DeviceCapabilitiesExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SecurityCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilities, sizeof(struct tt__SecurityCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IOCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilities, sizeof(struct tt__IOCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SystemCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilities, sizeof(struct tt__SystemCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilities, sizeof(struct tt__NetworkCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__CapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilitiesExtension2, sizeof(struct tt__CapabilitiesExtension2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AnalyticsDeviceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, sizeof(struct tt__AnalyticsDeviceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ReceiverCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(struct tt__ReceiverCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ReplayCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReplayCapabilities, sizeof(struct tt__ReplayCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SearchCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SearchCapabilities, sizeof(struct tt__SearchCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RecordingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingCapabilities, sizeof(struct tt__RecordingCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__DisplayCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DisplayCapabilities, sizeof(struct tt__DisplayCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__DeviceIOCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(struct tt__DeviceIOCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__CapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(struct tt__CapabilitiesExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZCapabilities, sizeof(struct tt__PTZCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MediaCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaCapabilities, sizeof(struct tt__MediaCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImagingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingCapabilities, sizeof(struct tt__ImagingCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__EventCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventCapabilities, sizeof(struct tt__EventCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__DeviceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(struct tt__DeviceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AnalyticsCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(struct tt__AnalyticsCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Dot11AvailableNetworksExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, sizeof(struct tt__Dot11AvailableNetworksExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__Dot11AuthAndMangementSuite **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, sizeof(enum tt__Dot11AuthAndMangementSuite), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__Dot11SignalStrength **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11SignalStrength, sizeof(enum tt__Dot11SignalStrength), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Dot11PSKSetExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSKSetExtension, sizeof(struct tt__Dot11PSKSetExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Dot11SecurityConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, sizeof(struct tt__Dot11SecurityConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Dot11PSKSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSKSet, sizeof(struct tt__Dot11PSKSet), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__Dot11Cipher **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Cipher, sizeof(enum tt__Dot11Cipher), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Dot11SecurityConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(struct tt__Dot11SecurityConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IPAddressFilterExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(struct tt__IPAddressFilterExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkZeroConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, sizeof(struct tt__NetworkZeroConfigurationExtension2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkZeroConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(struct tt__NetworkZeroConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__IPv6DHCPConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkInterfaceSetConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkInterfaceSetConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IPv6NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv6NetworkInterfaceSetConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IPv4NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv4NetworkInterfaceSetConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__DynamicDNSInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(struct tt__DynamicDNSInformationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NTPInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NTPInformationExtension, sizeof(struct tt__NTPInformationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__DNSInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSInformationExtension, sizeof(struct tt__DNSInformationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__HostnameInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(struct tt__HostnameInformationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkHostExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkHostExtension, sizeof(struct tt__NetworkHostExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkProtocolExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(struct tt__NetworkProtocolExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IPv6ConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(struct tt__IPv6ConfigurationExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PrefixedIPv6Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(struct tt__PrefixedIPv6Address), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PrefixedIPv4Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(struct tt__PrefixedIPv4Address), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IPv4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4Configuration, sizeof(struct tt__IPv4Configuration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IPv6Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6Configuration, sizeof(struct tt__IPv6Configuration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkInterfaceConnectionSetting **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(struct tt__NetworkInterfaceConnectionSetting), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkInterfaceExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceExtension2, sizeof(struct tt__NetworkInterfaceExtension2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Dot11Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Configuration, sizeof(struct tt__Dot11Configuration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Dot3Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot3Configuration, sizeof(struct tt__Dot3Configuration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Transport **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Transport, sizeof(struct tt__Transport), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AudioDecoderConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, sizeof(struct tt__AudioDecoderConfigurationOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__G726DecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__G726DecOptions, sizeof(struct tt__G726DecOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__G711DecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__G711DecOptions, sizeof(struct tt__G711DecOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AACDecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AACDecOptions, sizeof(struct tt__AACDecOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoDecoderConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension, sizeof(struct tt__VideoDecoderConfigurationOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Mpeg4DecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4DecOptions, sizeof(struct tt__Mpeg4DecOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__H264DecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264DecOptions, sizeof(struct tt__H264DecOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__JpegDecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegDecOptions, sizeof(struct tt__JpegDecOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZStatusFilterOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, sizeof(struct tt__PTZStatusFilterOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MetadataConfigurationOptionsExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, sizeof(struct tt__MetadataConfigurationOptionsExtension2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MetadataConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, sizeof(struct tt__MetadataConfigurationOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZStatusFilterOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStatusFilterOptions, sizeof(struct tt__PTZStatusFilterOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tt__EventSubscription_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, sizeof(struct _tt__EventSubscription_SubscriptionPolicy), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsnt__FilterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__FilterType, sizeof(struct wsnt__FilterType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AudioEncoderConfigurationOption **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfigurationOption, sizeof(struct tt__AudioEncoderConfigurationOption), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AudioSourceOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceOptionsExtension, sizeof(struct tt__AudioSourceOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoResolution2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoResolution2, sizeof(struct tt__VideoResolution2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__FloatRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FloatRange, sizeof(struct tt__FloatRange), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__H264Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__Mpeg4Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoResolution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoResolution, sizeof(struct tt__VideoResolution), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoEncoderOptionsExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(struct tt__VideoEncoderOptionsExtension2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__H264Options2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Options2, sizeof(struct tt__H264Options2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Mpeg4Options2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Options2, sizeof(struct tt__Mpeg4Options2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__JpegOptions2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegOptions2, sizeof(struct tt__JpegOptions2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoEncoderOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(struct tt__VideoEncoderOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__H264Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Options, sizeof(struct tt__H264Options), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Mpeg4Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Options, sizeof(struct tt__Mpeg4Options), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__JpegOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegOptions, sizeof(struct tt__JpegOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RotateOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateOptionsExtension, sizeof(struct tt__RotateOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IntList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntList, sizeof(struct tt__IntList), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__RotateMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateMode, sizeof(enum tt__RotateMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__SceneOrientationMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SceneOrientationMode, sizeof(enum tt__SceneOrientationMode), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoSourceConfigurationOptionsExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, sizeof(struct tt__VideoSourceConfigurationOptionsExtension2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RotateOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateOptions, sizeof(struct tt__RotateOptions), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoSourceConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, sizeof(struct tt__VideoSourceConfigurationOptionsExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IntRectangleRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRectangleRange, sizeof(struct tt__IntRectangleRange), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__LensProjection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LensProjection, sizeof(struct tt__LensProjection), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__LensOffset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LensOffset, sizeof(struct tt__LensOffset), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RotateExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateExtension, sizeof(struct tt__RotateExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SceneOrientation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SceneOrientation, sizeof(struct tt__SceneOrientation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__LensDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LensDescription, sizeof(struct tt__LensDescription), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoSourceConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, sizeof(struct tt__VideoSourceConfigurationExtension2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Rotate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Rotate, sizeof(struct tt__Rotate), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ProfileExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileExtension2, sizeof(struct tt__ProfileExtension2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(struct tt__AudioDecoderConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(struct tt__AudioOutputConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ProfileExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileExtension, sizeof(struct tt__ProfileExtension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__MetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfiguration, sizeof(struct tt__MetadataConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__PTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfiguration, sizeof(struct tt__PTZConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(struct tt__VideoAnalyticsConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(struct tt__AudioEncoderConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(struct tt__VideoEncoderConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(struct tt__AudioSourceConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(struct tt__VideoSourceConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__VideoSourceExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceExtension2, sizeof(struct tt__VideoSourceExtension2), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__ImagingSettings20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettings20, sizeof(struct tt__ImagingSettings20), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (float **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IntRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRange, sizeof(struct tt__IntRange), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__LocationEntity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LocationEntity, sizeof(struct tt__LocationEntity), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tds__StorageConfigurationData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__StorageConfigurationData, sizeof(struct tds__StorageConfigurationData), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tds__StorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__StorageConfiguration, sizeof(struct tds__StorageConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__GetSystemUrisResponse_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, sizeof(struct _tds__GetSystemUrisResponse_Extension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SystemLogUriList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLogUriList, sizeof(struct tt__SystemLogUriList), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Dot11AvailableNetworks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(struct tt__Dot11AvailableNetworks), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Dot11Status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Status, sizeof(struct tt__Dot11Status), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Dot11Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Capabilities, sizeof(struct tt__Dot11Capabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(struct tt__RelayOutputSettings), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RelayOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayOutput, sizeof(struct tt__RelayOutput), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReferenceToken, sizeof(char *), 1, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Dot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(struct tt__Dot1XConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__CertificateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateInformation, sizeof(struct tt__CertificateInformation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__CertificateWithPrivateKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(struct tt__CertificateWithPrivateKey), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__CertificateStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateStatus, sizeof(struct tt__CertificateStatus), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Certificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Certificate, sizeof(struct tt__Certificate), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__BinaryData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BinaryData, sizeof(struct tt__BinaryData), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddressFilter, sizeof(struct tt__IPAddressFilter), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(struct tt__NetworkZeroConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6Address, sizeof(char *), 1, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4Address, sizeof(char *), 1, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkGateway, sizeof(struct tt__NetworkGateway), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkProtocol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkProtocol, sizeof(struct tt__NetworkProtocol), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(struct tt__NetworkInterfaceSetConfiguration), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterface, sizeof(struct tt__NetworkInterface), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__duration, sizeof(LONG64), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__DynamicDNSInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(struct tt__DynamicDNSInformation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NTPInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NTPInformation, sizeof(struct tt__NTPInformation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__IPAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddress, sizeof(struct tt__IPAddress), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__token, sizeof(char *), 1, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__DNSInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSInformation, sizeof(struct tt__DNSInformation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__HostnameInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__HostnameInformation, sizeof(struct tt__HostnameInformation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum tt__CapabilityCategory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__User **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__User, sizeof(struct tt__User), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__RemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RemoteUser, sizeof(struct tt__RemoteUser), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__NetworkHost **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkHost, sizeof(struct tt__NetworkHost), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(char *), 1, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__Scope **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Scope, sizeof(struct tt__Scope), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SystemLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLog, sizeof(struct tt__SystemLog), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SupportInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportInformation, sizeof(struct tt__SupportInformation), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__BackupFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BackupFile, sizeof(struct tt__BackupFile), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__AttachmentData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AttachmentData, sizeof(struct tt__AttachmentData), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__SystemDateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemDateTime, sizeof(struct tt__SystemDateTime), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__DateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DateTime, sizeof(struct tt__DateTime), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__TimeZone **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TimeZone, sizeof(struct tt__TimeZone), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tds__DeviceServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(struct tds__DeviceServiceCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tds__Service **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__Service, sizeof(struct tds__Service), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__StorageConfigurationData_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StorageConfigurationData_Extension, sizeof(struct _tds__StorageConfigurationData_Extension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tds__UserCredential **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__UserCredential, sizeof(struct tds__UserCredential), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__UserCredential_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UserCredential_Extension, sizeof(struct _tds__UserCredential_Extension), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tds__MiscCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__MiscCapabilities, sizeof(struct tds__MiscCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tds__SystemCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__SystemCapabilities, sizeof(struct tds__SystemCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tds__SecurityCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__SecurityCapabilities, sizeof(struct tds__SecurityCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tds__NetworkCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__NetworkCapabilities, sizeof(struct tds__NetworkCapabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct tt__OnvifVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OnvifVersion, sizeof(struct tt__OnvifVersion), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _tds__Service_Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__Service_Capabilities, sizeof(struct _tds__Service_Capabilities), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct SOAP_ENV__Header **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsse__Security **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsc__SecurityContextTokenType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsse__BinarySecurityToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsse__UsernameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsu__Timestamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__KeyInfoType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__KeyInfo, sizeof(struct ds__KeyInfoType), 1, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct __saml2__union_AttributeStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_AttributeStatementType, sizeof(struct __saml2__union_AttributeStatementType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__AttributeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AttributeType, sizeof(struct saml2__AttributeType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__EvidenceType, sizeof(struct saml2__EvidenceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__ActionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__ActionType, sizeof(struct saml2__ActionType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__AuthnContextType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AuthnContextType, sizeof(struct saml2__AuthnContextType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__SubjectLocalityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__SubjectLocalityType, sizeof(struct saml2__SubjectLocalityType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct __saml2__union_EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_EvidenceType, sizeof(struct __saml2__union_EvidenceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct __saml2__union_AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_AdviceType, sizeof(struct __saml2__union_AdviceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AssertionType, sizeof(struct saml2__AssertionType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct __saml2__union_ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_ConditionsType, sizeof(struct __saml2__union_ConditionsType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__ProxyRestrictionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__ProxyRestrictionType, sizeof(struct saml2__ProxyRestrictionType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__OneTimeUseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__OneTimeUseType, sizeof(struct saml2__OneTimeUseType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__AudienceRestrictionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AudienceRestrictionType, sizeof(struct saml2__AudienceRestrictionType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__ConditionAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__ConditionAbstractType, sizeof(struct saml2__ConditionAbstractType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__SubjectConfirmationDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__SubjectConfirmationDataType, sizeof(struct saml2__SubjectConfirmationDataType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__SubjectConfirmationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__SubjectConfirmationType, sizeof(struct saml2__SubjectConfirmationType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__EncryptedElementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__EncryptedElementType, sizeof(struct saml2__EncryptedElementType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__BaseIDAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__BaseIDAbstractType, sizeof(struct saml2__BaseIDAbstractType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct __saml2__union_AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_AssertionType, sizeof(struct __saml2__union_AssertionType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__AttributeStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AttributeStatementType, sizeof(struct saml2__AttributeStatementType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__AuthzDecisionStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AuthzDecisionStatementType, sizeof(struct saml2__AuthzDecisionStatementType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__AuthnStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AuthnStatementType, sizeof(struct saml2__AuthnStatementType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__StatementAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__StatementAbstractType, sizeof(struct saml2__StatementAbstractType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AdviceType, sizeof(struct saml2__AdviceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__ConditionsType, sizeof(struct saml2__ConditionsType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__SubjectType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__SubjectType, sizeof(struct saml2__SubjectType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml2__NameIDType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__NameIDType, sizeof(struct saml2__NameIDType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct xenc__EncryptedKeyType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 1, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct xenc__EncryptedKeyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__AttributeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AttributeType, sizeof(struct saml1__AttributeType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__EvidenceType, sizeof(struct saml1__EvidenceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__ActionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__ActionType, sizeof(struct saml1__ActionType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__AuthorityBindingType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AuthorityBindingType, sizeof(struct saml1__AuthorityBindingType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__SubjectLocalityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__SubjectLocalityType, sizeof(struct saml1__SubjectLocalityType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__SubjectType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__SubjectType, sizeof(struct saml1__SubjectType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct __saml1__union_EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml1__union_EvidenceType, sizeof(struct __saml1__union_EvidenceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__SubjectConfirmationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__SubjectConfirmationType, sizeof(struct saml1__SubjectConfirmationType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__NameIdentifierType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__NameIdentifierType, sizeof(struct saml1__NameIdentifierType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct __saml1__union_AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml1__union_AdviceType, sizeof(struct __saml1__union_AdviceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AssertionType, sizeof(struct saml1__AssertionType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct __saml1__union_ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml1__union_ConditionsType, sizeof(struct __saml1__union_ConditionsType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__ConditionAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__ConditionAbstractType, sizeof(struct saml1__ConditionAbstractType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__DoNotCacheConditionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__DoNotCacheConditionType, sizeof(struct saml1__DoNotCacheConditionType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__AudienceRestrictionConditionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AudienceRestrictionConditionType, sizeof(struct saml1__AudienceRestrictionConditionType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__Signature, sizeof(struct ds__SignatureType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct __saml1__union_AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml1__union_AssertionType, sizeof(struct __saml1__union_AssertionType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__AttributeStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AttributeStatementType, sizeof(struct saml1__AttributeStatementType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__AuthorizationDecisionStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, sizeof(struct saml1__AuthorizationDecisionStatementType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__AuthenticationStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AuthenticationStatementType, sizeof(struct saml1__AuthenticationStatementType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__SubjectStatementAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__SubjectStatementAbstractType, sizeof(struct saml1__SubjectStatementAbstractType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__StatementAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__StatementAbstractType, sizeof(struct saml1__StatementAbstractType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AdviceType, sizeof(struct saml1__AdviceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct saml1__ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__ConditionsType, sizeof(struct saml1__ConditionsType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct __wsc__DerivedKeyTokenType_sequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, sizeof(struct __wsc__DerivedKeyTokenType_sequence), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (ULONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ULONG64, sizeof(ULONG64), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsc__PropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _xenc__ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct __xenc__union_ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct xenc__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct xenc__EncryptionPropertyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct xenc__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct xenc__CipherReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct xenc__EncryptionPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct xenc__CipherDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__KeyInfo, sizeof(struct ds__KeyInfoType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct xenc__EncryptionMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__X509IssuerSerialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__RSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__DSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__TransformType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__DigestMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__ReferenceType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 1, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__SignatureMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__CanonicalizationMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsse__SecurityTokenReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__RetrievalMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__KeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _c14n__InclusiveNamespaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__SignedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct ds__X509DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsse__Embedded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsse__KeyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsse__Reference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsse__EncodedString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsse__EncodedString, sizeof(struct wsse__EncodedString), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct _wsse__Password **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct chan__ChannelInstanceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsdd__ResolveMatchesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveMatchesType, sizeof(struct wsdd__ResolveMatchesType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsdd__ResolveType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveType, sizeof(struct wsdd__ResolveType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsdd__ProbeMatchesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeMatchesType, sizeof(struct wsdd__ProbeMatchesType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsdd__ProbeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeType, sizeof(struct wsdd__ProbeType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsdd__ByeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ByeType, sizeof(struct wsdd__ByeType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsdd__HelloType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__HelloType, sizeof(struct wsdd__HelloType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsdd__AppSequenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__AppSequenceType, sizeof(struct wsdd__AppSequenceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsdd__SigType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__SigType, sizeof(struct wsdd__SigType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsdd__ResolveMatchType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveMatchType, sizeof(struct wsdd__ResolveMatchType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsdd__ProbeMatchType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeMatchType, sizeof(struct wsdd__ProbeMatchType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (unsigned int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedInt, sizeof(unsigned int), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsdd__ScopesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ScopesType, sizeof(struct wsdd__ScopesType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__FaultTo, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__ReplyTo, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__From, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsa__Relationship **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__RelatesTo, sizeof(struct wsa__Relationship), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsa__ServiceNameType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__QName, sizeof(char *), 1, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsa__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:	if (!soap->null && *soap->href != '#')
./soapC.c:	{	a = (struct wsa__ReferencePropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0, NULL);
./soapC.c:		if (soap->body && soap_element_end_in(soap, tag))
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapC.c:		return soap->error;
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
./soapClient.c:		soap->error = SOAP_OK;
./soapClient.c:	if (soap->error
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
./soapClient.c:		soap->error = SOAP_OK;
./soapClient.c:	if (soap->error
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
./soapClient.c:		soap->error = SOAP_OK;
./soapClient.c:	if (soap->error
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
./soapClient.c:		soap->error = SOAP_OK;
./soapClient.c:	if (soap->error
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
./soapClient.c:		soap->error = SOAP_OK;
./soapClient.c:	if (soap->error
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
./soapClient.c:		soap->error = SOAP_OK;
./soapClient.c:	if (soap->error
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
./soapClient.c:		soap->error = SOAP_OK;
./soapClient.c:	if (soap->error
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
./soapClient.c:		soap->error = SOAP_OK;
./soapClient.c:	if (soap->error
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
./soapClient.c:		soap->error = SOAP_OK;
./soapClient.c:	if (soap->error
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
./soapClient.c:		soap->error = SOAP_OK;
./soapClient.c:	if (soap->error
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapClient.c:	soap->encodingStyle = NULL;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapClient.c:			 return soap->error;
./soapClient.c:		return soap->error;
./soapClient.c:	if (soap->error)
./soapServer.c:	soap->keep_alive = soap->max_keep_alive + 1;
./soapServer.c:		if (soap->keep_alive > 0 && soap->max_keep_alive > 0)
./soapServer.c:			soap->keep_alive--;
./soapServer.c:		{	if (soap->error >= SOAP_STOP)
./soapServer.c:			return soap->error;
./soapServer.c:		if ((soap_serve_request(soap) || (soap->fserveloop && soap->fserveloop(soap))) && soap->error && soap->error < SOAP_STOP)
./soapServer.c:	} while (soap->keep_alive);
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "SOAP-ENV:Fault"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsdd:Hello"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsdd:Bye"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsdd:Probe"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsdd:ProbeMatches"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsdd:Resolve"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsdd:ResolveMatches"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "SOAP-ENV:Fault"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns1:GetSupportedActions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns1:GetActions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns1:CreateActions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns1:DeleteActions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns1:ModifyActions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns1:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns1:GetActionTriggers"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns1:CreateActionTriggers"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns1:DeleteActionTriggers"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns1:ModifyActionTriggers"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns2:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns2:GetAccessPointInfoList"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns2:GetAccessPointInfo"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns2:GetAreaInfoList"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns2:GetAreaInfo"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns2:GetAccessPointState"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns2:EnableAccessPoint"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns2:DisableAccessPoint"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns2:ExternalAuthorization"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns4:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns4:GetDoorInfoList"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns4:GetDoorInfo"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns4:GetDoorState"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns4:AccessDoor"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns4:LockDoor"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns4:UnlockDoor"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns4:BlockDoor"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns4:LockDownDoor"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns4:LockDownReleaseDoor"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns4:LockOpenDoor"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns4:LockOpenReleaseDoor"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns4:DoubleLockDoor"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:CreateRSAKeyPair"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:UploadKeyPairInPKCS8"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:UploadCertificateWithPrivateKeyInPKCS12"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetKeyStatus"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetPrivateKeyStatus"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetAllKeys"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:DeleteKey"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:CreatePKCS10CSR"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:CreateSelfSignedCertificate"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:UploadCertificate"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetCertificate"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetAllCertificates"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:DeleteCertificate"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:CreateCertificationPath"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetCertificationPath"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetAllCertificationPaths"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:DeleteCertificationPath"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:UploadPassphrase"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetAllPassphrases"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:DeletePassphrase"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:UploadCRL"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetCRL"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetAllCRLs"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:DeleteCRL"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:CreateCertPathValidationPolicy"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetCertPathValidationPolicy"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetAllCertPathValidationPolicies"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:DeleteCertPathValidationPolicy"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:AddServerCertificateAssignment"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:RemoveServerCertificateAssignment"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:ReplaceServerCertificateAssignment"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetAssignedServerCertificates"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:SetClientAuthenticationRequired"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetClientAuthenticationRequired"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:AddCertPathValidationPolicyAssignment"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:RemoveCertPathValidationPolicyAssignment"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:ReplaceCertPathValidationPolicyAssignment"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetAssignedCertPathValidationPolicies"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:AddDot1XConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetAllDot1XConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetDot1XConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:DeleteDot1XConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:SetNetworkInterfaceDot1XConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:GetNetworkInterfaceDot1XConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "ns5:DeleteNetworkInterfaceDot1XConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tad:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tad:DeleteAnalyticsEngineControl"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tad:CreateAnalyticsEngineControl"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tad:SetAnalyticsEngineControl"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tad:GetAnalyticsEngineControl"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tad:GetAnalyticsEngineControls"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tad:GetAnalyticsEngine"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tad:GetAnalyticsEngines"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tad:SetVideoAnalyticsConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tad:SetAnalyticsEngineInput"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tad:GetAnalyticsEngineInput"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tad:GetAnalyticsEngineInputs"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tad:GetAnalyticsDeviceStreamUri"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tad:GetVideoAnalyticsConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tad:CreateAnalyticsEngineInputs"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tad:DeleteAnalyticsEngineInputs"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tad:GetAnalyticsState"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tan:GetSupportedRules"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tan:CreateRules"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tan:DeleteRules"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tan:GetRules"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tan:GetRuleOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tan:ModifyRules"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tan:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tan:GetSupportedAnalyticsModules"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tan:CreateAnalyticsModules"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tan:DeleteAnalyticsModules"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tan:GetAnalyticsModules"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tan:ModifyAnalyticsModules"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tdn:Hello"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tdn:Bye"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tdn:Probe"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetServices"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDeviceInformation"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetSystemDateAndTime"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetSystemDateAndTime"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetSystemFactoryDefault"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:UpgradeSystemFirmware"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SystemReboot"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:RestoreSystem"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetSystemBackup"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetSystemLog"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetSystemSupportInformation"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetScopes"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetScopes"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:AddScopes"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:RemoveScopes"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDiscoveryMode"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetDiscoveryMode"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetRemoteDiscoveryMode"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetRemoteDiscoveryMode"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDPAddresses"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetEndpointReference"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetRemoteUser"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetRemoteUser"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetUsers"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:CreateUsers"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:DeleteUsers"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetUser"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetWsdlUrl"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetDPAddresses"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetHostname"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetHostname"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetHostnameFromDHCP"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDNS"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetDNS"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetNTP"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetNTP"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDynamicDNS"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetDynamicDNS"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetNetworkInterfaces"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetNetworkInterfaces"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetNetworkProtocols"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetNetworkProtocols"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetNetworkDefaultGateway"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetNetworkDefaultGateway"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetZeroConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetZeroConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetIPAddressFilter"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetIPAddressFilter"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:AddIPAddressFilter"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:RemoveIPAddressFilter"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetAccessPolicy"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetAccessPolicy"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:CreateCertificate"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetCertificates"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetCertificatesStatus"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetCertificatesStatus"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:DeleteCertificates"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetPkcs10Request"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:LoadCertificates"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetClientCertificateMode"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetClientCertificateMode"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetRelayOutputs"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetRelayOutputSettings"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetRelayOutputState"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SendAuxiliaryCommand"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetCACertificates"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:LoadCertificateWithPrivateKey"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetCertificateInformation"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:LoadCACertificates"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:CreateDot1XConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetDot1XConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDot1XConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDot1XConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:DeleteDot1XConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDot11Capabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDot11Status"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:ScanAvailableDot11Networks"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetSystemUris"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:StartFirmwareUpgrade"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:StartSystemRestore"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetStorageConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:CreateStorageConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetStorageConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetStorageConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:DeleteStorageConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetGeoLocation"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetGeoLocation"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:DeleteGeoLocation"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetServices"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDeviceInformation"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetSystemDateAndTime"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetSystemDateAndTime"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetSystemFactoryDefault"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:UpgradeSystemFirmware"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SystemReboot"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:RestoreSystem"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetSystemBackup"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetSystemLog"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetSystemSupportInformation"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetScopes"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetScopes"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:AddScopes"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:RemoveScopes"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDiscoveryMode"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetDiscoveryMode"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetRemoteDiscoveryMode"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetRemoteDiscoveryMode"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDPAddresses"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetEndpointReference"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetRemoteUser"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetRemoteUser"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetUsers"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:CreateUsers"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:DeleteUsers"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetUser"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetWsdlUrl"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetDPAddresses"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetHostname"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetHostname"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetHostnameFromDHCP"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDNS"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetDNS"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetNTP"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetNTP"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDynamicDNS"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetDynamicDNS"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetNetworkInterfaces"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetNetworkInterfaces"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetNetworkProtocols"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetNetworkProtocols"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetNetworkDefaultGateway"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetNetworkDefaultGateway"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetZeroConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetZeroConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetIPAddressFilter"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetIPAddressFilter"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:AddIPAddressFilter"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:RemoveIPAddressFilter"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetAccessPolicy"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetAccessPolicy"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:CreateCertificate"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetCertificates"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetCertificatesStatus"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetCertificatesStatus"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:DeleteCertificates"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetPkcs10Request"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:LoadCertificates"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetClientCertificateMode"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetClientCertificateMode"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetRelayOutputs"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetRelayOutputSettings"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetRelayOutputState"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SendAuxiliaryCommand"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetCACertificates"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:LoadCertificateWithPrivateKey"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetCertificateInformation"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:LoadCACertificates"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:CreateDot1XConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetDot1XConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDot1XConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDot1XConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:DeleteDot1XConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDot11Capabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetDot11Status"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:ScanAvailableDot11Networks"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetSystemUris"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:StartFirmwareUpgrade"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:StartSystemRestore"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetStorageConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:CreateStorageConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetStorageConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetStorageConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:DeleteStorageConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetGeoLocation"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetGeoLocation"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:DeleteGeoLocation"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tev:PullMessages"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tev:Seek"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tev:SetSynchronizationPoint"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tev:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tev:CreatePullPointSubscription"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tev:GetEventProperties"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsnt:Renew"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsnt:Unsubscribe"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsnt:Subscribe"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsnt:GetCurrentMessage"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsnt:Notify"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsnt:GetMessages"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsnt:DestroyPullPoint"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsnt:Notify"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsnt:CreatePullPoint"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsnt:Renew"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsnt:Unsubscribe"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsnt:PauseSubscription"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "wsnt:ResumeSubscription"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "timg:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "timg:GetImagingSettings"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "timg:SetImagingSettings"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "timg:GetOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "timg:Move"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "timg:Stop"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "timg:GetStatus"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "timg:GetMoveOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "timg:GetPresets"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "timg:GetCurrentPreset"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "timg:SetCurrentPreset"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tls:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tls:GetLayout"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tls:SetLayout"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tls:GetDisplayOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tls:GetPaneConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tls:GetPaneConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tls:SetPaneConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tls:SetPaneConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tls:CreatePaneConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tls:DeletePaneConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetRelayOutputOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetAudioSources"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetAudioOutputs"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetVideoSources"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetVideoOutputs"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetVideoSourceConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetVideoOutputConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetAudioSourceConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetAudioOutputConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:SetVideoSourceConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:SetVideoOutputConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:SetAudioSourceConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:SetAudioOutputConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetVideoSourceConfigurationOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetVideoOutputConfigurationOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetAudioSourceConfigurationOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetAudioOutputConfigurationOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:GetRelayOutputs"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:SetRelayOutputSettings"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tds:SetRelayOutputState"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetDigitalInputs"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetDigitalInputConfigurationOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:SetDigitalInputConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetSerialPorts"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetSerialPortConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:SetSerialPortConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:GetSerialPortConfigurationOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tmd:SendReceiveSerialCommand"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:GetConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:GetPresets"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:SetPreset"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:RemovePreset"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:GotoPreset"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:GetStatus"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:GetConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:GetNodes"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:GetNode"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:SetConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:GetConfigurationOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:GotoHomePosition"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:SetHomePosition"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:ContinuousMove"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:RelativeMove"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:SendAuxiliaryCommand"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:AbsoluteMove"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:Stop"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:GetPresetTours"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:GetPresetTour"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:GetPresetTourOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:CreatePresetTour"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:ModifyPresetTour"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:OperatePresetTour"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:RemovePresetTour"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tptz:GetCompatibleConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:CreateRecording"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:DeleteRecording"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:GetRecordings"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:SetRecordingConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:GetRecordingConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:GetRecordingOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:CreateTrack"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:DeleteTrack"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:GetTrackConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:SetTrackConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:CreateRecordingJob"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:DeleteRecordingJob"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:GetRecordingJobs"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:SetRecordingJobConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:GetRecordingJobConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:SetRecordingJobMode"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:GetRecordingJobState"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:ExportRecordedData"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:StopExportRecordedData"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trc:GetExportRecordedDataState"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trp:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trp:GetReplayUri"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trp:GetReplayConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trp:SetReplayConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetVideoSources"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetAudioSources"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetAudioOutputs"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:CreateProfile"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetProfile"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetProfiles"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:AddVideoEncoderConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:AddVideoSourceConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:AddAudioEncoderConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:AddAudioSourceConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:AddPTZConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:AddVideoAnalyticsConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:AddMetadataConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:AddAudioOutputConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:AddAudioDecoderConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:RemoveVideoEncoderConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:RemoveVideoSourceConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:RemoveAudioEncoderConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:RemoveAudioSourceConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:RemovePTZConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:RemoveVideoAnalyticsConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:RemoveMetadataConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:RemoveAudioOutputConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:RemoveAudioDecoderConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:DeleteProfile"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetVideoSourceConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetVideoEncoderConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetAudioSourceConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetAudioEncoderConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetVideoAnalyticsConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetMetadataConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetAudioOutputConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetAudioDecoderConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetVideoSourceConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetVideoEncoderConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetAudioSourceConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetAudioEncoderConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetVideoAnalyticsConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetMetadataConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetAudioOutputConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetAudioDecoderConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetCompatibleVideoEncoderConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetCompatibleVideoSourceConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetCompatibleAudioEncoderConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetCompatibleAudioSourceConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetCompatibleVideoAnalyticsConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetCompatibleMetadataConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetCompatibleAudioOutputConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetCompatibleAudioDecoderConfigurations"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:SetVideoSourceConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:SetVideoEncoderConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:SetAudioSourceConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:SetAudioEncoderConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:SetVideoAnalyticsConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:SetMetadataConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:SetAudioOutputConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:SetAudioDecoderConfiguration"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetVideoSourceConfigurationOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetVideoEncoderConfigurationOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetAudioSourceConfigurationOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetAudioEncoderConfigurationOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetMetadataConfigurationOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetAudioOutputConfigurationOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetAudioDecoderConfigurationOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetGuaranteedNumberOfVideoEncoderInstances"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetStreamUri"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:StartMulticastStreaming"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:StopMulticastStreaming"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:SetSynchronizationPoint"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetSnapshotUri"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetVideoSourceModes"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:SetVideoSourceMode"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetOSDs"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetOSD"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:GetOSDOptions"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:SetOSD"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:CreateOSD"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trt:DeleteOSD"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trv:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trv:GetReceivers"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trv:GetReceiver"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trv:CreateReceiver"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trv:DeleteReceiver"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trv:ConfigureReceiver"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trv:SetReceiverMode"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "trv:GetReceiverState"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tse:GetServiceCapabilities"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tse:GetRecordingSummary"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tse:GetRecordingInformation"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tse:GetMediaAttributes"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tse:FindRecordings"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tse:GetRecordingSearchResults"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tse:FindEvents"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tse:GetEventSearchResults"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tse:FindPTZPosition"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tse:GetPTZPositionSearchResults"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tse:GetSearchState"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tse:EndSearch"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tse:FindMetadata"))
./soapServer.c:	if (!soap_match_tag(soap, soap->tag, "tse:GetMetadataSearchResults"))
./soapServer.c:	return soap->error = SOAP_NO_METHOD;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = SOAP_ENV__Fault(soap, soap_tmp_SOAP_ENV__Fault.faultcode, soap_tmp_SOAP_ENV__Fault.faultstring, soap_tmp_SOAP_ENV__Fault.faultactor, soap_tmp_SOAP_ENV__Fault.detail, soap_tmp_SOAP_ENV__Fault.SOAP_ENV__Code, soap_tmp_SOAP_ENV__Fault.SOAP_ENV__Reason, soap_tmp_SOAP_ENV__Fault.SOAP_ENV__Node, soap_tmp_SOAP_ENV__Fault.SOAP_ENV__Role, soap_tmp_SOAP_ENV__Fault.SOAP_ENV__Detail);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __wsdd__Hello(soap, soap_tmp___wsdd__Hello.wsdd__Hello);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __wsdd__Bye(soap, soap_tmp___wsdd__Bye.wsdd__Bye);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __wsdd__Probe(soap, soap_tmp___wsdd__Probe.wsdd__Probe);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __wsdd__ProbeMatches(soap, soap_tmp___wsdd__ProbeMatches.wsdd__ProbeMatches);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __wsdd__Resolve(soap, soap_tmp___wsdd__Resolve.wsdd__Resolve);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __wsdd__ResolveMatches(soap, soap_tmp___wsdd__ResolveMatches.wsdd__ResolveMatches);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = SOAP_ENV__Fault(soap, soap_tmp_SOAP_ENV__Fault.faultcode, soap_tmp_SOAP_ENV__Fault.faultstring, soap_tmp_SOAP_ENV__Fault.faultactor, soap_tmp_SOAP_ENV__Fault.detail, soap_tmp_SOAP_ENV__Fault.SOAP_ENV__Code, soap_tmp_SOAP_ENV__Fault.SOAP_ENV__Reason, soap_tmp_SOAP_ENV__Fault.SOAP_ENV__Node, soap_tmp_SOAP_ENV__Fault.SOAP_ENV__Role, soap_tmp_SOAP_ENV__Fault.SOAP_ENV__Detail);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns1__GetSupportedActions(soap, soap_tmp___ns1__GetSupportedActions.ns1__GetSupportedActions, &ns1__GetSupportedActionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns1__GetActions(soap, soap_tmp___ns1__GetActions.ns1__GetActions, &ns1__GetActionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns1__CreateActions(soap, soap_tmp___ns1__CreateActions.ns1__CreateActions, &ns1__CreateActionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns1__DeleteActions(soap, soap_tmp___ns1__DeleteActions.ns1__DeleteActions, &ns1__DeleteActionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns1__ModifyActions(soap, soap_tmp___ns1__ModifyActions.ns1__ModifyActions, &ns1__ModifyActionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns1__GetServiceCapabilities(soap, soap_tmp___ns1__GetServiceCapabilities.ns1__GetServiceCapabilities, &ns1__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns1__GetActionTriggers(soap, soap_tmp___ns1__GetActionTriggers.ns1__GetActionTriggers, &ns1__GetActionTriggersResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns1__CreateActionTriggers(soap, soap_tmp___ns1__CreateActionTriggers.ns1__CreateActionTriggers, &ns1__CreateActionTriggersResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns1__DeleteActionTriggers(soap, soap_tmp___ns1__DeleteActionTriggers.ns1__DeleteActionTriggers, &ns1__DeleteActionTriggersResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns1__ModifyActionTriggers(soap, soap_tmp___ns1__ModifyActionTriggers.ns1__ModifyActionTriggers, &ns1__ModifyActionTriggersResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns2__GetServiceCapabilities(soap, soap_tmp___ns2__GetServiceCapabilities.ns2__GetServiceCapabilities, &ns2__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns2__GetAccessPointInfoList(soap, soap_tmp___ns2__GetAccessPointInfoList.ns2__GetAccessPointInfoList, &ns2__GetAccessPointInfoListResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns2__GetAccessPointInfo(soap, soap_tmp___ns2__GetAccessPointInfo.ns2__GetAccessPointInfo, &ns2__GetAccessPointInfoResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns2__GetAreaInfoList(soap, soap_tmp___ns2__GetAreaInfoList.ns2__GetAreaInfoList, &ns2__GetAreaInfoListResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns2__GetAreaInfo(soap, soap_tmp___ns2__GetAreaInfo.ns2__GetAreaInfo, &ns2__GetAreaInfoResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns2__GetAccessPointState(soap, soap_tmp___ns2__GetAccessPointState.ns2__GetAccessPointState, &ns2__GetAccessPointStateResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns2__EnableAccessPoint(soap, soap_tmp___ns2__EnableAccessPoint.ns2__EnableAccessPoint, &ns2__EnableAccessPointResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns2__DisableAccessPoint(soap, soap_tmp___ns2__DisableAccessPoint.ns2__DisableAccessPoint, &ns2__DisableAccessPointResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns2__ExternalAuthorization(soap, soap_tmp___ns2__ExternalAuthorization.ns2__ExternalAuthorization, &ns2__ExternalAuthorizationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns4__GetServiceCapabilities(soap, soap_tmp___ns4__GetServiceCapabilities.ns4__GetServiceCapabilities, &ns4__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns4__GetDoorInfoList(soap, soap_tmp___ns4__GetDoorInfoList.ns4__GetDoorInfoList, &ns4__GetDoorInfoListResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns4__GetDoorInfo(soap, soap_tmp___ns4__GetDoorInfo.ns4__GetDoorInfo, &ns4__GetDoorInfoResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns4__GetDoorState(soap, soap_tmp___ns4__GetDoorState.ns4__GetDoorState, &ns4__GetDoorStateResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns4__AccessDoor(soap, soap_tmp___ns4__AccessDoor.ns4__AccessDoor, &ns4__AccessDoorResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns4__LockDoor(soap, soap_tmp___ns4__LockDoor.ns4__LockDoor, &ns4__LockDoorResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns4__UnlockDoor(soap, soap_tmp___ns4__UnlockDoor.ns4__UnlockDoor, &ns4__UnlockDoorResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns4__BlockDoor(soap, soap_tmp___ns4__BlockDoor.ns4__BlockDoor, &ns4__BlockDoorResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns4__LockDownDoor(soap, soap_tmp___ns4__LockDownDoor.ns4__LockDownDoor, &ns4__LockDownDoorResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns4__LockDownReleaseDoor(soap, soap_tmp___ns4__LockDownReleaseDoor.ns4__LockDownReleaseDoor, &ns4__LockDownReleaseDoorResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns4__LockOpenDoor(soap, soap_tmp___ns4__LockOpenDoor.ns4__LockOpenDoor, &ns4__LockOpenDoorResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns4__LockOpenReleaseDoor(soap, soap_tmp___ns4__LockOpenReleaseDoor.ns4__LockOpenReleaseDoor, &ns4__LockOpenReleaseDoorResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns4__DoubleLockDoor(soap, soap_tmp___ns4__DoubleLockDoor.ns4__DoubleLockDoor, &ns4__DoubleLockDoorResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetServiceCapabilities(soap, soap_tmp___ns5__GetServiceCapabilities.ns5__GetServiceCapabilities, &ns5__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__CreateRSAKeyPair(soap, soap_tmp___ns5__CreateRSAKeyPair.ns5__CreateRSAKeyPair, &ns5__CreateRSAKeyPairResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__UploadKeyPairInPKCS8(soap, soap_tmp___ns5__UploadKeyPairInPKCS8.ns5__UploadKeyPairInPKCS8, &ns5__UploadKeyPairInPKCS8Response);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__UploadCertificateWithPrivateKeyInPKCS12(soap, soap_tmp___ns5__UploadCertificateWithPrivateKeyInPKCS12.ns5__UploadCertificateWithPrivateKeyInPKCS12, &ns5__UploadCertificateWithPrivateKeyInPKCS12Response);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetKeyStatus(soap, soap_tmp___ns5__GetKeyStatus.ns5__GetKeyStatus, &ns5__GetKeyStatusResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetPrivateKeyStatus(soap, soap_tmp___ns5__GetPrivateKeyStatus.ns5__GetPrivateKeyStatus, &ns5__GetPrivateKeyStatusResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetAllKeys(soap, soap_tmp___ns5__GetAllKeys.ns5__GetAllKeys, &ns5__GetAllKeysResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__DeleteKey(soap, soap_tmp___ns5__DeleteKey.ns5__DeleteKey, &ns5__DeleteKeyResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__CreatePKCS10CSR(soap, soap_tmp___ns5__CreatePKCS10CSR.ns5__CreatePKCS10CSR, &ns5__CreatePKCS10CSRResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__CreateSelfSignedCertificate(soap, soap_tmp___ns5__CreateSelfSignedCertificate.ns5__CreateSelfSignedCertificate, &ns5__CreateSelfSignedCertificateResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__UploadCertificate(soap, soap_tmp___ns5__UploadCertificate.ns5__UploadCertificate, &ns5__UploadCertificateResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetCertificate(soap, soap_tmp___ns5__GetCertificate.ns5__GetCertificate, &ns5__GetCertificateResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetAllCertificates(soap, soap_tmp___ns5__GetAllCertificates.ns5__GetAllCertificates, &ns5__GetAllCertificatesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__DeleteCertificate(soap, soap_tmp___ns5__DeleteCertificate.ns5__DeleteCertificate, &ns5__DeleteCertificateResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__CreateCertificationPath(soap, soap_tmp___ns5__CreateCertificationPath.ns5__CreateCertificationPath, &ns5__CreateCertificationPathResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetCertificationPath(soap, soap_tmp___ns5__GetCertificationPath.ns5__GetCertificationPath, &ns5__GetCertificationPathResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetAllCertificationPaths(soap, soap_tmp___ns5__GetAllCertificationPaths.ns5__GetAllCertificationPaths, &ns5__GetAllCertificationPathsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__DeleteCertificationPath(soap, soap_tmp___ns5__DeleteCertificationPath.ns5__DeleteCertificationPath, &ns5__DeleteCertificationPathResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__UploadPassphrase(soap, soap_tmp___ns5__UploadPassphrase.ns5__UploadPassphrase, &ns5__UploadPassphraseResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetAllPassphrases(soap, soap_tmp___ns5__GetAllPassphrases.ns5__GetAllPassphrases, &ns5__GetAllPassphrasesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__DeletePassphrase(soap, soap_tmp___ns5__DeletePassphrase.ns5__DeletePassphrase, &ns5__DeletePassphraseResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__UploadCRL(soap, soap_tmp___ns5__UploadCRL.ns5__UploadCRL, &ns5__UploadCRLResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetCRL(soap, soap_tmp___ns5__GetCRL.ns5__GetCRL, &ns5__GetCRLResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetAllCRLs(soap, soap_tmp___ns5__GetAllCRLs.ns5__GetAllCRLs, &ns5__GetAllCRLsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__DeleteCRL(soap, soap_tmp___ns5__DeleteCRL.ns5__DeleteCRL, &ns5__DeleteCRLResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__CreateCertPathValidationPolicy(soap, soap_tmp___ns5__CreateCertPathValidationPolicy.ns5__CreateCertPathValidationPolicy, &ns5__CreateCertPathValidationPolicyResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetCertPathValidationPolicy(soap, soap_tmp___ns5__GetCertPathValidationPolicy.ns5__GetCertPathValidationPolicy, &ns5__GetCertPathValidationPolicyResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetAllCertPathValidationPolicies(soap, soap_tmp___ns5__GetAllCertPathValidationPolicies.ns5__GetAllCertPathValidationPolicies, &ns5__GetAllCertPathValidationPoliciesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__DeleteCertPathValidationPolicy(soap, soap_tmp___ns5__DeleteCertPathValidationPolicy.ns5__DeleteCertPathValidationPolicy, &ns5__DeleteCertPathValidationPolicyResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__AddServerCertificateAssignment(soap, soap_tmp___ns5__AddServerCertificateAssignment.ns5__AddServerCertificateAssignment, &ns5__AddServerCertificateAssignmentResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__RemoveServerCertificateAssignment(soap, soap_tmp___ns5__RemoveServerCertificateAssignment.ns5__RemoveServerCertificateAssignment, &ns5__RemoveServerCertificateAssignmentResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__ReplaceServerCertificateAssignment(soap, soap_tmp___ns5__ReplaceServerCertificateAssignment.ns5__ReplaceServerCertificateAssignment, &ns5__ReplaceServerCertificateAssignmentResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetAssignedServerCertificates(soap, soap_tmp___ns5__GetAssignedServerCertificates.ns5__GetAssignedServerCertificates, &ns5__GetAssignedServerCertificatesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__SetClientAuthenticationRequired(soap, soap_tmp___ns5__SetClientAuthenticationRequired.ns5__SetClientAuthenticationRequired, &ns5__SetClientAuthenticationRequiredResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetClientAuthenticationRequired(soap, soap_tmp___ns5__GetClientAuthenticationRequired.ns5__GetClientAuthenticationRequired, &ns5__GetClientAuthenticationRequiredResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__AddCertPathValidationPolicyAssignment(soap, soap_tmp___ns5__AddCertPathValidationPolicyAssignment.ns5__AddCertPathValidationPolicyAssignment, &ns5__AddCertPathValidationPolicyAssignmentResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__RemoveCertPathValidationPolicyAssignment(soap, soap_tmp___ns5__RemoveCertPathValidationPolicyAssignment.ns5__RemoveCertPathValidationPolicyAssignment, &ns5__RemoveCertPathValidationPolicyAssignmentResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__ReplaceCertPathValidationPolicyAssignment(soap, soap_tmp___ns5__ReplaceCertPathValidationPolicyAssignment.ns5__ReplaceCertPathValidationPolicyAssignment, &ns5__ReplaceCertPathValidationPolicyAssignmentResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetAssignedCertPathValidationPolicies(soap, soap_tmp___ns5__GetAssignedCertPathValidationPolicies.ns5__GetAssignedCertPathValidationPolicies, &ns5__GetAssignedCertPathValidationPoliciesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__AddDot1XConfiguration(soap, soap_tmp___ns5__AddDot1XConfiguration.ns5__AddDot1XConfiguration, &ns5__AddDot1XConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetAllDot1XConfigurations(soap, soap_tmp___ns5__GetAllDot1XConfigurations.ns5__GetAllDot1XConfigurations, &ns5__GetAllDot1XConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetDot1XConfiguration(soap, soap_tmp___ns5__GetDot1XConfiguration.ns5__GetDot1XConfiguration, &ns5__GetDot1XConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__DeleteDot1XConfiguration(soap, soap_tmp___ns5__DeleteDot1XConfiguration.ns5__DeleteDot1XConfiguration, &ns5__DeleteDot1XConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__SetNetworkInterfaceDot1XConfiguration(soap, soap_tmp___ns5__SetNetworkInterfaceDot1XConfiguration.ns5__SetNetworkInterfaceDot1XConfiguration, &ns5__SetNetworkInterfaceDot1XConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__GetNetworkInterfaceDot1XConfiguration(soap, soap_tmp___ns5__GetNetworkInterfaceDot1XConfiguration.ns5__GetNetworkInterfaceDot1XConfiguration, &ns5__GetNetworkInterfaceDot1XConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __ns5__DeleteNetworkInterfaceDot1XConfiguration(soap, soap_tmp___ns5__DeleteNetworkInterfaceDot1XConfiguration.ns5__DeleteNetworkInterfaceDot1XConfiguration, &ns5__DeleteNetworkInterfaceDot1XConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tad__GetServiceCapabilities(soap, soap_tmp___tad__GetServiceCapabilities.tad__GetServiceCapabilities, &tad__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tad__DeleteAnalyticsEngineControl(soap, soap_tmp___tad__DeleteAnalyticsEngineControl.tad__DeleteAnalyticsEngineControl, &tad__DeleteAnalyticsEngineControlResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tad__CreateAnalyticsEngineControl(soap, soap_tmp___tad__CreateAnalyticsEngineControl.tad__CreateAnalyticsEngineControl, &tad__CreateAnalyticsEngineControlResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tad__SetAnalyticsEngineControl(soap, soap_tmp___tad__SetAnalyticsEngineControl.tad__SetAnalyticsEngineControl, &tad__SetAnalyticsEngineControlResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tad__GetAnalyticsEngineControl(soap, soap_tmp___tad__GetAnalyticsEngineControl.tad__GetAnalyticsEngineControl, &tad__GetAnalyticsEngineControlResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tad__GetAnalyticsEngineControls(soap, soap_tmp___tad__GetAnalyticsEngineControls.tad__GetAnalyticsEngineControls, &tad__GetAnalyticsEngineControlsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tad__GetAnalyticsEngine(soap, soap_tmp___tad__GetAnalyticsEngine.tad__GetAnalyticsEngine, &tad__GetAnalyticsEngineResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tad__GetAnalyticsEngines(soap, soap_tmp___tad__GetAnalyticsEngines.tad__GetAnalyticsEngines, &tad__GetAnalyticsEnginesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tad__SetVideoAnalyticsConfiguration(soap, soap_tmp___tad__SetVideoAnalyticsConfiguration.tad__SetVideoAnalyticsConfiguration, &tad__SetVideoAnalyticsConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tad__SetAnalyticsEngineInput(soap, soap_tmp___tad__SetAnalyticsEngineInput.tad__SetAnalyticsEngineInput, &tad__SetAnalyticsEngineInputResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tad__GetAnalyticsEngineInput(soap, soap_tmp___tad__GetAnalyticsEngineInput.tad__GetAnalyticsEngineInput, &tad__GetAnalyticsEngineInputResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tad__GetAnalyticsEngineInputs(soap, soap_tmp___tad__GetAnalyticsEngineInputs.tad__GetAnalyticsEngineInputs, &tad__GetAnalyticsEngineInputsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tad__GetAnalyticsDeviceStreamUri(soap, soap_tmp___tad__GetAnalyticsDeviceStreamUri.tad__GetAnalyticsDeviceStreamUri, &tad__GetAnalyticsDeviceStreamUriResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tad__GetVideoAnalyticsConfiguration(soap, soap_tmp___tad__GetVideoAnalyticsConfiguration.tad__GetVideoAnalyticsConfiguration, &tad__GetVideoAnalyticsConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tad__CreateAnalyticsEngineInputs(soap, soap_tmp___tad__CreateAnalyticsEngineInputs.tad__CreateAnalyticsEngineInputs, &tad__CreateAnalyticsEngineInputsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tad__DeleteAnalyticsEngineInputs(soap, soap_tmp___tad__DeleteAnalyticsEngineInputs.tad__DeleteAnalyticsEngineInputs, &tad__DeleteAnalyticsEngineInputsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tad__GetAnalyticsState(soap, soap_tmp___tad__GetAnalyticsState.tad__GetAnalyticsState, &tad__GetAnalyticsStateResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tan__GetSupportedRules(soap, soap_tmp___tan__GetSupportedRules.tan__GetSupportedRules, &tan__GetSupportedRulesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tan__CreateRules(soap, soap_tmp___tan__CreateRules.tan__CreateRules, &tan__CreateRulesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tan__DeleteRules(soap, soap_tmp___tan__DeleteRules.tan__DeleteRules, &tan__DeleteRulesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tan__GetRules(soap, soap_tmp___tan__GetRules.tan__GetRules, &tan__GetRulesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tan__GetRuleOptions(soap, soap_tmp___tan__GetRuleOptions.tan__GetRuleOptions, &tan__GetRuleOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tan__ModifyRules(soap, soap_tmp___tan__ModifyRules.tan__ModifyRules, &tan__ModifyRulesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tan__GetServiceCapabilities(soap, soap_tmp___tan__GetServiceCapabilities.tan__GetServiceCapabilities, &tan__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tan__GetSupportedAnalyticsModules(soap, soap_tmp___tan__GetSupportedAnalyticsModules.tan__GetSupportedAnalyticsModules, &tan__GetSupportedAnalyticsModulesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tan__CreateAnalyticsModules(soap, soap_tmp___tan__CreateAnalyticsModules.tan__CreateAnalyticsModules, &tan__CreateAnalyticsModulesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tan__DeleteAnalyticsModules(soap, soap_tmp___tan__DeleteAnalyticsModules.tan__DeleteAnalyticsModules, &tan__DeleteAnalyticsModulesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tan__GetAnalyticsModules(soap, soap_tmp___tan__GetAnalyticsModules.tan__GetAnalyticsModules, &tan__GetAnalyticsModulesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tan__ModifyAnalyticsModules(soap, soap_tmp___tan__ModifyAnalyticsModules.tan__ModifyAnalyticsModules, &tan__ModifyAnalyticsModulesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tdn__Hello(soap, soap_tmp___tdn__Hello.tdn__Hello, &tdn__HelloResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tdn__Bye(soap, soap_tmp___tdn__Bye.tdn__Bye, &tdn__ByeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tdn__Probe(soap, soap_tmp___tdn__Probe.tdn__Probe, &tdn__ProbeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetServices(soap, soap_tmp___tds__GetServices.tds__GetServices, &tds__GetServicesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetServiceCapabilities(soap, soap_tmp___tds__GetServiceCapabilities.tds__GetServiceCapabilities, &tds__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDeviceInformation(soap, soap_tmp___tds__GetDeviceInformation.tds__GetDeviceInformation, &tds__GetDeviceInformationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetSystemDateAndTime(soap, soap_tmp___tds__SetSystemDateAndTime.tds__SetSystemDateAndTime, &tds__SetSystemDateAndTimeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetSystemDateAndTime(soap, soap_tmp___tds__GetSystemDateAndTime.tds__GetSystemDateAndTime, &tds__GetSystemDateAndTimeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetSystemFactoryDefault(soap, soap_tmp___tds__SetSystemFactoryDefault.tds__SetSystemFactoryDefault, &tds__SetSystemFactoryDefaultResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__UpgradeSystemFirmware(soap, soap_tmp___tds__UpgradeSystemFirmware.tds__UpgradeSystemFirmware, &tds__UpgradeSystemFirmwareResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SystemReboot(soap, soap_tmp___tds__SystemReboot.tds__SystemReboot, &tds__SystemRebootResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__RestoreSystem(soap, soap_tmp___tds__RestoreSystem.tds__RestoreSystem, &tds__RestoreSystemResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetSystemBackup(soap, soap_tmp___tds__GetSystemBackup.tds__GetSystemBackup, &tds__GetSystemBackupResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetSystemLog(soap, soap_tmp___tds__GetSystemLog.tds__GetSystemLog, &tds__GetSystemLogResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetSystemSupportInformation(soap, soap_tmp___tds__GetSystemSupportInformation.tds__GetSystemSupportInformation, &tds__GetSystemSupportInformationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetScopes(soap, soap_tmp___tds__GetScopes.tds__GetScopes, &tds__GetScopesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetScopes(soap, soap_tmp___tds__SetScopes.tds__SetScopes, &tds__SetScopesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__AddScopes(soap, soap_tmp___tds__AddScopes.tds__AddScopes, &tds__AddScopesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__RemoveScopes(soap, soap_tmp___tds__RemoveScopes.tds__RemoveScopes, &tds__RemoveScopesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDiscoveryMode(soap, soap_tmp___tds__GetDiscoveryMode.tds__GetDiscoveryMode, &tds__GetDiscoveryModeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetDiscoveryMode(soap, soap_tmp___tds__SetDiscoveryMode.tds__SetDiscoveryMode, &tds__SetDiscoveryModeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetRemoteDiscoveryMode(soap, soap_tmp___tds__GetRemoteDiscoveryMode.tds__GetRemoteDiscoveryMode, &tds__GetRemoteDiscoveryModeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetRemoteDiscoveryMode(soap, soap_tmp___tds__SetRemoteDiscoveryMode.tds__SetRemoteDiscoveryMode, &tds__SetRemoteDiscoveryModeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDPAddresses(soap, soap_tmp___tds__GetDPAddresses.tds__GetDPAddresses, &tds__GetDPAddressesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetEndpointReference(soap, soap_tmp___tds__GetEndpointReference.tds__GetEndpointReference, &tds__GetEndpointReferenceResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetRemoteUser(soap, soap_tmp___tds__GetRemoteUser.tds__GetRemoteUser, &tds__GetRemoteUserResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetRemoteUser(soap, soap_tmp___tds__SetRemoteUser.tds__SetRemoteUser, &tds__SetRemoteUserResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetUsers(soap, soap_tmp___tds__GetUsers.tds__GetUsers, &tds__GetUsersResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__CreateUsers(soap, soap_tmp___tds__CreateUsers.tds__CreateUsers, &tds__CreateUsersResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__DeleteUsers(soap, soap_tmp___tds__DeleteUsers.tds__DeleteUsers, &tds__DeleteUsersResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetUser(soap, soap_tmp___tds__SetUser.tds__SetUser, &tds__SetUserResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetWsdlUrl(soap, soap_tmp___tds__GetWsdlUrl.tds__GetWsdlUrl, &tds__GetWsdlUrlResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetCapabilities(soap, soap_tmp___tds__GetCapabilities.tds__GetCapabilities, &tds__GetCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetDPAddresses(soap, soap_tmp___tds__SetDPAddresses.tds__SetDPAddresses, &tds__SetDPAddressesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetHostname(soap, soap_tmp___tds__GetHostname.tds__GetHostname, &tds__GetHostnameResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetHostname(soap, soap_tmp___tds__SetHostname.tds__SetHostname, &tds__SetHostnameResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetHostnameFromDHCP(soap, soap_tmp___tds__SetHostnameFromDHCP.tds__SetHostnameFromDHCP, &tds__SetHostnameFromDHCPResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDNS(soap, soap_tmp___tds__GetDNS.tds__GetDNS, &tds__GetDNSResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetDNS(soap, soap_tmp___tds__SetDNS.tds__SetDNS, &tds__SetDNSResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetNTP(soap, soap_tmp___tds__GetNTP.tds__GetNTP, &tds__GetNTPResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetNTP(soap, soap_tmp___tds__SetNTP.tds__SetNTP, &tds__SetNTPResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDynamicDNS(soap, soap_tmp___tds__GetDynamicDNS.tds__GetDynamicDNS, &tds__GetDynamicDNSResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetDynamicDNS(soap, soap_tmp___tds__SetDynamicDNS.tds__SetDynamicDNS, &tds__SetDynamicDNSResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetNetworkInterfaces(soap, soap_tmp___tds__GetNetworkInterfaces.tds__GetNetworkInterfaces, &tds__GetNetworkInterfacesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetNetworkInterfaces(soap, soap_tmp___tds__SetNetworkInterfaces.tds__SetNetworkInterfaces, &tds__SetNetworkInterfacesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetNetworkProtocols(soap, soap_tmp___tds__GetNetworkProtocols.tds__GetNetworkProtocols, &tds__GetNetworkProtocolsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetNetworkProtocols(soap, soap_tmp___tds__SetNetworkProtocols.tds__SetNetworkProtocols, &tds__SetNetworkProtocolsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetNetworkDefaultGateway(soap, soap_tmp___tds__GetNetworkDefaultGateway.tds__GetNetworkDefaultGateway, &tds__GetNetworkDefaultGatewayResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetNetworkDefaultGateway(soap, soap_tmp___tds__SetNetworkDefaultGateway.tds__SetNetworkDefaultGateway, &tds__SetNetworkDefaultGatewayResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetZeroConfiguration(soap, soap_tmp___tds__GetZeroConfiguration.tds__GetZeroConfiguration, &tds__GetZeroConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetZeroConfiguration(soap, soap_tmp___tds__SetZeroConfiguration.tds__SetZeroConfiguration, &tds__SetZeroConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetIPAddressFilter(soap, soap_tmp___tds__GetIPAddressFilter.tds__GetIPAddressFilter, &tds__GetIPAddressFilterResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetIPAddressFilter(soap, soap_tmp___tds__SetIPAddressFilter.tds__SetIPAddressFilter, &tds__SetIPAddressFilterResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__AddIPAddressFilter(soap, soap_tmp___tds__AddIPAddressFilter.tds__AddIPAddressFilter, &tds__AddIPAddressFilterResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__RemoveIPAddressFilter(soap, soap_tmp___tds__RemoveIPAddressFilter.tds__RemoveIPAddressFilter, &tds__RemoveIPAddressFilterResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetAccessPolicy(soap, soap_tmp___tds__GetAccessPolicy.tds__GetAccessPolicy, &tds__GetAccessPolicyResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetAccessPolicy(soap, soap_tmp___tds__SetAccessPolicy.tds__SetAccessPolicy, &tds__SetAccessPolicyResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__CreateCertificate(soap, soap_tmp___tds__CreateCertificate.tds__CreateCertificate, &tds__CreateCertificateResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetCertificates(soap, soap_tmp___tds__GetCertificates.tds__GetCertificates, &tds__GetCertificatesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetCertificatesStatus(soap, soap_tmp___tds__GetCertificatesStatus.tds__GetCertificatesStatus, &tds__GetCertificatesStatusResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetCertificatesStatus(soap, soap_tmp___tds__SetCertificatesStatus.tds__SetCertificatesStatus, &tds__SetCertificatesStatusResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__DeleteCertificates(soap, soap_tmp___tds__DeleteCertificates.tds__DeleteCertificates, &tds__DeleteCertificatesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetPkcs10Request(soap, soap_tmp___tds__GetPkcs10Request.tds__GetPkcs10Request, &tds__GetPkcs10RequestResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__LoadCertificates(soap, soap_tmp___tds__LoadCertificates.tds__LoadCertificates, &tds__LoadCertificatesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetClientCertificateMode(soap, soap_tmp___tds__GetClientCertificateMode.tds__GetClientCertificateMode, &tds__GetClientCertificateModeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetClientCertificateMode(soap, soap_tmp___tds__SetClientCertificateMode.tds__SetClientCertificateMode, &tds__SetClientCertificateModeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetRelayOutputs(soap, soap_tmp___tds__GetRelayOutputs.tds__GetRelayOutputs, &tds__GetRelayOutputsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetRelayOutputSettings(soap, soap_tmp___tds__SetRelayOutputSettings.tds__SetRelayOutputSettings, &tds__SetRelayOutputSettingsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetRelayOutputState(soap, soap_tmp___tds__SetRelayOutputState.tds__SetRelayOutputState, &tds__SetRelayOutputStateResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SendAuxiliaryCommand(soap, soap_tmp___tds__SendAuxiliaryCommand.tds__SendAuxiliaryCommand, &tds__SendAuxiliaryCommandResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetCACertificates(soap, soap_tmp___tds__GetCACertificates.tds__GetCACertificates, &tds__GetCACertificatesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__LoadCertificateWithPrivateKey(soap, soap_tmp___tds__LoadCertificateWithPrivateKey.tds__LoadCertificateWithPrivateKey, &tds__LoadCertificateWithPrivateKeyResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetCertificateInformation(soap, soap_tmp___tds__GetCertificateInformation.tds__GetCertificateInformation, &tds__GetCertificateInformationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__LoadCACertificates(soap, soap_tmp___tds__LoadCACertificates.tds__LoadCACertificates, &tds__LoadCACertificatesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__CreateDot1XConfiguration(soap, soap_tmp___tds__CreateDot1XConfiguration.tds__CreateDot1XConfiguration, &tds__CreateDot1XConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetDot1XConfiguration(soap, soap_tmp___tds__SetDot1XConfiguration.tds__SetDot1XConfiguration, &tds__SetDot1XConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDot1XConfiguration(soap, soap_tmp___tds__GetDot1XConfiguration.tds__GetDot1XConfiguration, &tds__GetDot1XConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDot1XConfigurations(soap, soap_tmp___tds__GetDot1XConfigurations.tds__GetDot1XConfigurations, &tds__GetDot1XConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__DeleteDot1XConfiguration(soap, soap_tmp___tds__DeleteDot1XConfiguration.tds__DeleteDot1XConfiguration, &tds__DeleteDot1XConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDot11Capabilities(soap, soap_tmp___tds__GetDot11Capabilities.tds__GetDot11Capabilities, &tds__GetDot11CapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDot11Status(soap, soap_tmp___tds__GetDot11Status.tds__GetDot11Status, &tds__GetDot11StatusResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__ScanAvailableDot11Networks(soap, soap_tmp___tds__ScanAvailableDot11Networks.tds__ScanAvailableDot11Networks, &tds__ScanAvailableDot11NetworksResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetSystemUris(soap, soap_tmp___tds__GetSystemUris.tds__GetSystemUris, &tds__GetSystemUrisResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__StartFirmwareUpgrade(soap, soap_tmp___tds__StartFirmwareUpgrade.tds__StartFirmwareUpgrade, &tds__StartFirmwareUpgradeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__StartSystemRestore(soap, soap_tmp___tds__StartSystemRestore.tds__StartSystemRestore, &tds__StartSystemRestoreResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetStorageConfigurations(soap, soap_tmp___tds__GetStorageConfigurations.tds__GetStorageConfigurations, &tds__GetStorageConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__CreateStorageConfiguration(soap, soap_tmp___tds__CreateStorageConfiguration.tds__CreateStorageConfiguration, &tds__CreateStorageConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetStorageConfiguration(soap, soap_tmp___tds__GetStorageConfiguration.tds__GetStorageConfiguration, &tds__GetStorageConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetStorageConfiguration(soap, soap_tmp___tds__SetStorageConfiguration.tds__SetStorageConfiguration, &tds__SetStorageConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__DeleteStorageConfiguration(soap, soap_tmp___tds__DeleteStorageConfiguration.tds__DeleteStorageConfiguration, &tds__DeleteStorageConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetGeoLocation(soap, soap_tmp___tds__GetGeoLocation.tds__GetGeoLocation, &tds__GetGeoLocationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetGeoLocation(soap, soap_tmp___tds__SetGeoLocation.tds__SetGeoLocation, &tds__SetGeoLocationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__DeleteGeoLocation(soap, soap_tmp___tds__DeleteGeoLocation.tds__DeleteGeoLocation, &tds__DeleteGeoLocationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetServices_(soap, soap_tmp___tds__GetServices_.tds__GetServices, &tds__GetServicesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetServiceCapabilities_(soap, soap_tmp___tds__GetServiceCapabilities_.tds__GetServiceCapabilities, &tds__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDeviceInformation_(soap, soap_tmp___tds__GetDeviceInformation_.tds__GetDeviceInformation, &tds__GetDeviceInformationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetSystemDateAndTime_(soap, soap_tmp___tds__SetSystemDateAndTime_.tds__SetSystemDateAndTime, &tds__SetSystemDateAndTimeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetSystemDateAndTime_(soap, soap_tmp___tds__GetSystemDateAndTime_.tds__GetSystemDateAndTime, &tds__GetSystemDateAndTimeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetSystemFactoryDefault_(soap, soap_tmp___tds__SetSystemFactoryDefault_.tds__SetSystemFactoryDefault, &tds__SetSystemFactoryDefaultResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__UpgradeSystemFirmware_(soap, soap_tmp___tds__UpgradeSystemFirmware_.tds__UpgradeSystemFirmware, &tds__UpgradeSystemFirmwareResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SystemReboot_(soap, soap_tmp___tds__SystemReboot_.tds__SystemReboot, &tds__SystemRebootResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__RestoreSystem_(soap, soap_tmp___tds__RestoreSystem_.tds__RestoreSystem, &tds__RestoreSystemResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetSystemBackup_(soap, soap_tmp___tds__GetSystemBackup_.tds__GetSystemBackup, &tds__GetSystemBackupResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetSystemLog_(soap, soap_tmp___tds__GetSystemLog_.tds__GetSystemLog, &tds__GetSystemLogResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetSystemSupportInformation_(soap, soap_tmp___tds__GetSystemSupportInformation_.tds__GetSystemSupportInformation, &tds__GetSystemSupportInformationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetScopes_(soap, soap_tmp___tds__GetScopes_.tds__GetScopes, &tds__GetScopesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetScopes_(soap, soap_tmp___tds__SetScopes_.tds__SetScopes, &tds__SetScopesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__AddScopes_(soap, soap_tmp___tds__AddScopes_.tds__AddScopes, &tds__AddScopesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__RemoveScopes_(soap, soap_tmp___tds__RemoveScopes_.tds__RemoveScopes, &tds__RemoveScopesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDiscoveryMode_(soap, soap_tmp___tds__GetDiscoveryMode_.tds__GetDiscoveryMode, &tds__GetDiscoveryModeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetDiscoveryMode_(soap, soap_tmp___tds__SetDiscoveryMode_.tds__SetDiscoveryMode, &tds__SetDiscoveryModeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetRemoteDiscoveryMode_(soap, soap_tmp___tds__GetRemoteDiscoveryMode_.tds__GetRemoteDiscoveryMode, &tds__GetRemoteDiscoveryModeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetRemoteDiscoveryMode_(soap, soap_tmp___tds__SetRemoteDiscoveryMode_.tds__SetRemoteDiscoveryMode, &tds__SetRemoteDiscoveryModeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDPAddresses_(soap, soap_tmp___tds__GetDPAddresses_.tds__GetDPAddresses, &tds__GetDPAddressesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetEndpointReference_(soap, soap_tmp___tds__GetEndpointReference_.tds__GetEndpointReference, &tds__GetEndpointReferenceResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetRemoteUser_(soap, soap_tmp___tds__GetRemoteUser_.tds__GetRemoteUser, &tds__GetRemoteUserResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetRemoteUser_(soap, soap_tmp___tds__SetRemoteUser_.tds__SetRemoteUser, &tds__SetRemoteUserResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetUsers_(soap, soap_tmp___tds__GetUsers_.tds__GetUsers, &tds__GetUsersResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__CreateUsers_(soap, soap_tmp___tds__CreateUsers_.tds__CreateUsers, &tds__CreateUsersResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__DeleteUsers_(soap, soap_tmp___tds__DeleteUsers_.tds__DeleteUsers, &tds__DeleteUsersResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetUser_(soap, soap_tmp___tds__SetUser_.tds__SetUser, &tds__SetUserResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetWsdlUrl_(soap, soap_tmp___tds__GetWsdlUrl_.tds__GetWsdlUrl, &tds__GetWsdlUrlResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetCapabilities_(soap, soap_tmp___tds__GetCapabilities_.tds__GetCapabilities, &tds__GetCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetDPAddresses_(soap, soap_tmp___tds__SetDPAddresses_.tds__SetDPAddresses, &tds__SetDPAddressesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetHostname_(soap, soap_tmp___tds__GetHostname_.tds__GetHostname, &tds__GetHostnameResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetHostname_(soap, soap_tmp___tds__SetHostname_.tds__SetHostname, &tds__SetHostnameResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetHostnameFromDHCP_(soap, soap_tmp___tds__SetHostnameFromDHCP_.tds__SetHostnameFromDHCP, &tds__SetHostnameFromDHCPResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDNS_(soap, soap_tmp___tds__GetDNS_.tds__GetDNS, &tds__GetDNSResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetDNS_(soap, soap_tmp___tds__SetDNS_.tds__SetDNS, &tds__SetDNSResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetNTP_(soap, soap_tmp___tds__GetNTP_.tds__GetNTP, &tds__GetNTPResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetNTP_(soap, soap_tmp___tds__SetNTP_.tds__SetNTP, &tds__SetNTPResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDynamicDNS_(soap, soap_tmp___tds__GetDynamicDNS_.tds__GetDynamicDNS, &tds__GetDynamicDNSResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetDynamicDNS_(soap, soap_tmp___tds__SetDynamicDNS_.tds__SetDynamicDNS, &tds__SetDynamicDNSResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetNetworkInterfaces_(soap, soap_tmp___tds__GetNetworkInterfaces_.tds__GetNetworkInterfaces, &tds__GetNetworkInterfacesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetNetworkInterfaces_(soap, soap_tmp___tds__SetNetworkInterfaces_.tds__SetNetworkInterfaces, &tds__SetNetworkInterfacesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetNetworkProtocols_(soap, soap_tmp___tds__GetNetworkProtocols_.tds__GetNetworkProtocols, &tds__GetNetworkProtocolsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetNetworkProtocols_(soap, soap_tmp___tds__SetNetworkProtocols_.tds__SetNetworkProtocols, &tds__SetNetworkProtocolsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetNetworkDefaultGateway_(soap, soap_tmp___tds__GetNetworkDefaultGateway_.tds__GetNetworkDefaultGateway, &tds__GetNetworkDefaultGatewayResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetNetworkDefaultGateway_(soap, soap_tmp___tds__SetNetworkDefaultGateway_.tds__SetNetworkDefaultGateway, &tds__SetNetworkDefaultGatewayResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetZeroConfiguration_(soap, soap_tmp___tds__GetZeroConfiguration_.tds__GetZeroConfiguration, &tds__GetZeroConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetZeroConfiguration_(soap, soap_tmp___tds__SetZeroConfiguration_.tds__SetZeroConfiguration, &tds__SetZeroConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetIPAddressFilter_(soap, soap_tmp___tds__GetIPAddressFilter_.tds__GetIPAddressFilter, &tds__GetIPAddressFilterResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetIPAddressFilter_(soap, soap_tmp___tds__SetIPAddressFilter_.tds__SetIPAddressFilter, &tds__SetIPAddressFilterResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__AddIPAddressFilter_(soap, soap_tmp___tds__AddIPAddressFilter_.tds__AddIPAddressFilter, &tds__AddIPAddressFilterResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__RemoveIPAddressFilter_(soap, soap_tmp___tds__RemoveIPAddressFilter_.tds__RemoveIPAddressFilter, &tds__RemoveIPAddressFilterResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetAccessPolicy_(soap, soap_tmp___tds__GetAccessPolicy_.tds__GetAccessPolicy, &tds__GetAccessPolicyResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetAccessPolicy_(soap, soap_tmp___tds__SetAccessPolicy_.tds__SetAccessPolicy, &tds__SetAccessPolicyResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__CreateCertificate_(soap, soap_tmp___tds__CreateCertificate_.tds__CreateCertificate, &tds__CreateCertificateResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetCertificates_(soap, soap_tmp___tds__GetCertificates_.tds__GetCertificates, &tds__GetCertificatesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetCertificatesStatus_(soap, soap_tmp___tds__GetCertificatesStatus_.tds__GetCertificatesStatus, &tds__GetCertificatesStatusResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetCertificatesStatus_(soap, soap_tmp___tds__SetCertificatesStatus_.tds__SetCertificatesStatus, &tds__SetCertificatesStatusResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__DeleteCertificates_(soap, soap_tmp___tds__DeleteCertificates_.tds__DeleteCertificates, &tds__DeleteCertificatesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetPkcs10Request_(soap, soap_tmp___tds__GetPkcs10Request_.tds__GetPkcs10Request, &tds__GetPkcs10RequestResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__LoadCertificates_(soap, soap_tmp___tds__LoadCertificates_.tds__LoadCertificates, &tds__LoadCertificatesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetClientCertificateMode_(soap, soap_tmp___tds__GetClientCertificateMode_.tds__GetClientCertificateMode, &tds__GetClientCertificateModeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetClientCertificateMode_(soap, soap_tmp___tds__SetClientCertificateMode_.tds__SetClientCertificateMode, &tds__SetClientCertificateModeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetRelayOutputs_(soap, soap_tmp___tds__GetRelayOutputs_.tds__GetRelayOutputs, &tds__GetRelayOutputsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetRelayOutputSettings_(soap, soap_tmp___tds__SetRelayOutputSettings_.tds__SetRelayOutputSettings, &tds__SetRelayOutputSettingsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetRelayOutputState_(soap, soap_tmp___tds__SetRelayOutputState_.tds__SetRelayOutputState, &tds__SetRelayOutputStateResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SendAuxiliaryCommand_(soap, soap_tmp___tds__SendAuxiliaryCommand_.tds__SendAuxiliaryCommand, &tds__SendAuxiliaryCommandResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetCACertificates_(soap, soap_tmp___tds__GetCACertificates_.tds__GetCACertificates, &tds__GetCACertificatesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__LoadCertificateWithPrivateKey_(soap, soap_tmp___tds__LoadCertificateWithPrivateKey_.tds__LoadCertificateWithPrivateKey, &tds__LoadCertificateWithPrivateKeyResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetCertificateInformation_(soap, soap_tmp___tds__GetCertificateInformation_.tds__GetCertificateInformation, &tds__GetCertificateInformationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__LoadCACertificates_(soap, soap_tmp___tds__LoadCACertificates_.tds__LoadCACertificates, &tds__LoadCACertificatesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__CreateDot1XConfiguration_(soap, soap_tmp___tds__CreateDot1XConfiguration_.tds__CreateDot1XConfiguration, &tds__CreateDot1XConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetDot1XConfiguration_(soap, soap_tmp___tds__SetDot1XConfiguration_.tds__SetDot1XConfiguration, &tds__SetDot1XConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDot1XConfiguration_(soap, soap_tmp___tds__GetDot1XConfiguration_.tds__GetDot1XConfiguration, &tds__GetDot1XConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDot1XConfigurations_(soap, soap_tmp___tds__GetDot1XConfigurations_.tds__GetDot1XConfigurations, &tds__GetDot1XConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__DeleteDot1XConfiguration_(soap, soap_tmp___tds__DeleteDot1XConfiguration_.tds__DeleteDot1XConfiguration, &tds__DeleteDot1XConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDot11Capabilities_(soap, soap_tmp___tds__GetDot11Capabilities_.tds__GetDot11Capabilities, &tds__GetDot11CapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetDot11Status_(soap, soap_tmp___tds__GetDot11Status_.tds__GetDot11Status, &tds__GetDot11StatusResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__ScanAvailableDot11Networks_(soap, soap_tmp___tds__ScanAvailableDot11Networks_.tds__ScanAvailableDot11Networks, &tds__ScanAvailableDot11NetworksResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetSystemUris_(soap, soap_tmp___tds__GetSystemUris_.tds__GetSystemUris, &tds__GetSystemUrisResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__StartFirmwareUpgrade_(soap, soap_tmp___tds__StartFirmwareUpgrade_.tds__StartFirmwareUpgrade, &tds__StartFirmwareUpgradeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__StartSystemRestore_(soap, soap_tmp___tds__StartSystemRestore_.tds__StartSystemRestore, &tds__StartSystemRestoreResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetStorageConfigurations_(soap, soap_tmp___tds__GetStorageConfigurations_.tds__GetStorageConfigurations, &tds__GetStorageConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__CreateStorageConfiguration_(soap, soap_tmp___tds__CreateStorageConfiguration_.tds__CreateStorageConfiguration, &tds__CreateStorageConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetStorageConfiguration_(soap, soap_tmp___tds__GetStorageConfiguration_.tds__GetStorageConfiguration, &tds__GetStorageConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetStorageConfiguration_(soap, soap_tmp___tds__SetStorageConfiguration_.tds__SetStorageConfiguration, &tds__SetStorageConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__DeleteStorageConfiguration_(soap, soap_tmp___tds__DeleteStorageConfiguration_.tds__DeleteStorageConfiguration, &tds__DeleteStorageConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__GetGeoLocation_(soap, soap_tmp___tds__GetGeoLocation_.tds__GetGeoLocation, &tds__GetGeoLocationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__SetGeoLocation_(soap, soap_tmp___tds__SetGeoLocation_.tds__SetGeoLocation, &tds__SetGeoLocationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tds__DeleteGeoLocation_(soap, soap_tmp___tds__DeleteGeoLocation_.tds__DeleteGeoLocation, &tds__DeleteGeoLocationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__PullMessages(soap, soap_tmp___tev__PullMessages.tev__PullMessages, &tev__PullMessagesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__Seek(soap, soap_tmp___tev__Seek.tev__Seek, &tev__SeekResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__SetSynchronizationPoint(soap, soap_tmp___tev__SetSynchronizationPoint.tev__SetSynchronizationPoint, &tev__SetSynchronizationPointResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__GetServiceCapabilities(soap, soap_tmp___tev__GetServiceCapabilities.tev__GetServiceCapabilities, &tev__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__CreatePullPointSubscription(soap, soap_tmp___tev__CreatePullPointSubscription.tev__CreatePullPointSubscription, &tev__CreatePullPointSubscriptionResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__GetEventProperties(soap, soap_tmp___tev__GetEventProperties.tev__GetEventProperties, &tev__GetEventPropertiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__Renew(soap, soap_tmp___tev__Renew.wsnt__Renew, &wsnt__RenewResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__Unsubscribe(soap, soap_tmp___tev__Unsubscribe.wsnt__Unsubscribe, &wsnt__UnsubscribeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__Subscribe(soap, soap_tmp___tev__Subscribe.wsnt__Subscribe, &wsnt__SubscribeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__GetCurrentMessage(soap, soap_tmp___tev__GetCurrentMessage.wsnt__GetCurrentMessage, &wsnt__GetCurrentMessageResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__Notify(soap, soap_tmp___tev__Notify.wsnt__Notify);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__GetMessages(soap, soap_tmp___tev__GetMessages.wsnt__GetMessages, &wsnt__GetMessagesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__DestroyPullPoint(soap, soap_tmp___tev__DestroyPullPoint.wsnt__DestroyPullPoint, &wsnt__DestroyPullPointResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__Notify_(soap, soap_tmp___tev__Notify_.wsnt__Notify);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__CreatePullPoint(soap, soap_tmp___tev__CreatePullPoint.wsnt__CreatePullPoint, &wsnt__CreatePullPointResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__Renew_(soap, soap_tmp___tev__Renew_.wsnt__Renew, &wsnt__RenewResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__Unsubscribe_(soap, soap_tmp___tev__Unsubscribe_.wsnt__Unsubscribe, &wsnt__UnsubscribeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__PauseSubscription(soap, soap_tmp___tev__PauseSubscription.wsnt__PauseSubscription, &wsnt__PauseSubscriptionResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tev__ResumeSubscription(soap, soap_tmp___tev__ResumeSubscription.wsnt__ResumeSubscription, &wsnt__ResumeSubscriptionResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __timg__GetServiceCapabilities(soap, soap_tmp___timg__GetServiceCapabilities.timg__GetServiceCapabilities, &timg__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __timg__GetImagingSettings(soap, soap_tmp___timg__GetImagingSettings.timg__GetImagingSettings, &timg__GetImagingSettingsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __timg__SetImagingSettings(soap, soap_tmp___timg__SetImagingSettings.timg__SetImagingSettings, &timg__SetImagingSettingsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __timg__GetOptions(soap, soap_tmp___timg__GetOptions.timg__GetOptions, &timg__GetOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __timg__Move(soap, soap_tmp___timg__Move.timg__Move, &timg__MoveResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __timg__Stop(soap, soap_tmp___timg__Stop.timg__Stop, &timg__StopResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __timg__GetStatus(soap, soap_tmp___timg__GetStatus.timg__GetStatus, &timg__GetStatusResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __timg__GetMoveOptions(soap, soap_tmp___timg__GetMoveOptions.timg__GetMoveOptions, &timg__GetMoveOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __timg__GetPresets(soap, soap_tmp___timg__GetPresets.timg__GetPresets, &timg__GetPresetsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __timg__GetCurrentPreset(soap, soap_tmp___timg__GetCurrentPreset.timg__GetCurrentPreset, &timg__GetCurrentPresetResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __timg__SetCurrentPreset(soap, soap_tmp___timg__SetCurrentPreset.timg__SetCurrentPreset, &timg__SetCurrentPresetResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tls__GetServiceCapabilities(soap, soap_tmp___tls__GetServiceCapabilities.tls__GetServiceCapabilities, &tls__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tls__GetLayout(soap, soap_tmp___tls__GetLayout.tls__GetLayout, &tls__GetLayoutResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tls__SetLayout(soap, soap_tmp___tls__SetLayout.tls__SetLayout, &tls__SetLayoutResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tls__GetDisplayOptions(soap, soap_tmp___tls__GetDisplayOptions.tls__GetDisplayOptions, &tls__GetDisplayOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tls__GetPaneConfigurations(soap, soap_tmp___tls__GetPaneConfigurations.tls__GetPaneConfigurations, &tls__GetPaneConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tls__GetPaneConfiguration(soap, soap_tmp___tls__GetPaneConfiguration.tls__GetPaneConfiguration, &tls__GetPaneConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tls__SetPaneConfigurations(soap, soap_tmp___tls__SetPaneConfigurations.tls__SetPaneConfigurations, &tls__SetPaneConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tls__SetPaneConfiguration(soap, soap_tmp___tls__SetPaneConfiguration.tls__SetPaneConfiguration, &tls__SetPaneConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tls__CreatePaneConfiguration(soap, soap_tmp___tls__CreatePaneConfiguration.tls__CreatePaneConfiguration, &tls__CreatePaneConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tls__DeletePaneConfiguration(soap, soap_tmp___tls__DeletePaneConfiguration.tls__DeletePaneConfiguration, &tls__DeletePaneConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetServiceCapabilities(soap, soap_tmp___tmd__GetServiceCapabilities.tmd__GetServiceCapabilities, &tmd__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetRelayOutputOptions(soap, soap_tmp___tmd__GetRelayOutputOptions.tmd__GetRelayOutputOptions, &tmd__GetRelayOutputOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetAudioSources(soap, soap_tmp___tmd__GetAudioSources.tmd__GetAudioSources, &tmd__GetAudioSourcesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetAudioOutputs(soap, soap_tmp___tmd__GetAudioOutputs.tmd__GetAudioOutputs, &tmd__GetAudioOutputsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetVideoSources(soap, soap_tmp___tmd__GetVideoSources.tmd__GetVideoSources, &tmd__GetVideoSourcesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetVideoOutputs(soap, soap_tmp___tmd__GetVideoOutputs.tmd__GetVideoOutputs, &tmd__GetVideoOutputsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetVideoSourceConfiguration(soap, soap_tmp___tmd__GetVideoSourceConfiguration.tmd__GetVideoSourceConfiguration, &tmd__GetVideoSourceConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetVideoOutputConfiguration(soap, soap_tmp___tmd__GetVideoOutputConfiguration.tmd__GetVideoOutputConfiguration, &tmd__GetVideoOutputConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetAudioSourceConfiguration(soap, soap_tmp___tmd__GetAudioSourceConfiguration.tmd__GetAudioSourceConfiguration, &tmd__GetAudioSourceConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetAudioOutputConfiguration(soap, soap_tmp___tmd__GetAudioOutputConfiguration.tmd__GetAudioOutputConfiguration, &tmd__GetAudioOutputConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__SetVideoSourceConfiguration(soap, soap_tmp___tmd__SetVideoSourceConfiguration.tmd__SetVideoSourceConfiguration, &tmd__SetVideoSourceConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__SetVideoOutputConfiguration(soap, soap_tmp___tmd__SetVideoOutputConfiguration.tmd__SetVideoOutputConfiguration, &tmd__SetVideoOutputConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__SetAudioSourceConfiguration(soap, soap_tmp___tmd__SetAudioSourceConfiguration.tmd__SetAudioSourceConfiguration, &tmd__SetAudioSourceConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__SetAudioOutputConfiguration(soap, soap_tmp___tmd__SetAudioOutputConfiguration.tmd__SetAudioOutputConfiguration, &tmd__SetAudioOutputConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetVideoSourceConfigurationOptions(soap, soap_tmp___tmd__GetVideoSourceConfigurationOptions.tmd__GetVideoSourceConfigurationOptions, &tmd__GetVideoSourceConfigurationOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetVideoOutputConfigurationOptions(soap, soap_tmp___tmd__GetVideoOutputConfigurationOptions.tmd__GetVideoOutputConfigurationOptions, &tmd__GetVideoOutputConfigurationOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetAudioSourceConfigurationOptions(soap, soap_tmp___tmd__GetAudioSourceConfigurationOptions.tmd__GetAudioSourceConfigurationOptions, &tmd__GetAudioSourceConfigurationOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetAudioOutputConfigurationOptions(soap, soap_tmp___tmd__GetAudioOutputConfigurationOptions.tmd__GetAudioOutputConfigurationOptions, &tmd__GetAudioOutputConfigurationOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetRelayOutputs(soap, soap_tmp___tmd__GetRelayOutputs.tds__GetRelayOutputs, &tds__GetRelayOutputsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__SetRelayOutputSettings(soap, soap_tmp___tmd__SetRelayOutputSettings.tmd__SetRelayOutputSettings, &tmd__SetRelayOutputSettingsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__SetRelayOutputState(soap, soap_tmp___tmd__SetRelayOutputState.tds__SetRelayOutputState, &tds__SetRelayOutputStateResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetDigitalInputs(soap, soap_tmp___tmd__GetDigitalInputs.tmd__GetDigitalInputs, &tmd__GetDigitalInputsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetDigitalInputConfigurationOptions(soap, soap_tmp___tmd__GetDigitalInputConfigurationOptions.tmd__GetDigitalInputConfigurationOptions, &tmd__GetDigitalInputConfigurationOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__SetDigitalInputConfigurations(soap, soap_tmp___tmd__SetDigitalInputConfigurations.tmd__SetDigitalInputConfigurations, &tmd__SetDigitalInputConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetSerialPorts(soap, soap_tmp___tmd__GetSerialPorts.tmd__GetSerialPorts, &tmd__GetSerialPortsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetSerialPortConfiguration(soap, soap_tmp___tmd__GetSerialPortConfiguration.tmd__GetSerialPortConfiguration, &tmd__GetSerialPortConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__SetSerialPortConfiguration(soap, soap_tmp___tmd__SetSerialPortConfiguration.tmd__SetSerialPortConfiguration, &tmd__SetSerialPortConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__GetSerialPortConfigurationOptions(soap, soap_tmp___tmd__GetSerialPortConfigurationOptions.tmd__GetSerialPortConfigurationOptions, &tmd__GetSerialPortConfigurationOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tmd__SendReceiveSerialCommand(soap, soap_tmp___tmd__SendReceiveSerialCommand.tmd__SendReceiveSerialCommand, &tmd__SendReceiveSerialCommandResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__GetServiceCapabilities(soap, soap_tmp___tptz__GetServiceCapabilities.tptz__GetServiceCapabilities, &tptz__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__GetConfigurations(soap, soap_tmp___tptz__GetConfigurations.tptz__GetConfigurations, &tptz__GetConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__GetPresets(soap, soap_tmp___tptz__GetPresets.tptz__GetPresets, &tptz__GetPresetsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__SetPreset(soap, soap_tmp___tptz__SetPreset.tptz__SetPreset, &tptz__SetPresetResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__RemovePreset(soap, soap_tmp___tptz__RemovePreset.tptz__RemovePreset, &tptz__RemovePresetResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__GotoPreset(soap, soap_tmp___tptz__GotoPreset.tptz__GotoPreset, &tptz__GotoPresetResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__GetStatus(soap, soap_tmp___tptz__GetStatus.tptz__GetStatus, &tptz__GetStatusResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__GetConfiguration(soap, soap_tmp___tptz__GetConfiguration.tptz__GetConfiguration, &tptz__GetConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__GetNodes(soap, soap_tmp___tptz__GetNodes.tptz__GetNodes, &tptz__GetNodesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__GetNode(soap, soap_tmp___tptz__GetNode.tptz__GetNode, &tptz__GetNodeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__SetConfiguration(soap, soap_tmp___tptz__SetConfiguration.tptz__SetConfiguration, &tptz__SetConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__GetConfigurationOptions(soap, soap_tmp___tptz__GetConfigurationOptions.tptz__GetConfigurationOptions, &tptz__GetConfigurationOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__GotoHomePosition(soap, soap_tmp___tptz__GotoHomePosition.tptz__GotoHomePosition, &tptz__GotoHomePositionResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__SetHomePosition(soap, soap_tmp___tptz__SetHomePosition.tptz__SetHomePosition, &tptz__SetHomePositionResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__ContinuousMove(soap, soap_tmp___tptz__ContinuousMove.tptz__ContinuousMove, &tptz__ContinuousMoveResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__RelativeMove(soap, soap_tmp___tptz__RelativeMove.tptz__RelativeMove, &tptz__RelativeMoveResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__SendAuxiliaryCommand(soap, soap_tmp___tptz__SendAuxiliaryCommand.tptz__SendAuxiliaryCommand, &tptz__SendAuxiliaryCommandResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__AbsoluteMove(soap, soap_tmp___tptz__AbsoluteMove.tptz__AbsoluteMove, &tptz__AbsoluteMoveResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__Stop(soap, soap_tmp___tptz__Stop.tptz__Stop, &tptz__StopResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__GetPresetTours(soap, soap_tmp___tptz__GetPresetTours.tptz__GetPresetTours, &tptz__GetPresetToursResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__GetPresetTour(soap, soap_tmp___tptz__GetPresetTour.tptz__GetPresetTour, &tptz__GetPresetTourResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__GetPresetTourOptions(soap, soap_tmp___tptz__GetPresetTourOptions.tptz__GetPresetTourOptions, &tptz__GetPresetTourOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__CreatePresetTour(soap, soap_tmp___tptz__CreatePresetTour.tptz__CreatePresetTour, &tptz__CreatePresetTourResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__ModifyPresetTour(soap, soap_tmp___tptz__ModifyPresetTour.tptz__ModifyPresetTour, &tptz__ModifyPresetTourResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__OperatePresetTour(soap, soap_tmp___tptz__OperatePresetTour.tptz__OperatePresetTour, &tptz__OperatePresetTourResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__RemovePresetTour(soap, soap_tmp___tptz__RemovePresetTour.tptz__RemovePresetTour, &tptz__RemovePresetTourResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tptz__GetCompatibleConfigurations(soap, soap_tmp___tptz__GetCompatibleConfigurations.tptz__GetCompatibleConfigurations, &tptz__GetCompatibleConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__GetServiceCapabilities(soap, soap_tmp___trc__GetServiceCapabilities.trc__GetServiceCapabilities, &trc__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__CreateRecording(soap, soap_tmp___trc__CreateRecording.trc__CreateRecording, &trc__CreateRecordingResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__DeleteRecording(soap, soap_tmp___trc__DeleteRecording.trc__DeleteRecording, &trc__DeleteRecordingResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__GetRecordings(soap, soap_tmp___trc__GetRecordings.trc__GetRecordings, &trc__GetRecordingsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__SetRecordingConfiguration(soap, soap_tmp___trc__SetRecordingConfiguration.trc__SetRecordingConfiguration, &trc__SetRecordingConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__GetRecordingConfiguration(soap, soap_tmp___trc__GetRecordingConfiguration.trc__GetRecordingConfiguration, &trc__GetRecordingConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__GetRecordingOptions(soap, soap_tmp___trc__GetRecordingOptions.trc__GetRecordingOptions, &trc__GetRecordingOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__CreateTrack(soap, soap_tmp___trc__CreateTrack.trc__CreateTrack, &trc__CreateTrackResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__DeleteTrack(soap, soap_tmp___trc__DeleteTrack.trc__DeleteTrack, &trc__DeleteTrackResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__GetTrackConfiguration(soap, soap_tmp___trc__GetTrackConfiguration.trc__GetTrackConfiguration, &trc__GetTrackConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__SetTrackConfiguration(soap, soap_tmp___trc__SetTrackConfiguration.trc__SetTrackConfiguration, &trc__SetTrackConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__CreateRecordingJob(soap, soap_tmp___trc__CreateRecordingJob.trc__CreateRecordingJob, &trc__CreateRecordingJobResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__DeleteRecordingJob(soap, soap_tmp___trc__DeleteRecordingJob.trc__DeleteRecordingJob, &trc__DeleteRecordingJobResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__GetRecordingJobs(soap, soap_tmp___trc__GetRecordingJobs.trc__GetRecordingJobs, &trc__GetRecordingJobsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__SetRecordingJobConfiguration(soap, soap_tmp___trc__SetRecordingJobConfiguration.trc__SetRecordingJobConfiguration, &trc__SetRecordingJobConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__GetRecordingJobConfiguration(soap, soap_tmp___trc__GetRecordingJobConfiguration.trc__GetRecordingJobConfiguration, &trc__GetRecordingJobConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__SetRecordingJobMode(soap, soap_tmp___trc__SetRecordingJobMode.trc__SetRecordingJobMode, &trc__SetRecordingJobModeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__GetRecordingJobState(soap, soap_tmp___trc__GetRecordingJobState.trc__GetRecordingJobState, &trc__GetRecordingJobStateResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__ExportRecordedData(soap, soap_tmp___trc__ExportRecordedData.trc__ExportRecordedData, &trc__ExportRecordedDataResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__StopExportRecordedData(soap, soap_tmp___trc__StopExportRecordedData.trc__StopExportRecordedData, &trc__StopExportRecordedDataResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trc__GetExportRecordedDataState(soap, soap_tmp___trc__GetExportRecordedDataState.trc__GetExportRecordedDataState, &trc__GetExportRecordedDataStateResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trp__GetServiceCapabilities(soap, soap_tmp___trp__GetServiceCapabilities.trp__GetServiceCapabilities, &trp__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trp__GetReplayUri(soap, soap_tmp___trp__GetReplayUri.trp__GetReplayUri, &trp__GetReplayUriResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trp__GetReplayConfiguration(soap, soap_tmp___trp__GetReplayConfiguration.trp__GetReplayConfiguration, &trp__GetReplayConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trp__SetReplayConfiguration(soap, soap_tmp___trp__SetReplayConfiguration.trp__SetReplayConfiguration, &trp__SetReplayConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetServiceCapabilities(soap, soap_tmp___trt__GetServiceCapabilities.trt__GetServiceCapabilities, &trt__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetVideoSources(soap, soap_tmp___trt__GetVideoSources.trt__GetVideoSources, &trt__GetVideoSourcesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetAudioSources(soap, soap_tmp___trt__GetAudioSources.trt__GetAudioSources, &trt__GetAudioSourcesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetAudioOutputs(soap, soap_tmp___trt__GetAudioOutputs.trt__GetAudioOutputs, &trt__GetAudioOutputsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__CreateProfile(soap, soap_tmp___trt__CreateProfile.trt__CreateProfile, &trt__CreateProfileResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetProfile(soap, soap_tmp___trt__GetProfile.trt__GetProfile, &trt__GetProfileResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetProfiles(soap, soap_tmp___trt__GetProfiles.trt__GetProfiles, &trt__GetProfilesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__AddVideoEncoderConfiguration(soap, soap_tmp___trt__AddVideoEncoderConfiguration.trt__AddVideoEncoderConfiguration, &trt__AddVideoEncoderConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__AddVideoSourceConfiguration(soap, soap_tmp___trt__AddVideoSourceConfiguration.trt__AddVideoSourceConfiguration, &trt__AddVideoSourceConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__AddAudioEncoderConfiguration(soap, soap_tmp___trt__AddAudioEncoderConfiguration.trt__AddAudioEncoderConfiguration, &trt__AddAudioEncoderConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__AddAudioSourceConfiguration(soap, soap_tmp___trt__AddAudioSourceConfiguration.trt__AddAudioSourceConfiguration, &trt__AddAudioSourceConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__AddPTZConfiguration(soap, soap_tmp___trt__AddPTZConfiguration.trt__AddPTZConfiguration, &trt__AddPTZConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__AddVideoAnalyticsConfiguration(soap, soap_tmp___trt__AddVideoAnalyticsConfiguration.trt__AddVideoAnalyticsConfiguration, &trt__AddVideoAnalyticsConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__AddMetadataConfiguration(soap, soap_tmp___trt__AddMetadataConfiguration.trt__AddMetadataConfiguration, &trt__AddMetadataConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__AddAudioOutputConfiguration(soap, soap_tmp___trt__AddAudioOutputConfiguration.trt__AddAudioOutputConfiguration, &trt__AddAudioOutputConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__AddAudioDecoderConfiguration(soap, soap_tmp___trt__AddAudioDecoderConfiguration.trt__AddAudioDecoderConfiguration, &trt__AddAudioDecoderConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__RemoveVideoEncoderConfiguration(soap, soap_tmp___trt__RemoveVideoEncoderConfiguration.trt__RemoveVideoEncoderConfiguration, &trt__RemoveVideoEncoderConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__RemoveVideoSourceConfiguration(soap, soap_tmp___trt__RemoveVideoSourceConfiguration.trt__RemoveVideoSourceConfiguration, &trt__RemoveVideoSourceConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__RemoveAudioEncoderConfiguration(soap, soap_tmp___trt__RemoveAudioEncoderConfiguration.trt__RemoveAudioEncoderConfiguration, &trt__RemoveAudioEncoderConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__RemoveAudioSourceConfiguration(soap, soap_tmp___trt__RemoveAudioSourceConfiguration.trt__RemoveAudioSourceConfiguration, &trt__RemoveAudioSourceConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__RemovePTZConfiguration(soap, soap_tmp___trt__RemovePTZConfiguration.trt__RemovePTZConfiguration, &trt__RemovePTZConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__RemoveVideoAnalyticsConfiguration(soap, soap_tmp___trt__RemoveVideoAnalyticsConfiguration.trt__RemoveVideoAnalyticsConfiguration, &trt__RemoveVideoAnalyticsConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__RemoveMetadataConfiguration(soap, soap_tmp___trt__RemoveMetadataConfiguration.trt__RemoveMetadataConfiguration, &trt__RemoveMetadataConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__RemoveAudioOutputConfiguration(soap, soap_tmp___trt__RemoveAudioOutputConfiguration.trt__RemoveAudioOutputConfiguration, &trt__RemoveAudioOutputConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__RemoveAudioDecoderConfiguration(soap, soap_tmp___trt__RemoveAudioDecoderConfiguration.trt__RemoveAudioDecoderConfiguration, &trt__RemoveAudioDecoderConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__DeleteProfile(soap, soap_tmp___trt__DeleteProfile.trt__DeleteProfile, &trt__DeleteProfileResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetVideoSourceConfigurations(soap, soap_tmp___trt__GetVideoSourceConfigurations.trt__GetVideoSourceConfigurations, &trt__GetVideoSourceConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetVideoEncoderConfigurations(soap, soap_tmp___trt__GetVideoEncoderConfigurations.trt__GetVideoEncoderConfigurations, &trt__GetVideoEncoderConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetAudioSourceConfigurations(soap, soap_tmp___trt__GetAudioSourceConfigurations.trt__GetAudioSourceConfigurations, &trt__GetAudioSourceConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetAudioEncoderConfigurations(soap, soap_tmp___trt__GetAudioEncoderConfigurations.trt__GetAudioEncoderConfigurations, &trt__GetAudioEncoderConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetVideoAnalyticsConfigurations(soap, soap_tmp___trt__GetVideoAnalyticsConfigurations.trt__GetVideoAnalyticsConfigurations, &trt__GetVideoAnalyticsConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetMetadataConfigurations(soap, soap_tmp___trt__GetMetadataConfigurations.trt__GetMetadataConfigurations, &trt__GetMetadataConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetAudioOutputConfigurations(soap, soap_tmp___trt__GetAudioOutputConfigurations.trt__GetAudioOutputConfigurations, &trt__GetAudioOutputConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetAudioDecoderConfigurations(soap, soap_tmp___trt__GetAudioDecoderConfigurations.trt__GetAudioDecoderConfigurations, &trt__GetAudioDecoderConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetVideoSourceConfiguration(soap, soap_tmp___trt__GetVideoSourceConfiguration.trt__GetVideoSourceConfiguration, &trt__GetVideoSourceConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetVideoEncoderConfiguration(soap, soap_tmp___trt__GetVideoEncoderConfiguration.trt__GetVideoEncoderConfiguration, &trt__GetVideoEncoderConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetAudioSourceConfiguration(soap, soap_tmp___trt__GetAudioSourceConfiguration.trt__GetAudioSourceConfiguration, &trt__GetAudioSourceConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetAudioEncoderConfiguration(soap, soap_tmp___trt__GetAudioEncoderConfiguration.trt__GetAudioEncoderConfiguration, &trt__GetAudioEncoderConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetVideoAnalyticsConfiguration(soap, soap_tmp___trt__GetVideoAnalyticsConfiguration.trt__GetVideoAnalyticsConfiguration, &trt__GetVideoAnalyticsConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetMetadataConfiguration(soap, soap_tmp___trt__GetMetadataConfiguration.trt__GetMetadataConfiguration, &trt__GetMetadataConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetAudioOutputConfiguration(soap, soap_tmp___trt__GetAudioOutputConfiguration.trt__GetAudioOutputConfiguration, &trt__GetAudioOutputConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetAudioDecoderConfiguration(soap, soap_tmp___trt__GetAudioDecoderConfiguration.trt__GetAudioDecoderConfiguration, &trt__GetAudioDecoderConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetCompatibleVideoEncoderConfigurations(soap, soap_tmp___trt__GetCompatibleVideoEncoderConfigurations.trt__GetCompatibleVideoEncoderConfigurations, &trt__GetCompatibleVideoEncoderConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetCompatibleVideoSourceConfigurations(soap, soap_tmp___trt__GetCompatibleVideoSourceConfigurations.trt__GetCompatibleVideoSourceConfigurations, &trt__GetCompatibleVideoSourceConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetCompatibleAudioEncoderConfigurations(soap, soap_tmp___trt__GetCompatibleAudioEncoderConfigurations.trt__GetCompatibleAudioEncoderConfigurations, &trt__GetCompatibleAudioEncoderConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetCompatibleAudioSourceConfigurations(soap, soap_tmp___trt__GetCompatibleAudioSourceConfigurations.trt__GetCompatibleAudioSourceConfigurations, &trt__GetCompatibleAudioSourceConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetCompatibleVideoAnalyticsConfigurations(soap, soap_tmp___trt__GetCompatibleVideoAnalyticsConfigurations.trt__GetCompatibleVideoAnalyticsConfigurations, &trt__GetCompatibleVideoAnalyticsConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetCompatibleMetadataConfigurations(soap, soap_tmp___trt__GetCompatibleMetadataConfigurations.trt__GetCompatibleMetadataConfigurations, &trt__GetCompatibleMetadataConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetCompatibleAudioOutputConfigurations(soap, soap_tmp___trt__GetCompatibleAudioOutputConfigurations.trt__GetCompatibleAudioOutputConfigurations, &trt__GetCompatibleAudioOutputConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetCompatibleAudioDecoderConfigurations(soap, soap_tmp___trt__GetCompatibleAudioDecoderConfigurations.trt__GetCompatibleAudioDecoderConfigurations, &trt__GetCompatibleAudioDecoderConfigurationsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__SetVideoSourceConfiguration(soap, soap_tmp___trt__SetVideoSourceConfiguration.trt__SetVideoSourceConfiguration, &trt__SetVideoSourceConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__SetVideoEncoderConfiguration(soap, soap_tmp___trt__SetVideoEncoderConfiguration.trt__SetVideoEncoderConfiguration, &trt__SetVideoEncoderConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__SetAudioSourceConfiguration(soap, soap_tmp___trt__SetAudioSourceConfiguration.trt__SetAudioSourceConfiguration, &trt__SetAudioSourceConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__SetAudioEncoderConfiguration(soap, soap_tmp___trt__SetAudioEncoderConfiguration.trt__SetAudioEncoderConfiguration, &trt__SetAudioEncoderConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__SetVideoAnalyticsConfiguration(soap, soap_tmp___trt__SetVideoAnalyticsConfiguration.trt__SetVideoAnalyticsConfiguration, &trt__SetVideoAnalyticsConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__SetMetadataConfiguration(soap, soap_tmp___trt__SetMetadataConfiguration.trt__SetMetadataConfiguration, &trt__SetMetadataConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__SetAudioOutputConfiguration(soap, soap_tmp___trt__SetAudioOutputConfiguration.trt__SetAudioOutputConfiguration, &trt__SetAudioOutputConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__SetAudioDecoderConfiguration(soap, soap_tmp___trt__SetAudioDecoderConfiguration.trt__SetAudioDecoderConfiguration, &trt__SetAudioDecoderConfigurationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetVideoSourceConfigurationOptions(soap, soap_tmp___trt__GetVideoSourceConfigurationOptions.trt__GetVideoSourceConfigurationOptions, &trt__GetVideoSourceConfigurationOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetVideoEncoderConfigurationOptions(soap, soap_tmp___trt__GetVideoEncoderConfigurationOptions.trt__GetVideoEncoderConfigurationOptions, &trt__GetVideoEncoderConfigurationOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetAudioSourceConfigurationOptions(soap, soap_tmp___trt__GetAudioSourceConfigurationOptions.trt__GetAudioSourceConfigurationOptions, &trt__GetAudioSourceConfigurationOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetAudioEncoderConfigurationOptions(soap, soap_tmp___trt__GetAudioEncoderConfigurationOptions.trt__GetAudioEncoderConfigurationOptions, &trt__GetAudioEncoderConfigurationOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetMetadataConfigurationOptions(soap, soap_tmp___trt__GetMetadataConfigurationOptions.trt__GetMetadataConfigurationOptions, &trt__GetMetadataConfigurationOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetAudioOutputConfigurationOptions(soap, soap_tmp___trt__GetAudioOutputConfigurationOptions.trt__GetAudioOutputConfigurationOptions, &trt__GetAudioOutputConfigurationOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetAudioDecoderConfigurationOptions(soap, soap_tmp___trt__GetAudioDecoderConfigurationOptions.trt__GetAudioDecoderConfigurationOptions, &trt__GetAudioDecoderConfigurationOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, soap_tmp___trt__GetGuaranteedNumberOfVideoEncoderInstances.trt__GetGuaranteedNumberOfVideoEncoderInstances, &trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetStreamUri(soap, soap_tmp___trt__GetStreamUri.trt__GetStreamUri, &trt__GetStreamUriResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__StartMulticastStreaming(soap, soap_tmp___trt__StartMulticastStreaming.trt__StartMulticastStreaming, &trt__StartMulticastStreamingResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__StopMulticastStreaming(soap, soap_tmp___trt__StopMulticastStreaming.trt__StopMulticastStreaming, &trt__StopMulticastStreamingResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__SetSynchronizationPoint(soap, soap_tmp___trt__SetSynchronizationPoint.trt__SetSynchronizationPoint, &trt__SetSynchronizationPointResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetSnapshotUri(soap, soap_tmp___trt__GetSnapshotUri.trt__GetSnapshotUri, &trt__GetSnapshotUriResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetVideoSourceModes(soap, soap_tmp___trt__GetVideoSourceModes.trt__GetVideoSourceModes, &trt__GetVideoSourceModesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__SetVideoSourceMode(soap, soap_tmp___trt__SetVideoSourceMode.trt__SetVideoSourceMode, &trt__SetVideoSourceModeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetOSDs(soap, soap_tmp___trt__GetOSDs.trt__GetOSDs, &trt__GetOSDsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetOSD(soap, soap_tmp___trt__GetOSD.trt__GetOSD, &trt__GetOSDResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__GetOSDOptions(soap, soap_tmp___trt__GetOSDOptions.trt__GetOSDOptions, &trt__GetOSDOptionsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__SetOSD(soap, soap_tmp___trt__SetOSD.trt__SetOSD, &trt__SetOSDResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__CreateOSD(soap, soap_tmp___trt__CreateOSD.trt__CreateOSD, &trt__CreateOSDResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trt__DeleteOSD(soap, soap_tmp___trt__DeleteOSD.trt__DeleteOSD, &trt__DeleteOSDResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trv__GetServiceCapabilities(soap, soap_tmp___trv__GetServiceCapabilities.trv__GetServiceCapabilities, &trv__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trv__GetReceivers(soap, soap_tmp___trv__GetReceivers.trv__GetReceivers, &trv__GetReceiversResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trv__GetReceiver(soap, soap_tmp___trv__GetReceiver.trv__GetReceiver, &trv__GetReceiverResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trv__CreateReceiver(soap, soap_tmp___trv__CreateReceiver.trv__CreateReceiver, &trv__CreateReceiverResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trv__DeleteReceiver(soap, soap_tmp___trv__DeleteReceiver.trv__DeleteReceiver, &trv__DeleteReceiverResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trv__ConfigureReceiver(soap, soap_tmp___trv__ConfigureReceiver.trv__ConfigureReceiver, &trv__ConfigureReceiverResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trv__SetReceiverMode(soap, soap_tmp___trv__SetReceiverMode.trv__SetReceiverMode, &trv__SetReceiverModeResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __trv__GetReceiverState(soap, soap_tmp___trv__GetReceiverState.trv__GetReceiverState, &trv__GetReceiverStateResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tse__GetServiceCapabilities(soap, soap_tmp___tse__GetServiceCapabilities.tse__GetServiceCapabilities, &tse__GetServiceCapabilitiesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tse__GetRecordingSummary(soap, soap_tmp___tse__GetRecordingSummary.tse__GetRecordingSummary, &tse__GetRecordingSummaryResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tse__GetRecordingInformation(soap, soap_tmp___tse__GetRecordingInformation.tse__GetRecordingInformation, &tse__GetRecordingInformationResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tse__GetMediaAttributes(soap, soap_tmp___tse__GetMediaAttributes.tse__GetMediaAttributes, &tse__GetMediaAttributesResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tse__FindRecordings(soap, soap_tmp___tse__FindRecordings.tse__FindRecordings, &tse__FindRecordingsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tse__GetRecordingSearchResults(soap, soap_tmp___tse__GetRecordingSearchResults.tse__GetRecordingSearchResults, &tse__GetRecordingSearchResultsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tse__FindEvents(soap, soap_tmp___tse__FindEvents.tse__FindEvents, &tse__FindEventsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tse__GetEventSearchResults(soap, soap_tmp___tse__GetEventSearchResults.tse__GetEventSearchResults, &tse__GetEventSearchResultsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tse__FindPTZPosition(soap, soap_tmp___tse__FindPTZPosition.tse__FindPTZPosition, &tse__FindPTZPositionResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tse__GetPTZPositionSearchResults(soap, soap_tmp___tse__GetPTZPositionSearchResults.tse__GetPTZPositionSearchResults, &tse__GetPTZPositionSearchResultsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tse__GetSearchState(soap, soap_tmp___tse__GetSearchState.tse__GetSearchState, &tse__GetSearchStateResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tse__EndSearch(soap, soap_tmp___tse__EndSearch.tse__EndSearch, &tse__EndSearchResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tse__FindMetadata(soap, soap_tmp___tse__FindMetadata.tse__FindMetadata, &tse__FindMetadataResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:		return soap->error;
./soapServer.c:	soap->error = __tse__GetMetadataSearchResults(soap, soap_tmp___tse__GetMetadataSearchResults.tse__GetMetadataSearchResults, &tse__GetMetadataSearchResultsResponse);
./soapServer.c:	if (soap->error)
./soapServer.c:		return soap->error;
./soapServer.c:	soap->encodingStyle = NULL;
./soapServer.c:		return soap->error;
./soapServer.c:	if (soap->mode & SOAP_IO_LENGTH)
./soapServer.c:			 return soap->error;
./soapServer.c:		return soap->error;
./wsaapi.c:      if (soap->error == 202) // HTTP ACCEPTED
./wsaapi.c:      if (soap->error == 202) // HTTP ACCEPTED
./wsaapi.c:SOAP and HTTP errors set the soap->error attribute, as shown in this example:
./wsaapi.c:      if (soap->error == 202) // HTTP ACCEPTED
./wsaapi.c:        return soap->error;
./wsaapi.c:        return soap->error;
./wsaapi.c:    soap->bind_flags = SO_REUSEADDR;
./wsaapi.c:    return soap->error;
./wsaapi.c:  soap->header->SOAP_WSA(MessageID) = soap_strdup(soap, id);
./wsaapi.c:    soap->header->SOAP_WSA(To) = soap_strdup(soap, to);
./wsaapi.c:    soap->header->SOAP_WSA(To) = (char*)soap_wsa_anonymousURI;
./wsaapi.c:  soap->header->SOAP_WSA(Action) = soap_strdup(soap, action);
./wsaapi.c:  soap->header->SOAP_WSA(RelatesTo) = NULL;
./wsaapi.c:  soap->header->SOAP_WSA(From) = NULL;
./wsaapi.c:  soap->header->SOAP_WSA(FaultTo) = NULL;
./wsaapi.c:  if (!soap->header)
./wsaapi.c:  soap->header->SOAP_WSA(From) = (SOAP_WSA_(,From)*)soap_malloc(soap, sizeof(SOAP_WSA_(,From)));
./wsaapi.c:  SOAP_WSA_(soap_default,EndpointReferenceType)(soap, soap->header->SOAP_WSA(From));
./wsaapi.c:  soap->header->SOAP_WSA(From)->Address = soap_strdup(soap, from);
./wsaapi.c:  if (!soap->header)
./wsaapi.c:    soap->header->SOAP_WSA(ReplyTo) = (SOAP_WSA_(,ReplyTo)*)soap_malloc(soap, sizeof(SOAP_WSA_(,ReplyTo)));
./wsaapi.c:    SOAP_WSA_(soap_default,EndpointReferenceType)(soap, soap->header->SOAP_WSA(ReplyTo));
./wsaapi.c:    soap->header->SOAP_WSA(ReplyTo)->Address = soap_strdup(soap, replyTo);
./wsaapi.c:    soap->header->SOAP_WSA(ReplyTo) = NULL;
./wsaapi.c:  if (!soap->header)
./wsaapi.c:    soap->header->SOAP_WSA(FaultTo) = (SOAP_WSA_(,FaultTo)*)soap_malloc(soap, sizeof(SOAP_WSA_(,FaultTo)));
./wsaapi.c:    SOAP_WSA_(soap_default,EndpointReferenceType)(soap, soap->header->SOAP_WSA(FaultTo));
./wsaapi.c:    soap->header->SOAP_WSA(FaultTo)->Address = soap_strdup(soap, faultTo);
./wsaapi.c:    soap->header->SOAP_WSA(FaultTo) = NULL;
./wsaapi.c:  if (!soap->header)
./wsaapi.c:    soap->header->SOAP_WSA(RelatesTo) = (SOAP_WSA_(,RelatesTo)*)soap_malloc(soap, sizeof(SOAP_WSA_(,RelatesTo)));
./wsaapi.c:    SOAP_WSA_(soap_default_,RelatesTo)(soap, soap->header->SOAP_WSA(RelatesTo));
./wsaapi.c:    soap->header->SOAP_WSA(RelatesTo)->__item = soap_strdup(soap, relatesTo);
./wsaapi.c:  if (!soap->header || !soap->header->SOAP_WSA(From))
./wsaapi.c:  return soap->header->SOAP_WSA(From)->Address;
./wsaapi.c:  if (!soap->header || !soap->header->SOAP_WSA(ReplyTo))
./wsaapi.c:  return soap->header->SOAP_WSA(ReplyTo)->Address;
./wsaapi.c:  if (!soap->header || !soap->header->SOAP_WSA(FaultTo))
./wsaapi.c:  return soap->header->SOAP_WSA(FaultTo)->Address;
./wsaapi.c:  if (!soap->header || !soap->header->SOAP_WSA(RelatesTo))
./wsaapi.c:  return soap->header->SOAP_WSA(RelatesTo)->__item;
./wsaapi.c:  if (!soap->header || !soap->header->SOAP_WSA(Action))
./wsaapi.c:    return soap->error = SOAP_PLUGIN_ERROR;
./wsaapi.c:  oldheader = soap->header;
./wsaapi.c:  soap->header = NULL;
./wsaapi.c:    return soap->error;
./wsaapi.c:  newheader = soap->header;
./wsaapi.c:        soap->omode |= SOAP_ENC_PLAIN; /* omit HTTP header ("encode XML body only") */
./wsaapi.c:          soap->header = oldheader;
./wsaapi.c:          soap->header = NULL;
./wsaapi.c:        if (soap_valid_socket(reply_soap->socket))
./wsaapi.c:        soap->header = newheader;
./wsaapi.c:        soap->omode &= ~SOAP_ENC_PLAIN;           /* HTTP header required */
./wsaapi.c:        data->fresponse = soap->fresponse;
./wsaapi.c:        soap->fresponse = soap_wsa_response;    /* response will be a POST */
./wsaapi.c:  soap->header = newheader;
./wsaapi.c:  soap->action = newheader->SOAP_WSA(Action);
./wsaapi.c:  oldheader = soap->header;
./wsaapi.c:	SOAP_WSA_(soap_default,EndpointReferenceType)(soap, soap->header->SOAP_WSA(FaultTo));
./wsaapi.c:  soap->header = NULL;
./wsaapi.c:  newheader = soap->header;
./wsaapi.c:	  return soap->error = SOAP_PLUGIN_ERROR;
./wsaapi.c:	soap->keep_alive = 0;
./wsaapi.c:	  return soap->error = SOAP_STOP; /* nowhere to go */
./wsaapi.c:	  soap->action = (char*)action;
./wsaapi.c:	  soap->action = newheader->SOAP_WSA(Action);
./wsaapi.c:	data->fresponse = soap->fresponse;
./wsaapi.c:	soap->fresponse = soap_wsa_response;      /* response will be a POST */
./wsaapi.c:    soap->header = newheader;
./wsaapi.c:  if (soap->error && soap->fault && soap->fault->SOAP_ENV__Code)
./wsaapi.c:        if (soap->fault->detail)
./wsaapi.c:          detail = soap->fault->detail;
./wsaapi.c:          detail = soap->fault->SOAP_ENV__Detail;
./wsaapi.c:      return soap->error;
./wsaapi.c:  if (soap->error && soap->fault)
./wsaapi.c:    if (soap->fault->detail)
./wsaapi.c:      detail = soap->fault->detail;
./wsaapi.c:      detail = soap->fault->SOAP_ENV__Detail;
./wsaapi.c:      return soap->error;
./wsaapi.c:  if (soap->error && soap->fault && soap->fault->SOAP_ENV__Code)
./wsaapi.c:      return soap->error;
./wsaapi.c:      if (soap->version == 1)
./wsaapi.c:        soap->fault->detail->__type = SOAP_WSA_(SOAP_TYPE_,ProblemHeaderQName);
./wsaapi.c:        soap->fault->detail->fault = (void*)info;
./wsaapi.c:      else if (soap->version == 2)
./wsaapi.c:        soap->fault->SOAP_ENV__Detail->__type = SOAP_WSA_(SOAP_TYPE_,ProblemHeaderQName);
./wsaapi.c:        soap->fault->SOAP_ENV__Detail->fault = (void*)info;
./wsaapi.c:      if (soap->version == 1)
./wsaapi.c:        soap->fault->detail->__type = SOAP_WSA_(SOAP_TYPE_,ProblemHeaderQName);
./wsaapi.c:        soap->fault->detail->fault = (void*)info;
./wsaapi.c:      else if (soap->version == 2)
./wsaapi.c:        soap->fault->SOAP_ENV__Detail->__type = SOAP_WSA_(SOAP_TYPE_,ProblemHeaderQName);
./wsaapi.c:        soap->fault->SOAP_ENV__Detail->fault = (void*)info;
./wsaapi.c:      if (soap->version == 1)
./wsaapi.c:        soap->fault->detail->__type = SOAP_WSA_(SOAP_TYPE_,ProblemIRI);
./wsaapi.c:        soap->fault->detail->fault = (void*)info;
./wsaapi.c:      else if (soap->version == 2)
./wsaapi.c:        soap->fault->SOAP_ENV__Detail->__type = SOAP_WSA_(SOAP_TYPE_,ProblemIRI);
./wsaapi.c:        soap->fault->SOAP_ENV__Detail->fault = (void*)info;
./wsaapi.c:      if (soap->version == 1)
./wsaapi.c:        soap->fault->detail->__type = SOAP_WSA_(SOAP_TYPE_,ProblemAction);
./wsaapi.c:        soap->fault->detail->fault = (void*)soap_malloc(soap, sizeof(SOAP_WSA_(,ProblemAction)));
./wsaapi.c:        SOAP_WSA_(soap_default_,ProblemAction)(soap, (SOAP_WSA_(,ProblemAction)*)soap->fault->detail->fault);
./wsaapi.c:        ((SOAP_WSA_(,ProblemAction)*)soap->fault->detail->fault)->Action = (char*)info;
./wsaapi.c:      else if (soap->version == 2)
./wsaapi.c:        soap->fault->SOAP_ENV__Detail->__type = SOAP_WSA_(SOAP_TYPE_,ProblemAction);
./wsaapi.c:        soap->fault->SOAP_ENV__Detail->fault = (void*)soap_malloc(soap, sizeof(SOAP_WSA_(,ProblemAction)));
./wsaapi.c:        SOAP_WSA_(soap_default_,ProblemAction)(soap, (SOAP_WSA_(,ProblemAction)*)soap->fault->SOAP_ENV__Detail->fault);
./wsaapi.c:        ((SOAP_WSA_(,ProblemAction)*)soap->fault->SOAP_ENV__Detail->fault)->Action = (char*)info;
./wsaapi.c:      if (soap->version == 1)
./wsaapi.c:        soap->fault->detail->__type = SOAP_WSA_(SOAP_TYPE_,ProblemIRI);
./wsaapi.c:        soap->fault->detail->fault = (void*)info;
./wsaapi.c:      else if (soap->version == 2)
./wsaapi.c:        soap->fault->SOAP_ENV__Detail->__type = SOAP_WSA_(SOAP_TYPE_,ProblemIRI);
./wsaapi.c:        soap->fault->SOAP_ENV__Detail->fault = (void*)info;
./wsaapi.c:      return soap_wsa_sender_fault_subcode(soap, code, "The [action] cannot be processed at the receiver.", soap->action);
./wsaapi.c:  data->fheader = soap->fheader;
./wsaapi.c:  data->fseterror = soap->fseterror;
./wsaapi.c:  soap->fheader = soap_wsa_header;
./wsaapi.c:  soap->fseterror = soap_wsa_set_error;
./wsaapi.c:    return soap->error = SOAP_PLUGIN_ERROR;
./wsaapi.c:    return soap->error;
./wsaapi.c:  if (soap->header && soap->header->SOAP_WSA(Action))
./wsaapi.c:    soap->action = soap->header->SOAP_WSA(Action);
./wsaapi.c:    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "WSA action='%s'\n", soap->action));
./wsaapi.c:  if (soap->error == SOAP_NO_METHOD || (soap->error == SOAP_TAG_MISMATCH && soap->level == 2))
./wsaapi.c:    soap->error = soap_wsa_error(soap, SOAP_WSA(ActionNotSupported), soap->action);
./wsaapi.c:    soap->error = soap_wsa_error(soap, "Action not supported");
./wsaapi.c:    soap->error = soap_wsa_error(soap, SOAP_WSA(ActionNotSupported));
./wsaapi.c:  soap->fresponse = data->fresponse;    /* reset (HTTP response) */
./wsaapi.c:  data->fdisconnect = soap->fdisconnect;
./wsaapi.c:  soap->fdisconnect = soap_wsa_disconnect; /* to accept HTTP 202 */
./wsaapi.c:  return soap->fpost(soap, soap_strdup(soap, soap->endpoint), soap->host, soap->port, soap->path, soap->action, count);
./wsaapi.c:  soap->fdisconnect = data->fdisconnect; /* reset */
./wsaapi.c:  if (soap->header)
./wsaapi.c:  return soap->error = SOAP_EOM;
./wsseapi.c:        return soap->error; // no username: return FailedAuthentication (from soap_wsse_get_Username)
./wsseapi.c:        int err = soap->error;
./wsseapi.c:          return soap->error;
./wsseapi.c:        return soap->error;
./wsseapi.c:by returning soap->error from service operations. The fault is displayed with
./wsseapi.c:    soap->cafile = "cacerts.pem";  // use this
./wsseapi.c:    soap->capath = "dir/to/certs"; // and/or point to CA certs
./wsseapi.c:    soap->crlfile = "revoked.pem"; // use CRL (optional)
./wsseapi.c:    soap->cafile = "cacerts.pem";  // file with CA certs of peers
./wsseapi.c:    soap->capath = "dir/to/certs"; // and/or point to CA certs directory
./wsseapi.c:    soap->crlfile = "revoked.pem"; // use CRL (optional)
./wsseapi.c:soap->dom. This enables further analysis of the message content.
./wsseapi.c:    soap->cafile = "cacerts.pem";  // file with CA certs of peers
./wsseapi.c:    soap->capath = "dir/to/certs"; // and/or point to CA certs directory
./wsseapi.c:    soap->crlfile = "revoked.pem"; // use CRL (optional)
./wsseapi.c:    soap->cafile = "cacerts.pem";  // file with CA certs of peers
./wsseapi.c:    soap->capath = "dir/to/certs"; // and/or point to CA certs directory
./wsseapi.c:    soap->crlfile = "revoked.pem"; // use CRL (optional)
./wsseapi.c:    soap->fsslverify = ssl_verify; // set certificate verification callback
./wsseapi.c:    soap->cafile = "cacerts.pem";  // file with CA certs of peers
./wsseapi.c:    soap->capath = "dir/to/certs"; // and/or point to CA certs directory
./wsseapi.c:    soap->crlfile = "revoked.pem"; // use CRL (optional)
./wsseapi.c:    soap->fsslverify = ssl_verify;
./wsseapi.c:    soap->cafile = "cacerts.pem";  // file with CA certs of peers
./wsseapi.c:    soap->capath = "dir/to/certs"; // and/or point to CA certs directory
./wsseapi.c:    soap->crlfile = "revoked.pem"; // use CRL (optional)
./wsseapi.c:-# After receiving a message, the DOM in soap->dom can be traversed for further    analysis.
./wsseapi.c:    soap->cafile = "cacerts.pem";  // file with CA certs of peers
./wsseapi.c:    soap->capath = "dir/to/certs"; // and/or point to CA certs directory
./wsseapi.c:    soap->crlfile = "revoked.pem"; // use CRL (optional)
./wsseapi.c:    soap->fsslverify = ssl_verify; // optional, a callback to verify peer certificates
./wsseapi.c:When using HTTPS, the `soap->cafile`, `soap->capath` are already set with
./wsseapi.c:    soap->cafile = "cacerts.pem";  // file with CA certs of peers
./wsseapi.c:    soap->capath = "dir/to/certs"; // and/or point to CA certs directory
./wsseapi.c:    soap->crlfile = "revoked.pem"; // use CRL (optional)
./wsseapi.c:    soap->fsslverify = ssl_verify; // optional, a callback to verify peer certificates
./wsseapi.c:        return soap->error;
./wsseapi.c:To implement a server that supports HTTP keep-alive, a `soap->fserveloop`
./wsseapi.c:    soap->fserveloop = set_verify_decrypt_auto;
./wsseapi.c:    soap->cafile = "cacerts.pem";  // same as above (or overrides the above)
./wsseapi.c:    soap->capath = "dir/to/certs"; // and/or point to CA certs
./wsseapi.c:    soap->crlfile = "revoked.pem"; // use CRL (optional)
./wsseapi.c:const char *wsse_Base64BinaryURI = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary";
./wsseapi.c:const char *wsse_HexBinaryURI = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#HexBinary";
./wsseapi.c:  if (!soap->header->wsse__Security)
./wsseapi.c:    soap->header->wsse__Security = (_wsse__Security*)soap_malloc(soap, sizeof(_wsse__Security));
./wsseapi.c:    if (!soap->header->wsse__Security)
./wsseapi.c:    soap_default__wsse__Security(soap, soap->header->wsse__Security);
./wsseapi.c:  return soap->header->wsse__Security;
./wsseapi.c:  if (soap->namespaces && !strcmp(soap->namespaces[0].ns, "http://schemas.xmlsoap.org/soap/envelope/"))
./wsseapi.c:    if (soap->fpreparesend == soap_wsse_preparesend)
./wsseapi.c:      soap->fpreparesend = data->fpreparesend;
./wsseapi.c:    if (soap->fpreparefinalsend == soap_wsse_preparefinalsend)
./wsseapi.c:      soap->fpreparefinalsend = data->fpreparefinalsend;
./wsseapi.c:  soap->feltbegout = NULL;
./wsseapi.c:  soap->feltendout = NULL;
./wsseapi.c:  if (soap->header)
./wsseapi.c:    soap->header->wsse__Security = NULL;
./wsseapi.c:  if (soap->header)
./wsseapi.c:    return soap->header->wsse__Security;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:          return soap->error; 
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:  s = der = (unsigned char*)soap->labbuf;
./wsseapi.c:@brief Verifies X509 certificate against soap->cafile, soap->capath, and soap->crlfile.
./wsseapi.c:    X509_STORE_set_verify_cb_func(data->store, soap->fsslverify);
./wsseapi.c:    if (soap->cafile || soap->capath)
./wsseapi.c:      if (X509_STORE_load_locations(data->store, soap->cafile, soap->capath) != 1)
./wsseapi.c:    if (soap->crlfile)
./wsseapi.c:      if (*soap->crlfile)
./wsseapi.c:        if (X509_load_crl_file(lookup, soap->crlfile, X509_FILETYPE_PEM) != 1)
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:        return soap->error = SOAP_EOM;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:    return soap->error;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:  const char *c14ninclude = soap->c14ninclude;
./wsseapi.c:  soap_wsse_add_SignedInfo_SignatureMethod(soap, method, (soap->mode & SOAP_XML_CANONICAL));
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:  sig = soap->labbuf;
./wsseapi.c:  soap->part = SOAP_IN_HEADER;
./wsseapi.c:  soap->level = 4;
./wsseapi.c:  if (!(soap->mode & SOAP_XML_CANONICAL))
./wsseapi.c:  soap->c14ninclude = NULL;
./wsseapi.c:  soap->c14ninclude = c14ninclude;
./wsseapi.c:    return soap->error;
./wsseapi.c:    return soap->error = SOAP_PLUGIN_ERROR;
./wsseapi.c:    return soap->error;
./wsseapi.c:      soap->error = SOAP_OK;
./wsseapi.c:      soap->error = SOAP_OK;
./wsseapi.c:    err = soap->error;
./wsseapi.c:This function searches for the SignedInfo element in the soap->dom DOM tree to
./wsseapi.c:      return soap->error;
./wsseapi.c:    elt = soap_dom_find(soap->dom, soap->dom, ds_URI, "SignedInfo", 0);
./wsseapi.c:      const char *c14ninclude = soap->c14ninclude;
./wsseapi.c:          soap->c14ninclude = signature->SignedInfo->CanonicalizationMethod->c14n__InclusiveNamespaces->PrefixList;
./wsseapi.c:          soap->c14ninclude = NULL;
./wsseapi.c:        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Verifying signed canonicalized DOM with C14N prefix list '%s'\n", soap->c14ninclude ? soap->c14ninclude : ""));
./wsseapi.c:        soap->mode &= ~SOAP_XML_DOM;
./wsseapi.c:        soap->mode |= SOAP_XML_CANONICAL | SOAP_DOM_ASIS;
./wsseapi.c:        while (soap->nlist)
./wsseapi.c:          struct soap_nlist *np = soap->nlist->next;
./wsseapi.c:          SOAP_FREE(soap, soap->nlist);
./wsseapi.c:          soap->nlist = np;
./wsseapi.c:        soap->mode &= ~(SOAP_XML_CANONICAL | SOAP_XML_DOM);
./wsseapi.c:        soap->mode |= SOAP_DOM_ASIS;
./wsseapi.c:      soap->ns = 2;
./wsseapi.c:      soap->feltbegout = NULL;
./wsseapi.c:      soap->feltendout = NULL;
./wsseapi.c:      soap->c14ninclude = c14ninclude;
./wsseapi.c:      const char *c14nexclude = soap->c14nexclude;
./wsseapi.c:      const char *c14ninclude = soap->c14ninclude;
./wsseapi.c:      soap_mode mode = soap->mode;
./wsseapi.c:      short part = soap->part;
./wsseapi.c:      soap->level = 4;
./wsseapi.c:      soap->c14ninclude = NULL;
./wsseapi.c:      soap->part = SOAP_IN_HEADER; /* header encoding rules (literal) */
./wsseapi.c:      soap->mode &= ~SOAP_XML_DOM;
./wsseapi.c:        soap->mode |= SOAP_XML_CANONICAL;
./wsseapi.c:        soap->mode &= ~SOAP_XML_CANONICAL;
./wsseapi.c:      soap->mode = mode;
./wsseapi.c:      soap->c14nexclude = c14nexclude;
./wsseapi.c:      soap->c14ninclude = c14ninclude;
./wsseapi.c:      soap->part = part;
./wsseapi.c:This function searches for the SignedInfo element in the soap->dom DOM tree to
./wsseapi.c:    elt = soap_dom_find(soap->dom, soap->dom, ds_URI, "Signature", 0);
./wsseapi.c:        const char *c14ninclude = soap->c14ninclude;
./wsseapi.c:              soap->c14ninclude = reference->Transforms->Transform[i].c14n__InclusiveNamespaces->PrefixList;
./wsseapi.c:              soap->c14ninclude = NULL;
./wsseapi.c:          return soap->error;
./wsseapi.c:        soap->c14ninclude = c14ninclude;
./wsseapi.c:  for (elt = soap->dom; elt; elt = soap_dom_next_element(elt, NULL))
./wsseapi.c:      soap->mode &= ~SOAP_XML_DOM;
./wsseapi.c:      soap->mode |= SOAP_XML_CANONICAL | SOAP_DOM_ASIS;
./wsseapi.c:      while (soap->nlist)
./wsseapi.c:        struct soap_nlist *np = soap->nlist->next;
./wsseapi.c:        SOAP_FREE(soap, soap->nlist);
./wsseapi.c:        soap->nlist = np;
./wsseapi.c:      soap->mode &= ~SOAP_XML_CANONICAL;
./wsseapi.c:      soap->mode |= SOAP_DOM_ASIS;
./wsseapi.c:    soap->ns = 2;
./wsseapi.c:    soap->feltbegout = NULL;
./wsseapi.c:    soap->feltendout = NULL;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:  s = der = (unsigned char*)soap->labbuf;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:      s = der = (unsigned char*)soap->labbuf;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:    return soap->error;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:    soap->omode |= SOAP_SEC_WSUID;
./wsseapi.c:      return soap->error;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:        return soap->error;
./wsseapi.c:      if ((soap->omode & SOAP_IO) == SOAP_IO_BUFFER)
./wsseapi.c:        soap->omode = (soap->omode & ~SOAP_IO) | SOAP_IO_CHUNK;
./wsseapi.c:  soap->feltbegout = soap_wsse_element_begin_out;
./wsseapi.c:  soap->feltendout = soap_wsse_element_end_out;
./wsseapi.c:@brief Verifies the EncryptedKey header information (certificate validity requires soap->cacert to be set). Retrieves the decryption key from the token handler callback to decrypt the decryption key.
./wsseapi.c:    if (soap->dom)
./wsseapi.c:      struct soap_dom_element *ek = soap_dom_find(soap->dom, soap->dom, xenc_URI, "EncryptedKey", 0);
./wsseapi.c:          return soap->error;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:  soap_mode omode = soap->omode;
./wsseapi.c:  short version = soap->version;
./wsseapi.c:  soap->version = 0;
./wsseapi.c:  soap->encodingStyle = NULL;
./wsseapi.c:    err = soap->error;
./wsseapi.c:    soap_strcpy(soap->id, sizeof(soap->id), assertion->AssertionID);
./wsseapi.c:    soap->event = SOAP_SEC_BEGIN;
./wsseapi.c:      err = soap->error;
./wsseapi.c:  soap->header->wsse__Security = security;
./wsseapi.c:  soap->omode = omode;
./wsseapi.c:  soap->version = version;
./wsseapi.c:@brief Verifies the SAML 1.0 Assertion with its enveloped signature, requires soap->cacert specified.
./wsseapi.c:  struct soap_dom_element *elt = soap->dom;
./wsseapi.c:  soap_mode omode = soap->omode;
./wsseapi.c:  short version = soap->version;
./wsseapi.c:  soap->version = 0;
./wsseapi.c:  soap->encodingStyle = NULL;
./wsseapi.c:  soap->dom = NULL;
./wsseapi.c:    err = soap->error;
./wsseapi.c:  soap->version = version;
./wsseapi.c:  soap->omode = omode;
./wsseapi.c:  soap->dom = elt;
./wsseapi.c:  soap_mode omode = soap->omode;
./wsseapi.c:  short version = soap->version;
./wsseapi.c:  soap->version = 0;
./wsseapi.c:  soap->encodingStyle = NULL;
./wsseapi.c:    err = soap->error;
./wsseapi.c:    soap_strcpy(soap->id, sizeof(soap->id), assertion->ID);
./wsseapi.c:    soap->event = SOAP_SEC_BEGIN;
./wsseapi.c:      err = soap->error;
./wsseapi.c:  soap->header->wsse__Security = security;
./wsseapi.c:  soap->omode = omode;
./wsseapi.c:  soap->version = version;
./wsseapi.c:@brief Verifies the SAML 2.0 Assertion with its enveloped signature, requires soap->cacert specified.
./wsseapi.c:  struct soap_dom_element *elt = soap->dom;
./wsseapi.c:  soap_mode omode = soap->omode;
./wsseapi.c:  short version = soap->version;
./wsseapi.c:  soap->version = 0;
./wsseapi.c:  soap->encodingStyle = NULL;
./wsseapi.c:  soap->dom = NULL;
./wsseapi.c:    err = soap->error;
./wsseapi.c:  soap->version = version;
./wsseapi.c:  soap->omode = omode;
./wsseapi.c:  soap->dom = elt;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:  soap->feltbegin = soap_wsse_element_begin_in; 
./wsseapi.c:  soap->feltendin = soap_wsse_element_end_in;
./wsseapi.c:  soap->wsuid = soap_strdup(soap, tags);
./wsseapi.c:  if (soap->fpreparesend != soap_wsse_preparesend)
./wsseapi.c:    data->fpreparesend = soap->fpreparesend;
./wsseapi.c:    soap->fpreparesend = soap_wsse_preparesend;
./wsseapi.c:  if (soap->fpreparefinalsend != soap_wsse_preparefinalsend)
./wsseapi.c:    data->fpreparefinalsend = soap->fpreparefinalsend;
./wsseapi.c:    soap->fpreparefinalsend = soap_wsse_preparefinalsend;
./wsseapi.c:  if ((soap->omode & SOAP_ENC_ZLIB))
./wsseapi.c:    soap->omode = (soap->omode & ~SOAP_IO) | SOAP_IO_CHUNK;
./wsseapi.c:  else if ((soap->omode & SOAP_IO) == SOAP_IO_STORE) /* no store buffering (or else fpreparesend not working) */
./wsseapi.c:    soap->omode = (soap->omode & ~SOAP_IO) | SOAP_IO_BUFFER;
./wsseapi.c:  soap->omode &= ~SOAP_XML_DOM;
./wsseapi.c:  soap->omode |= SOAP_SEC_WSUID;
./wsseapi.c:  soap->imode |= SOAP_XML_DOM;
./wsseapi.c:certificate used to verify the signature, which requires soap->cafile and/or
./wsseapi.c:soap->capath to be set.
./wsseapi.c:  if (soap->fpreparefinalrecv != soap_wsse_preparefinalrecv)
./wsseapi.c:    data->fpreparefinalrecv = soap->fpreparefinalrecv;
./wsseapi.c:    soap->fpreparefinalrecv = soap_wsse_preparefinalrecv; 
./wsseapi.c:  soap->imode &= ~SOAP_XML_DOM;
./wsseapi.c:  soap->omode &= ~SOAP_SEC_WSUID;
./wsseapi.c:  if (soap->fpreparefinalrecv == soap_wsse_preparefinalrecv)
./wsseapi.c:    soap->fpreparefinalrecv = data->fpreparefinalrecv;
./wsseapi.c:  if (signedInfo && soap->dom)
./wsseapi.c:    elt = soap->dom;
./wsseapi.c:  if (soap->local_namespaces)
./wsseapi.c:    if (soap->local_namespaces->out)
./wsseapi.c:      ns = soap->local_namespaces->out;
./wsseapi.c:    else if (soap->local_namespaces->ns)
./wsseapi.c:      ns = soap->local_namespaces->ns;
./wsseapi.c:    ns = "http://www.w3.org/2003/05/soap-envelope";
./wsseapi.c:  if (!soap->dom)
./wsseapi.c:  soap->header->wsse__Security = NULL;
./wsseapi.c:    return soap->error = SOAP_EOM;
./wsseapi.c:  soap->header->wsse__Security = security;
./wsseapi.c:  soap->omode |= SOAP_SEC_WSUID;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:      return soap->error = SOAP_EOM;
./wsseapi.c:        return soap->error;
./wsseapi.c:    return soap->error;
./wsseapi.c:  soap->omode &= ~SOAP_XML_DOM;
./wsseapi.c:  soap->feltbegout = soap_wsse_element_begin_out;
./wsseapi.c:  soap->feltendout = soap_wsse_element_end_out;
./wsseapi.c:  if ((soap->mode & SOAP_IO_LENGTH) && ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK || (soap->mode & SOAP_IO) == SOAP_IO_STORE))
./wsseapi.c:  event = soap->event;
./wsseapi.c:  soap->event = 0;
./wsseapi.c:    return soap->error;
./wsseapi.c:      return soap->error;
./wsseapi.c:      return soap->error;
./wsseapi.c:      return soap->error;
./wsseapi.c:    return soap->error;
./wsseapi.c:  soap->event = event;
./wsseapi.c:  soap->level -= 3;
./wsseapi.c:  if ((soap->mode & SOAP_IO_LENGTH) && ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK || (soap->mode & SOAP_IO) == SOAP_IO_STORE))
./wsseapi.c:  event = soap->event;
./wsseapi.c:  soap->event = 0;
./wsseapi.c:  soap->level += 3;
./wsseapi.c:  soap->body = 1;
./wsseapi.c:    return soap->error;
./wsseapi.c:  soap->event = event;
./wsseapi.c:    return soap->error;
./wsseapi.c:    return soap->error;
./wsseapi.c:  if (soap->part == SOAP_IN_ENVELOPE)
./wsseapi.c:    struct soap_dom_element **elt, *dom = soap->dom;
./wsseapi.c:    soap->dom = NULL;
./wsseapi.c:      return soap->error;
./wsseapi.c:    soap->dom = dom->prnt;
./wsseapi.c:    for (elt = &soap->dom->elts; *elt && (*elt)->next; elt = &(*elt)->next)
./wsseapi.c:    if (soap->level > 3)
./wsseapi.c:      soap->level -= 3;
./wsseapi.c:    soap->event = SOAP_SEC_DECRYPT;
./wsseapi.c:  if (soap->event == SOAP_SEC_DECRYPT
./wsseapi.c:   && soap->dom
./wsseapi.c:   && soap->dom->elts
./wsseapi.c:    struct soap_dom_element *dom = soap->dom->elts;
./wsseapi.c:    soap->event = 0;
./wsseapi.c:    soap->dom = NULL;
./wsseapi.c:    soap->level += 3;
./wsseapi.c:    soap->dom = dom;
./wsseapi.c:      return soap->error;
./wsseapi.c:        return soap->error = SOAP_EOM;
./wsseapi.c:        return soap->error;
./wsseapi.c:      struct soap_attribute *tp, *tq, *tr = soap->attributes; /* preserve attribute lists */
./wsseapi.c:      soap->attributes = NULL;
./wsseapi.c:      for (tp = soap->attributes; tp; tp = tq)
./wsseapi.c:      soap->attributes = tr;
./wsseapi.c:    return soap->error;
./wsseapi.c:  if (soap->level <= 1 && !(soap->mode & SOAP_IO_LENGTH))
./wsseapi.c:    soap->feltbegout = NULL;
./wsseapi.c:    soap->feltendout = NULL;
./wsseapi.c:        return soap->error;
./wsseapi.c:        return soap->error;
./wsseapi.c:  soap->c14ninclude = data->prefixlist;
./wsseapi.c:  if (soap->event == SOAP_SEC_BEGIN)
./wsseapi.c:      soap->event = SOAP_SEC_SIGN;
./wsseapi.c:    else if (!data->sigid || soap_tagsearch(data->sigid, soap->id))
./wsseapi.c:      size_t l = strlen(soap->id);
./wsseapi.c:      soap->event = SOAP_SEC_SIGN;
./wsseapi.c:      digest->level = soap->level;
./wsseapi.c:      soap_strcpy(digest->id + 1, l + 1, soap->id);
./wsseapi.c:  if (soap->event == SOAP_SEC_SIGN)
./wsseapi.c:      if (soap->level < data->digest->level)
./wsseapi.c:        soap->event = 0;
./wsseapi.c:    if (soap->mode & SOAP_XML_CANONICAL)
./wsseapi.c:        return soap->error;
./wsseapi.c:      return soap->error;
./wsseapi.c:    if ((soap->mode & SOAP_IO) != SOAP_IO_CHUNK && (soap->mode & SOAP_IO) != SOAP_IO_STORE)
./wsseapi.c:      short part = soap->part;
./wsseapi.c:      soap->part = SOAP_IN_HEADER; /* header encoding rules (literal) */
./wsseapi.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Counting the size of additional SOAP Header elements, mode=0x%x\n", soap->mode));
./wsseapi.c:        const char *c14ninclude = soap->c14ninclude;
./wsseapi.c:        soap->c14ninclude = NULL;
./wsseapi.c:        soap->level = 3; /* indent level for XML Signature */
./wsseapi.c:        if ((soap->mode & SOAP_XML_CANONICAL))
./wsseapi.c:          soap->ns = 0; /* need namespaces for canonicalization */
./wsseapi.c:	  if ((soap->mode & SOAP_XML_INDENT))
./wsseapi.c:	    soap->count += 4; /* correction for soap->ns = 0: add \n+indent */
./wsseapi.c:        soap->c14ninclude = c14ninclude;
./wsseapi.c:        const char *c14nexclude = soap->c14nexclude;
./wsseapi.c:        soap->c14nexclude = "ds xsi"; /* don't add xmlns:ds or xmlns:xsi to count msg len */
./wsseapi.c:        soap->level = 4; /* indent level for XML SignedInfo */
./wsseapi.c:        if ((soap->mode & SOAP_XML_CANONICAL))
./wsseapi.c:          soap->ns = 0; /* need namespaces for canonicalization */
./wsseapi.c:	  if ((soap->mode & SOAP_XML_INDENT))
./wsseapi.c:	    soap->count += 5; /* correction for soap->ns = 0: add \n+indent */
./wsseapi.c:        soap->c14nexclude = c14nexclude;
./wsseapi.c:      soap->part = part;
./wsseapi.c:  if (soap->fpreparefinalsend)
./wsseapi.c:    return soap->fpreparefinalsend(soap);
./wsseapi.c:  if (soap->fpreparesend == soap_wsse_preparesend)
./wsseapi.c:    soap->fpreparesend = data->fpreparesend;
./wsseapi.c:  if (soap->fpreparefinalsend == soap_wsse_preparefinalsend)
./wsseapi.c:    soap->fpreparefinalsend = data->fpreparefinalsend;
./wsseapi.c:  soap->omode &= ~SOAP_SEC_WSUID;
./wsseapi.c:    return soap->error;
./wsdd.nsmap.bak:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./wsdd.nsmap.bak:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./wsdd.nsmap:        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
./wsdd.nsmap:        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
./Makefile:#INCLUDE= -I../gsoap/gsoap-2.8/gsoap -I../gsoap/gsoap-2.8/gsoap/import -I../gsoap/gsoap-2.8/gsoap/plugin
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsa:MessageID>b9335468-079c-4227-97c7-47a68f59fa8f</wsa:MessageID><wsa:To SOAP-ENV:mustUnderstand="true">urn:schemas-xmlsoap-org:ws:2005:04:discovery</wsa:To><wsa:Action SOAP-ENV:mustUnderstand="true">http://schemas.xmlsoap.org/ws/2005/04/discovery/Probe</wsa:Action></SOAP-ENV:Header><SOAP-ENV:Body><wsdd:Probe><wsdd:Types>tdn:NetworkVideoTransmitter</wsdd:Types><wsdd:Scopes></wsdd:Scopes></wsdd:Probe></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsa:MessageID>e85731b1-5d49-45d7-828b-09b3511ff81f</wsa:MessageID></SOAP-ENV:Header><SOAP-ENV:Body><tds:GetCapabilities><tds:Category>All</tds:Category></tds:GetCapabilities></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">vl9Vxyx3/8rI+amR2OdF72XuQrQ=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">v5XTWJF/6sgGgG2/qfN8gNWndW4=</wsse:Nonce><wsu:Created>2017-03-23T09:30:39Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><trt:GetProfiles></trt:GetProfiles></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">Yuitc4zPlEnEKL3fBJg+OoaqBl8=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">wJXTWHxlhTWmM5UP4bxA9j0PSCg=</wsse:Nonce><wsu:Created>2017-03-23T09:30:40Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><trt:SetVideoEncoderConfiguration><trt:Configuration token="000"><tt:Name>VideoEncoderConfig_Channel1_MainStream</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>JPEG</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4</tt:Quality><tt:RateControl><tt:FrameRateLimit>18</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:H264><tt:GovLength>36</tt:GovLength><tt:H264Profile>High</tt:H264Profile></tt:H264><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.0</tt:IPv4Address></tt:Address><tt:Port>40000</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></trt:Configuration><trt:ForcePersistence>true</trt:ForcePersistence></trt:SetVideoEncoderConfiguration></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsa:MessageID>404449fb-b604-46f9-8ad0-f33cf94d8133</wsa:MessageID><wsa:To SOAP-ENV:mustUnderstand="true">urn:schemas-xmlsoap-org:ws:2005:04:discovery</wsa:To><wsa:Action SOAP-ENV:mustUnderstand="true">http://schemas.xmlsoap.org/ws/2005/04/discovery/Probe</wsa:Action></SOAP-ENV:Header><SOAP-ENV:Body><wsdd:Probe><wsdd:Types>tdn:NetworkVideoTransmitter</wsdd:Types><wsdd:Scopes></wsdd:Scopes></wsdd:Probe></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsa:MessageID>1017d8d3-051a-488b-889c-0ad0ec90cb66</wsa:MessageID></SOAP-ENV:Header><SOAP-ENV:Body><tds:GetCapabilities><tds:Category>All</tds:Category></tds:GetCapabilities></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">LAaT0Lyp8sxwNXbQZBCJhaM0Gd8=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">CJbTWNoHCbV/JXquu+IcUvPAnlY=</wsse:Nonce><wsu:Created>2017-03-23T09:31:52Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><trt:GetProfiles></trt:GetProfiles></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">08Gu5Xxe0H1AoxCtj1IMCVRcvZo=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">CJbTWCDCgSwJF/7Ri7VrifAgVe8=</wsse:Nonce><wsu:Created>2017-03-23T09:31:52Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><trt:SetVideoEncoderConfiguration><trt:Configuration token="000"><tt:Name>VideoEncoderConfig_Channel1_MainStream</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>JPEG</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4</tt:Quality><tt:RateControl><tt:FrameRateLimit>18</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:H264><tt:GovLength>36</tt:GovLength><tt:H264Profile>High</tt:H264Profile></tt:H264><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.0</tt:IPv4Address></tt:Address><tt:Port>40000</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></trt:Configuration><trt:ForcePersistence>true</trt:ForcePersistence></trt:SetVideoEncoderConfiguration></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsa:MessageID>00243a88-2277-4738-b151-9a6e8c99c6e3</wsa:MessageID><wsa:To SOAP-ENV:mustUnderstand="true">urn:schemas-xmlsoap-org:ws:2005:04:discovery</wsa:To><wsa:Action SOAP-ENV:mustUnderstand="true">http://schemas.xmlsoap.org/ws/2005/04/discovery/Probe</wsa:Action></SOAP-ENV:Header><SOAP-ENV:Body><wsdd:Probe><wsdd:Types>tdn:NetworkVideoTransmitter</wsdd:Types><wsdd:Scopes></wsdd:Scopes></wsdd:Probe></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsa:MessageID>88c5254a-0385-4e67-a4f9-43cd5d03a612</wsa:MessageID></SOAP-ENV:Header><SOAP-ENV:Body><tds:GetCapabilities><tds:Category>All</tds:Category></tds:GetCapabilities></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">Z0aJ+zxHN7D40MVYSREsgNjL+P8=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">JJbTWJNYcCKDZM/x7HCNoJI/oZ4=</wsse:Nonce><wsu:Created>2017-03-23T09:32:20Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><trt:GetProfiles></trt:GetProfiles></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">Ea+8rUI8gqNBqTdwe05IZjaD5nI=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">JZbTWJk6xJDBHcDLQXnd2xHHOQs=</wsse:Nonce><wsu:Created>2017-03-23T09:32:21Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><trt:SetVideoEncoderConfiguration><trt:Configuration token="000"><tt:Name>VideoEncoderConfig_Channel1_MainStream</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>H264</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4</tt:Quality><tt:RateControl><tt:FrameRateLimit>18</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:H264><tt:GovLength>36</tt:GovLength><tt:H264Profile>High</tt:H264Profile></tt:H264><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.0</tt:IPv4Address></tt:Address><tt:Port>40000</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></trt:Configuration><trt:ForcePersistence>true</trt:ForcePersistence></trt:SetVideoEncoderConfiguration></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">t2inKPLnI3lna3ncHiP0HdLVJcM=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">JZbTWOF6gW/KblRHLK5xxcllc8c=</wsse:Nonce><wsu:Created>2017-03-23T09:32:21Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><trt:SetVideoEncoderConfiguration><trt:Configuration token="001"><tt:Name>VideoEncoderConfig_Channel1_SubStream1</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>JPEG</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4</tt:Quality><tt:RateControl><tt:FrameRateLimit>18</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.1</tt:IPv4Address></tt:Address><tt:Port>40008</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></trt:Configuration><trt:ForcePersistence>true</trt:ForcePersistence></trt:SetVideoEncoderConfiguration></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">5hq8j0j5rm+n8eAa0PDxfrU6UAg=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">JZbTWL8s6A3qqEf/wpyFHcu2xn0=</wsse:Nonce><wsu:Created>2017-03-23T09:32:21Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><tds:GetNetworkInterfaces></tds:GetNetworkInterfaces></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsa:MessageID>2e3ece47-602e-42ce-8908-04831e1a13a0</wsa:MessageID><wsa:To SOAP-ENV:mustUnderstand="true">urn:schemas-xmlsoap-org:ws:2005:04:discovery</wsa:To><wsa:Action SOAP-ENV:mustUnderstand="true">http://schemas.xmlsoap.org/ws/2005/04/discovery/Probe</wsa:Action></SOAP-ENV:Header><SOAP-ENV:Body><wsdd:Probe><wsdd:Types>tdn:NetworkVideoTransmitter</wsdd:Types><wsdd:Scopes></wsdd:Scopes></wsdd:Probe></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsa:MessageID>dfffda36-44e9-4fea-bac5-801fb0753b0b</wsa:MessageID></SOAP-ENV:Header><SOAP-ENV:Body><tds:GetCapabilities><tds:Category>All</tds:Category></tds:GetCapabilities></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">Oj4JlZWYvYdUIJ16uL+HWv1pSA4=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">HJfTWDVf23jYVDoqmQwcnI006JQ=</wsse:Nonce><wsu:Created>2017-03-23T09:36:28Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><trt:GetProfiles></trt:GetProfiles></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">pc+mY6fQk/MbR3QFXyQzJG1h2F0=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">HJfTWJwfWuZEnyLIE2R9BrIkSWg=</wsse:Nonce><wsu:Created>2017-03-23T09:36:28Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><trt:SetVideoEncoderConfiguration><trt:Configuration token="000"><tt:Name>VideoEncoderConfig_Channel1_MainStream</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>H264</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4</tt:Quality><tt:RateControl><tt:FrameRateLimit>18</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:H264><tt:GovLength>36</tt:GovLength><tt:H264Profile>High</tt:H264Profile></tt:H264><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.0</tt:IPv4Address></tt:Address><tt:Port>40000</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></trt:Configuration><trt:ForcePersistence>true</trt:ForcePersistence></trt:SetVideoEncoderConfiguration></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">9aiP1QL0QZ/zj+XvtqWpVCcvMbI=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">HJfTWOrmfozO0T4NmLa6i5uQHNI=</wsse:Nonce><wsu:Created>2017-03-23T09:36:28Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><trt:SetVideoEncoderConfiguration><trt:Configuration token="001"><tt:Name>VideoEncoderConfig_Channel1_SubStream1</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>JPEG</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4</tt:Quality><tt:RateControl><tt:FrameRateLimit>18</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.1</tt:IPv4Address></tt:Address><tt:Port>40008</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></trt:Configuration><trt:ForcePersistence>true</trt:ForcePersistence></trt:SetVideoEncoderConfiguration></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">OUIAAqX4M1zpnFAVemp1ZKzIYTs=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">HJfTWKzmq11zQQkNbVUEexI0xuw=</wsse:Nonce><wsu:Created>2017-03-23T09:36:28Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><tds:GetNetworkInterfaces></tds:GetNetworkInterfaces></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsa:MessageID>18c13a1a-520a-4f32-9344-0b4a5d110d76</wsa:MessageID><wsa:To SOAP-ENV:mustUnderstand="true">urn:schemas-xmlsoap-org:ws:2005:04:discovery</wsa:To><wsa:Action SOAP-ENV:mustUnderstand="true">http://schemas.xmlsoap.org/ws/2005/04/discovery/Probe</wsa:Action></SOAP-ENV:Header><SOAP-ENV:Body><wsdd:Probe><wsdd:Types>tdn:NetworkVideoTransmitter</wsdd:Types><wsdd:Scopes></wsdd:Scopes></wsdd:Probe></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsa:MessageID>e4d6be88-5e22-4a98-87ae-4ae9338ce21d</wsa:MessageID></SOAP-ENV:Header><SOAP-ENV:Body><tds:GetCapabilities><tds:Category>All</tds:Category></tds:GetCapabilities></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">QLaK5urKu+2/bl2MPEDU9vqyljY=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">OpfTWLNVLhOF0MMu/kiEX1NHL0U=</wsse:Nonce><wsu:Created>2017-03-23T09:36:58Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><trt:GetProfiles></trt:GetProfiles></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">OAgq2uB49uT3ECamEJUdhqHwlfY=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">OpfTWAOc8YpKjLXyzfGQtsnR5mU=</wsse:Nonce><wsu:Created>2017-03-23T09:36:58Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><trt:SetVideoEncoderConfiguration><trt:Configuration token="000"><tt:Name>VideoEncoderConfig_Channel1_MainStream</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>H264</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4</tt:Quality><tt:RateControl><tt:FrameRateLimit>18</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:H264><tt:GovLength>36</tt:GovLength><tt:H264Profile>High</tt:H264Profile></tt:H264><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.0</tt:IPv4Address></tt:Address><tt:Port>40000</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></trt:Configuration><trt:ForcePersistence>true</trt:ForcePersistence></trt:SetVideoEncoderConfiguration></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">uw0X/vIkDXNY04O3D0GJPuJ8bx8=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">O5fTWBs+ghSVSVSPRmuxT4TERrE=</wsse:Nonce><wsu:Created>2017-03-23T09:36:59Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><trt:GetStreamUri><trt:StreamSetup><tt:Stream>RTP-Unicast</tt:Stream><tt:Transport><tt:Protocol>UDP</tt:Protocol></tt:Transport></trt:StreamSetup><trt:ProfileToken>MediaProfile000</trt:ProfileToken></trt:GetStreamUri></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsa:MessageID>50a35cc4-fafc-41f5-972c-e67efe7211c5</wsa:MessageID><wsa:To SOAP-ENV:mustUnderstand="true">urn:schemas-xmlsoap-org:ws:2005:04:discovery</wsa:To><wsa:Action SOAP-ENV:mustUnderstand="true">http://schemas.xmlsoap.org/ws/2005/04/discovery/Probe</wsa:Action></SOAP-ENV:Header><SOAP-ENV:Body><wsdd:Probe><wsdd:Types>tdn:NetworkVideoTransmitter</wsdd:Types><wsdd:Scopes></wsdd:Scopes></wsdd:Probe></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsa:MessageID>4842682b-413c-4f42-aacc-8ffe1c09cce3</wsa:MessageID></SOAP-ENV:Header><SOAP-ENV:Body><tds:GetCapabilities><tds:Category>All</tds:Category></tds:GetCapabilities></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">cwHh69N2t/Xw6c48vQlBNkuzzmA=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">85fTWN64HS2FejLIzIk7AjdOt40=</wsse:Nonce><wsu:Created>2017-03-23T09:40:03Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><trt:GetProfiles></trt:GetProfiles></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">W0jhFTKwOrwWOetCQlAAZuM4LD8=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">9JfTWHVJQHxv9A+NAWKYW7kHfNM=</wsse:Nonce><wsu:Created>2017-03-23T09:40:04Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><trt:SetVideoEncoderConfiguration><trt:Configuration token="000"><tt:Name>VideoEncoderConfig_Channel1_MainStream</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>H264</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4</tt:Quality><tt:RateControl><tt:FrameRateLimit>18</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:H264><tt:GovLength>36</tt:GovLength><tt:H264Profile>High</tt:H264Profile></tt:H264><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.0</tt:IPv4Address></tt:Address><tt:Port>40000</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></trt:Configuration><trt:ForcePersistence>true</trt:ForcePersistence></trt:SetVideoEncoderConfiguration></SOAP-ENV:Body></SOAP-ENV:Envelope>
./SENT.log:<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:SOAP-ENC="http://www.w3.org/2003/05/soap-encoding" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:wsdd="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:chan="http://schemas.microsoft.com/ws/2005/02/duplex" xmlns:wsa5="http://www.w3.org/2005/08/addressing" xmlns:c14n="http://www.w3.org/2001/10/xml-exc-c14n#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:saml1="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:wsc="http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xmime="http://tempuri.org/xmime.xsd" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:ns3="http://www.onvif.org/ver10/pacs" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsrfbf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:wstop="http://docs.oasis-open.org/wsn/t-1" xmlns:wsrfr="http://docs.oasis-open.org/wsrf/r-2" xmlns:ns1="http://www.onvif.org/ver10/actionengine/wsdl" xmlns:ns2="http://www.onvif.org/ver10/accesscontrol/wsdl" xmlns:ns4="http://www.onvif.org/ver10/doorcontrol/wsdl" xmlns:ns5="http://www.onvif.org/ver10/advancedsecurity/wsdl" xmlns:tad="http://www.onvif.org/ver10/analyticsdevice/wsdl" xmlns:tan="http://www.onvif.org/ver20/analytics/wsdl" xmlns:tdn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tev="http://www.onvif.org/ver10/events/wsdl" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:timg="http://www.onvif.org/ver20/imaging/wsdl" xmlns:tls="http://www.onvif.org/ver10/display/wsdl" xmlns:tmd="http://www.onvif.org/ver10/deviceIO/wsdl" xmlns:tptz="http://www.onvif.org/ver20/ptz/wsdl" xmlns:trc="http://www.onvif.org/ver10/recording/wsdl" xmlns:trp="http://www.onvif.org/ver10/replay/wsdl" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:trv="http://www.onvif.org/ver10/receiver/wsdl" xmlns:tse="http://www.onvif.org/ver10/search/wsdl"><SOAP-ENV:Header><wsse:Security SOAP-ENV:mustUnderstand="true"><wsse:UsernameToken wsu:Id="user"><wsse:Username>admin</wsse:Username><wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">rd8ZCS5e0NUJwUkVYJ5L2lIAujo=</wsse:Password><wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">9JfTWHj4S8TRs0xSsef+bVAvdsI=</wsse:Nonce><wsu:Created>2017-03-23T09:40:04Z</wsu:Created></wsse:UsernameToken></wsse:Security></SOAP-ENV:Header><SOAP-ENV:Body><trt:GetStreamUri><trt:StreamSetup><tt:Stream>RTP-Unicast</tt:Stream><tt:Transport><tt:Protocol>UDP</tt:Protocol></tt:Transport></trt:StreamSetup><trt:ProfileToken>MediaProfile000</trt:ProfileToken></trt:GetStreamUri></SOAP-ENV:Body></SOAP-ENV:Envelope>
匹配到二进制文件 ./client_onvif_test
./stdsoap2.c:static const char soap_env2[40] = "http://www.w3.org/2003/05/soap-envelope";
./stdsoap2.c:static const char soap_enc2[40] = "http://www.w3.org/2003/05/soap-encoding";
./stdsoap2.c:static const char soap_rpc[35] = "http://www.w3.org/2003/05/soap-rpc";
./stdsoap2.c:  if (soap->os)
./stdsoap2.c:  { soap->os->write(s, (std::streamsize)n);
./stdsoap2.c:    if (soap->os->good())
./stdsoap2.c:    soap->errnum = 0;
./stdsoap2.c:  sk = soap->sendsk;
./stdsoap2.c:    sk = soap->socket;
./stdsoap2.c:    { if (soap->send_timeout)
./stdsoap2.c:          if (soap->ssl)
./stdsoap2.c:            r = tcp_select(soap, sk, SOAP_TCP_SELECT_ALL, soap->send_timeout);
./stdsoap2.c:          if (soap->session)
./stdsoap2.c:            r = tcp_select(soap, sk, SOAP_TCP_SELECT_ALL, soap->send_timeout);
./stdsoap2.c:          if (soap->ssl)
./stdsoap2.c:            r = tcp_select(soap, sk, SOAP_TCP_SELECT_ALL, soap->send_timeout);
./stdsoap2.c:            r = tcp_select(soap, sk, SOAP_TCP_SELECT_SND | SOAP_TCP_SELECT_ERR, soap->send_timeout);
./stdsoap2.c:          err = soap->errnum;
./stdsoap2.c:            return soap->error;
./stdsoap2.c:      if (soap->ssl)
./stdsoap2.c:        nwritten = SSL_write(soap->ssl, s, (int)n);
./stdsoap2.c:      else if (soap->bio)
./stdsoap2.c:        nwritten = BIO_write(soap->bio, s, (int)n);
./stdsoap2.c:      if (soap->session)
./stdsoap2.c:        nwritten = gnutls_record_send(soap->session, s, n);
./stdsoap2.c:      if (soap->ssl)
./stdsoap2.c:      { err = gsk_secure_socket_write(soap->ssl, (char*)s, n, &nwritten);
./stdsoap2.c:      if ((soap->omode & SOAP_IO_UDP))
./stdsoap2.c:      { if (soap->peerlen)
./stdsoap2.c:          nwritten = sendto(sk, (char*)s, (SOAP_WINSOCKINT)n, soap->socket_flags, &soap->peer.addr, (SOAP_WINSOCKINT)soap->peerlen);
./stdsoap2.c:          nwritten = send(sk, s, (SOAP_WINSOCKINT)n, soap->socket_flags);
./stdsoap2.c:          if ((soap->connect_flags & SO_BROADCAST))
./stdsoap2.c:            if (soap->peerlen)
./stdsoap2.c:              nwritten = sendto(sk, (char*)s, (SOAP_WINSOCKINT)n, soap->socket_flags, &soap->peer.addr, (SOAP_WINSOCKINT)soap->peerlen);
./stdsoap2.c:              nwritten = send(sk, s, (SOAP_WINSOCKINT)n, soap->socket_flags);
./stdsoap2.c:          { soap->errnum = err;
./stdsoap2.c:        nwritten = send(sk, s, (int)n, soap->socket_flags);
./stdsoap2.c:        nwritten = send(sk, (void*)s, n, soap->socket_flags);
./stdsoap2.c:        if (soap->ssl && (r = SSL_get_error(soap->ssl, nwritten)) != SSL_ERROR_NONE && r != SSL_ERROR_WANT_READ && r != SSL_ERROR_WANT_WRITE)
./stdsoap2.c:        { soap->errnum = err;
./stdsoap2.c:        if (soap->session)
./stdsoap2.c:          if (soap->ssl && r == SSL_ERROR_WANT_READ)
./stdsoap2.c:            r = tcp_select(soap, sk, SOAP_TCP_SELECT_RCV | SOAP_TCP_SELECT_ERR, soap->send_timeout ? soap->send_timeout : -10000);
./stdsoap2.c:          if (soap->session && !gnutls_record_get_direction(soap->session))
./stdsoap2.c:            r = tcp_select(soap, sk, SOAP_TCP_SELECT_RCV | SOAP_TCP_SELECT_ERR, soap->send_timeout ? soap->send_timeout : -10000);
./stdsoap2.c:            r = tcp_select(soap, sk, SOAP_TCP_SELECT_SND | SOAP_TCP_SELECT_ERR, soap->send_timeout ? soap->send_timeout : -10000);
./stdsoap2.c:          if (!r && soap->send_timeout)
./stdsoap2.c:        { soap->errnum = err;
./stdsoap2.c:      nwritten = fwrite(s, 1, n, soap->sendfd);
./stdsoap2.c:      if (soap->rpmreqid)
./stdsoap2.c:        nwritten = (httpBlockPut(soap->rpmreqid, (char*)s, n) == 0) ? n : -1;
./stdsoap2.c:        nwritten = fwrite(s, sizeof(char), n, fdopen(soap->sendfd, "w"));
./stdsoap2.c:      nwritten = _write(soap->sendfd, s, (unsigned int)n);
./stdsoap2.c:      nwritten = write(soap->sendfd, s, (unsigned int)n);
./stdsoap2.c:        { soap->errnum = err;
./stdsoap2.c:  if (soap->fpreparesend && (soap->mode & SOAP_IO) != SOAP_IO_STORE && (soap->mode & SOAP_IO_LENGTH) && (soap->error = soap->fpreparesend(soap, s, n)) != SOAP_OK)
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  if (soap->ffiltersend && (soap->error = soap->ffiltersend(soap, &s, &n)) != SOAP_OK)
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  if ((soap->mode & SOAP_IO_LENGTH))
./stdsoap2.c:    soap->count += n;
./stdsoap2.c:  else if (soap->mode & SOAP_IO)
./stdsoap2.c:  { size_t i = sizeof(soap->buf) - soap->bufidx;
./stdsoap2.c:    { soap_memcpy((void*)(soap->buf + soap->bufidx), i, (const void*)s, i);
./stdsoap2.c:      soap->bufidx = sizeof(soap->buf);
./stdsoap2.c:        return soap->error;
./stdsoap2.c:      i = sizeof(soap->buf);
./stdsoap2.c:    soap_memcpy((void*)(soap->buf + soap->bufidx), sizeof(soap->buf) - soap->bufidx, (const void*)s, n);
./stdsoap2.c:    soap->bufidx += n;
./stdsoap2.c:{ size_t n = soap->bufidx;
./stdsoap2.c:    if ((soap->mode & SOAP_IO) == SOAP_IO_STORE)
./stdsoap2.c:      if (soap->fpreparesend && (r = soap->fpreparesend(soap, soap->buf, n)) != SOAP_OK)
./stdsoap2.c:        return soap->error = r;
./stdsoap2.c:    soap->bufidx = 0;
./stdsoap2.c:    if (soap->mode & SOAP_ENC_ZLIB)
./stdsoap2.c:    { soap->d_stream->next_in = (Byte*)soap->buf;
./stdsoap2.c:      soap->d_stream->avail_in = (unsigned int)n;
./stdsoap2.c:      soap->z_crc = crc32(soap->z_crc, (Byte*)soap->buf, (unsigned int)n);
./stdsoap2.c:      { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Deflating %u bytes\n", soap->d_stream->avail_in));
./stdsoap2.c:        if (deflate(soap->d_stream, Z_NO_FLUSH) != Z_OK)
./stdsoap2.c:        { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unable to deflate: %s\n", soap->d_stream->msg ? soap->d_stream->msg : SOAP_STR_EOS));
./stdsoap2.c:          return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:        if (!soap->d_stream->avail_out)
./stdsoap2.c:        { if (soap_flush_raw(soap, soap->z_buf, sizeof(soap->buf)))
./stdsoap2.c:            return soap->error;
./stdsoap2.c:          soap->d_stream->next_out = (Byte*)soap->z_buf;
./stdsoap2.c:          soap->d_stream->avail_out = sizeof(soap->buf);
./stdsoap2.c:      } while (soap->d_stream->avail_in);
./stdsoap2.c:      return soap_flush_raw(soap, soap->buf, n);
./stdsoap2.c:{ if ((soap->mode & SOAP_IO) == SOAP_IO_STORE)
./stdsoap2.c:      return soap->error = SOAP_EOM;
./stdsoap2.c:  if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK)
./stdsoap2.c:    (SOAP_SNPRINTF(t, sizeof(t), 20), &"\r\n%lX\r\n"[soap->chunksize ? 0 : 2], (unsigned long)n);
./stdsoap2.c:    soap->error = soap->fsend(soap, t, strlen(t));
./stdsoap2.c:    if (soap->error)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    soap->chunksize += n;
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Send %u bytes to socket=%d/fd=%d\n", (unsigned int)n, (int)soap->socket, soap->sendfd));
./stdsoap2.c:  return soap->error = soap->fsend(soap, s, n);
./stdsoap2.c:    return soap->error;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:{ if (!soap->body && soap_send_raw(soap, "&", 1))
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  soap->body = 0;
./stdsoap2.c:{ soap_encode_url(s, soap->msgbuf, sizeof(soap->msgbuf));
./stdsoap2.c:  return soap_send(soap, soap->msgbuf);
./stdsoap2.c:  soap->errnum = 0;
./stdsoap2.c:  if (soap->is) /* recv from C++ stream */
./stdsoap2.c:  { if (soap->is->good())
./stdsoap2.c:      return (size_t)soap->is->read(s, (std::streamsize)n).gcount();
./stdsoap2.c:  if (soap->is) /* recv from C buffer until NUL */
./stdsoap2.c:  { size_t l = strlen(soap->is);
./stdsoap2.c:    soap_memcpy(s, n, soap->is, l);
./stdsoap2.c:    soap->is += l;
./stdsoap2.c:  sk = soap->recvsk;
./stdsoap2.c:    sk = soap->socket;
./stdsoap2.c:      if (soap->recv_timeout && !soap->ssl) /* OpenSSL: sockets are nonblocking so go ahead to read */
./stdsoap2.c:      if (soap->recv_timeout)
./stdsoap2.c:        { r = tcp_select(soap, sk, SOAP_TCP_SELECT_RCV | SOAP_TCP_SELECT_ERR, soap->recv_timeout);
./stdsoap2.c:          r = soap->errnum;
./stdsoap2.c:      if (soap->ssl)
./stdsoap2.c:      { r = SSL_read(soap->ssl, s, (int)n);
./stdsoap2.c:        err = SSL_get_error(soap->ssl, r);
./stdsoap2.c:      else if (soap->bio)
./stdsoap2.c:      { r = BIO_read(soap->bio, s, (int)n);
./stdsoap2.c:      if (soap->session)
./stdsoap2.c:      { r = (int)gnutls_record_recv(soap->session, s, n);
./stdsoap2.c:      if (soap->ssl)
./stdsoap2.c:      { err = gsk_secure_socket_read(soap->ssl, s, n, &r);
./stdsoap2.c:        if ((soap->omode & SOAP_IO_UDP))
./stdsoap2.c:        { SOAP_SOCKLEN_T k = (SOAP_SOCKLEN_T)sizeof(soap->peer);
./stdsoap2.c:          memset((void*)&soap->peer, 0, sizeof(soap->peer));
./stdsoap2.c:          r = recvfrom(sk, s, (SOAP_WINSOCKINT)n, soap->socket_flags, &soap->peer.addr, &k);    /* portability note: see SOAP_SOCKLEN_T definition in stdsoap2.h */
./stdsoap2.c:          soap->peerlen = (size_t)k;
./stdsoap2.c:          soap->ip = ntohl(soap->peer.in.sin_addr.s_addr);
./stdsoap2.c:          r = recv(sk, s, (SOAP_WINSOCKINT)n, soap->socket_flags);
./stdsoap2.c:        { soap->errnum = r;
./stdsoap2.c:      if (soap->ssl && err == SSL_ERROR_WANT_WRITE)
./stdsoap2.c:        r = tcp_select(soap, sk, SOAP_TCP_SELECT_SND | SOAP_TCP_SELECT_ERR, soap->recv_timeout ? soap->recv_timeout : 5);
./stdsoap2.c:      if (soap->session && gnutls_record_get_direction(soap->session))
./stdsoap2.c:        r = tcp_select(soap, sk, SOAP_TCP_SELECT_SND | SOAP_TCP_SELECT_ERR, soap->recv_timeout ? soap->recv_timeout : 5);
./stdsoap2.c:      if (soap->ssl && err == GSK_WOULD_BLOCK_WRITE)
./stdsoap2.c:        r = tcp_select(soap, sk, SOAP_TCP_SELECT_SND | SOAP_TCP_SELECT_ERR, soap->recv_timeout ? soap->recv_timeout : 5);
./stdsoap2.c:        r = tcp_select(soap, sk, SOAP_TCP_SELECT_RCV | SOAP_TCP_SELECT_ERR, soap->recv_timeout ? soap->recv_timeout : 5);
./stdsoap2.c:      if (!r && soap->recv_timeout)
./stdsoap2.c:      { r = soap->errnum;
./stdsoap2.c:      { soap->errnum = r;
./stdsoap2.c:  return fread(s, 1, n, soap->recvfd);
./stdsoap2.c:  if (soap->rpmreqid)
./stdsoap2.c:    r = httpBlockRead(soap->rpmreqid, s, n);
./stdsoap2.c:    r = _read(soap->recvfd, s, (unsigned int)n);
./stdsoap2.c:    r = read(soap->recvfd, s, n);
./stdsoap2.c:  soap->errnum = soap_errno;
./stdsoap2.c:{ if (soap->bufidx < soap->buflen)
./stdsoap2.c:    return soap->buf[soap->bufidx++];
./stdsoap2.c:  soap->bufidx = 0;
./stdsoap2.c:  soap->buflen = soap->chunkbuflen = soap->frecv(soap, soap->buf, sizeof(soap->buf));
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Read %u bytes from socket=%d/fd=%d\n", (unsigned int)soap->buflen, (int)soap->socket, soap->recvfd));
./stdsoap2.c:  DBGMSG(RECV, soap->buf, soap->buflen);
./stdsoap2.c:  if (soap->buflen)
./stdsoap2.c:    return soap->buf[soap->bufidx++];
./stdsoap2.c:  if ((soap->mode & SOAP_ENC_ZLIB) && soap->d_stream)
./stdsoap2.c:  { if (soap->d_stream->next_out == Z_NULL)
./stdsoap2.c:    { soap->bufidx = soap->buflen = 0;
./stdsoap2.c:    if (soap->d_stream->avail_in || !soap->d_stream->avail_out)
./stdsoap2.c:      soap->d_stream->next_out = (Byte*)soap->buf;
./stdsoap2.c:      soap->d_stream->avail_out = sizeof(soap->buf);
./stdsoap2.c:      r = inflate(soap->d_stream, Z_NO_FLUSH);
./stdsoap2.c:      if (r == Z_NEED_DICT && soap->z_dict)
./stdsoap2.c:        r = inflateSetDictionary(soap->d_stream, (const Bytef*)soap->z_dict, soap->z_dict_len);
./stdsoap2.c:      { soap->bufidx = 0;
./stdsoap2.c:        ret = soap->buflen = sizeof(soap->buf) - soap->d_stream->avail_out;
./stdsoap2.c:        if (soap->zlib_in == SOAP_ZLIB_GZIP)
./stdsoap2.c:          soap->z_crc = crc32(soap->z_crc, (Byte*)soap->buf, (unsigned int)ret);
./stdsoap2.c:        { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inflated %lu->%lu bytes\n", soap->d_stream->total_in, soap->d_stream->total_out));
./stdsoap2.c:          soap->z_ratio_in = (float)soap->d_stream->total_in / (float)soap->d_stream->total_out;
./stdsoap2.c:          soap->d_stream->next_out = Z_NULL;
./stdsoap2.c:        { soap->count += ret;
./stdsoap2.c:          if (soap->count > SOAP_MAXINFLATESIZE && soap->z_ratio_in < SOAP_MINDEFLATERATIO)
./stdsoap2.c:          { soap->d_stream->msg = (char*)"caught SOAP_MINDEFLATERATIO explosive decompression guard (remedy: increase SOAP_MAXINFLATESIZE and/or decrease SOAP_MINDEFLATERATIO)";
./stdsoap2.c:            return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:          DBGMSG(RECV, soap->buf, ret);
./stdsoap2.c:          if (soap->fpreparerecv && (r = soap->fpreparerecv(soap, soap->buf, ret)) != SOAP_OK)
./stdsoap2.c:            return soap->error = r;
./stdsoap2.c:      { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inflate error: %s\n", soap->d_stream->msg ? soap->d_stream->msg : SOAP_STR_EOS));
./stdsoap2.c:        soap->d_stream->next_out = Z_NULL;
./stdsoap2.c:        return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:    if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK && !soap->chunksize)
./stdsoap2.c:    { soap_memcpy((void*)soap->buf, sizeof(soap->buf), (const void*)soap->z_buf, sizeof(soap->buf));
./stdsoap2.c:      soap->buflen = soap->z_buflen;
./stdsoap2.c:  if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK) /* read HTTP chunked transfer */
./stdsoap2.c:      if (soap->chunksize)
./stdsoap2.c:      { soap->buflen = ret = soap->frecv(soap, soap->buf, soap->chunksize > sizeof(soap->buf) ? sizeof(soap->buf) : soap->chunksize);
./stdsoap2.c:        DBGMSG(RECV, soap->buf, ret);
./stdsoap2.c:        soap->bufidx = 0;
./stdsoap2.c:        soap->chunksize -= ret;
./stdsoap2.c:      if (!soap->chunkbuflen)
./stdsoap2.c:      { soap->chunkbuflen = ret = soap->frecv(soap, soap->buf, sizeof(soap->buf));
./stdsoap2.c:        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Read %u bytes (chunked) from socket=%d\n", (unsigned int)ret, (int)soap->socket));
./stdsoap2.c:        DBGMSG(RECV, soap->buf, ret);
./stdsoap2.c:        soap->bufidx = 0;
./stdsoap2.c:        { soap->ahead = EOF;
./stdsoap2.c:        soap->bufidx = soap->buflen;
./stdsoap2.c:      soap->buflen = soap->chunkbuflen;
./stdsoap2.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Getting chunk size (idx=%u len=%u)\n", (unsigned int)soap->bufidx, (unsigned int)soap->buflen));
./stdsoap2.c:        { soap->ahead = EOF;
./stdsoap2.c:      { soap->ahead = EOF;
./stdsoap2.c:      soap->chunksize = (size_t)soap_strtoul(tmp, &t, 16);
./stdsoap2.c:      if (!soap->chunksize)
./stdsoap2.c:      { soap->bufidx = soap->buflen = soap->chunkbuflen = 0;
./stdsoap2.c:        soap->ahead = EOF;
./stdsoap2.c:      soap->buflen = soap->bufidx + soap->chunksize;
./stdsoap2.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Moving buf len to idx=%u len=%u (%s)\n", (unsigned int)soap->bufidx, (unsigned int)soap->buflen, tmp));
./stdsoap2.c:      if (soap->buflen > soap->chunkbuflen)
./stdsoap2.c:      { soap->buflen = soap->chunkbuflen;
./stdsoap2.c:        soap->chunksize -= soap->buflen - soap->bufidx;
./stdsoap2.c:        soap->chunkbuflen = 0;
./stdsoap2.c:        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Passed end of buffer for chunked HTTP (%u bytes left)\n", (unsigned int)(soap->buflen - soap->bufidx)));
./stdsoap2.c:      else if (soap->chunkbuflen)
./stdsoap2.c:        soap->chunksize = 0;
./stdsoap2.c:      ret = soap->buflen - soap->bufidx;
./stdsoap2.c:  { soap->bufidx = 0;
./stdsoap2.c:    soap->buflen = ret = soap->frecv(soap, soap->buf, sizeof(soap->buf));
./stdsoap2.c:    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Read %u bytes from socket=%d/fd=%d\n", (unsigned int)ret, (int)soap->socket, soap->recvfd));
./stdsoap2.c:    DBGMSG(RECV, soap->buf, ret);
./stdsoap2.c:  if (soap->mode & SOAP_ENC_ZLIB)
./stdsoap2.c:  { soap_memcpy((void*)soap->z_buf, sizeof(soap->buf), (const void*)soap->buf, sizeof(soap->buf));
./stdsoap2.c:    soap->d_stream->next_in = (Byte*)(soap->z_buf + soap->bufidx);
./stdsoap2.c:    soap->d_stream->avail_in = (unsigned int)ret;
./stdsoap2.c:    soap->d_stream->next_out = (Byte*)soap->buf;
./stdsoap2.c:    soap->d_stream->avail_out = sizeof(soap->buf);
./stdsoap2.c:    r = inflate(soap->d_stream, Z_NO_FLUSH);
./stdsoap2.c:    if (r == Z_NEED_DICT && soap->z_dict)
./stdsoap2.c:      r = inflateSetDictionary(soap->d_stream, (const Bytef*)soap->z_dict, soap->z_dict_len);
./stdsoap2.c:    { soap->bufidx = 0;
./stdsoap2.c:      soap->z_buflen = soap->buflen;
./stdsoap2.c:      soap->buflen = sizeof(soap->buf) - soap->d_stream->avail_out;
./stdsoap2.c:      if (soap->zlib_in == SOAP_ZLIB_GZIP)
./stdsoap2.c:        soap->z_crc = crc32(soap->z_crc, (Byte*)soap->buf, (unsigned int)soap->buflen);
./stdsoap2.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inflated %u bytes\n", (unsigned int)soap->buflen));
./stdsoap2.c:      if (ret && !soap->buflen && r != Z_STREAM_END)
./stdsoap2.c:      ret = soap->buflen;
./stdsoap2.c:      { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inflated total %lu->%lu bytes\n", soap->d_stream->total_in, soap->d_stream->total_out));
./stdsoap2.c:        soap->z_ratio_in = (float)soap->d_stream->total_in / (float)soap->d_stream->total_out;
./stdsoap2.c:        soap->d_stream->next_out = Z_NULL;
./stdsoap2.c:      if (soap->count + ret > SOAP_MAXINFLATESIZE && soap->z_ratio_in < SOAP_MINDEFLATERATIO)
./stdsoap2.c:      { soap->d_stream->msg = (char*)"caught SOAP_MINDEFLATERATIO explosive decompression guard (remedy: increase SOAP_MAXINFLATESIZE and/or decrease SOAP_MINDEFLATERATIO)";
./stdsoap2.c:        return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:      DBGMSG(RECV, soap->buf, ret);
./stdsoap2.c:      if (soap->fpreparerecv && (r = soap->fpreparerecv(soap, soap->buf, ret)) != SOAP_OK)
./stdsoap2.c:        return soap->error = r;
./stdsoap2.c:    { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unable to inflate: (%d) %s\n", r, soap->d_stream->msg ? soap->d_stream->msg : SOAP_STR_EOS));
./stdsoap2.c:      soap->d_stream->next_out = Z_NULL;
./stdsoap2.c:      return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:  if (soap->fpreparerecv
./stdsoap2.c:   && soap->zlib_in == SOAP_ZLIB_NONE
./stdsoap2.c:   && (r = soap->fpreparerecv(soap, soap->buf + soap->bufidx, ret)))
./stdsoap2.c:    return soap->error = r;
./stdsoap2.c:  { soap->count += ret;
./stdsoap2.c:    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Read count=%lu (+%lu)\n", (unsigned long)soap->count, (unsigned long)ret));
./stdsoap2.c:  if (soap->mode & SOAP_ENC_DIME)
./stdsoap2.c:  { if (soap->dime.buflen)
./stdsoap2.c:      soap->count += soap->dime.buflen - soap->buflen;
./stdsoap2.c:      soap->buflen = soap->dime.buflen;
./stdsoap2.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Skip padding (%ld bytes)\n", -(long)soap->dime.size&3));
./stdsoap2.c:      for (i = -(long)soap->dime.size&3; i > 0; i--)
./stdsoap2.c:      { soap->bufidx++;
./stdsoap2.c:        if (soap->bufidx >= soap->buflen)
./stdsoap2.c:      { *s++ = soap->buf[soap->bufidx++];
./stdsoap2.c:        if (soap->bufidx >= soap->buflen)
./stdsoap2.c:      soap->dime.flags = tmp[0] & 0x7;
./stdsoap2.c:      soap->dime.size = ((size_t)tmp[8] << 24) | ((size_t)tmp[9] << 16) | ((size_t)tmp[10] << 8) | ((size_t)tmp[11]);
./stdsoap2.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Get DIME chunk (%u bytes)\n", (unsigned int)soap->dime.size));
./stdsoap2.c:      if (soap->dime.flags & SOAP_DIME_CF)
./stdsoap2.c:        soap->dime.chunksize = soap->dime.size;
./stdsoap2.c:        if (soap->buflen - soap->bufidx >= soap->dime.size)
./stdsoap2.c:        { soap->dime.buflen = soap->buflen;
./stdsoap2.c:          soap->buflen = soap->bufidx + soap->dime.chunksize;
./stdsoap2.c:          soap->dime.chunksize -= soap->buflen - soap->bufidx;
./stdsoap2.c:        soap->dime.buflen = 0;
./stdsoap2.c:        soap->dime.chunksize = 0;
./stdsoap2.c:      soap->count = soap->buflen - soap->bufidx;
./stdsoap2.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "%u bytes remaining\n", (unsigned int)soap->count));
./stdsoap2.c:    if (soap->dime.chunksize)
./stdsoap2.c:    { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Get next DIME hdr for chunked DIME (%u bytes chunk)\n", (unsigned int)soap->dime.chunksize));
./stdsoap2.c:      if (soap->buflen - soap->bufidx >= soap->dime.chunksize)
./stdsoap2.c:      { soap->dime.buflen = soap->buflen;
./stdsoap2.c:        soap->count -= soap->buflen - soap->bufidx - soap->dime.chunksize;
./stdsoap2.c:        soap->buflen = soap->bufidx + soap->dime.chunksize;
./stdsoap2.c:        soap->dime.chunksize -= soap->buflen - soap->bufidx;
./stdsoap2.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "%lu bytes remaining, count=%lu\n", (unsigned long)(soap->buflen-soap->bufidx), (unsigned long)soap->count));
./stdsoap2.c:  if (soap->ffilterrecv)
./stdsoap2.c:    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Filter recverror = %d bufidx = %lu buflen = %lu\n", soap->recverror, (unsigned long)soap->bufidx, (unsigned long)soap->buflen));
./stdsoap2.c:    if (soap->recverror)
./stdsoap2.c:      soap->bufidx = soap->buflen = 0;
./stdsoap2.c:    { soap->bufidx = soap->buflen = 0;
./stdsoap2.c:      err = soap->ffilterrecv(soap, soap->buf, &soap->buflen, sizeof(soap->buf));
./stdsoap2.c:        return soap->error = err;
./stdsoap2.c:      if (soap->buflen)
./stdsoap2.c:      { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Filtered output continued %lu bytes\n", (unsigned long)soap->buflen));
./stdsoap2.c:      soap->recverror = soap_recv_raw(soap);
./stdsoap2.c:      soap->buflen -= soap->bufidx; /* chunked may set bufidx > 0 to skip hex chunk length */
./stdsoap2.c:    while (soap->ffilterrecv)
./stdsoap2.c:    { err = soap->ffilterrecv(soap, soap->buf + soap->bufidx, &soap->buflen, sizeof(soap->buf) - soap->bufidx);
./stdsoap2.c:        return soap->error = err;
./stdsoap2.c:      if (soap->buflen)
./stdsoap2.c:      { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Filtered output %lu bytes\n", (unsigned long)soap->buflen));
./stdsoap2.c:        soap->buflen += soap->bufidx;
./stdsoap2.c:      if (soap->recverror)
./stdsoap2.c:      { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Returning postponed error %d\n", soap->recverror));
./stdsoap2.c:        return soap->recverror;
./stdsoap2.c:      soap->recverror = soap_recv_raw(soap);
./stdsoap2.c:      soap->buflen -= soap->bufidx; /* chunked may set bufidx > 0 to skip hex chunk length */
./stdsoap2.c:  return soap->recverror = soap_recv_raw(soap);
./stdsoap2.c:  c = soap->ahead;
./stdsoap2.c:      soap->ahead = 0;
./stdsoap2.c:{ char *t = soap->tmpbuf;
./stdsoap2.c:        if (t != soap->tmpbuf)
./stdsoap2.c:        while (*s && t < soap->tmpbuf + sizeof(soap->tmpbuf) - 1)
./stdsoap2.c:        if (t == soap->tmpbuf + sizeof(soap->tmpbuf) - 1)
./stdsoap2.c:  return soap->tmpbuf;
./stdsoap2.c:{ if (soap->bufidx >= soap->buflen && soap_recv(soap))
./stdsoap2.c:  return (unsigned char)soap->buf[soap->bufidx];
./stdsoap2.c:{ if (soap->bufidx >= soap->buflen && soap_recv(soap))
./stdsoap2.c:  return (unsigned char)soap->buf[soap->bufidx++];
./stdsoap2.c:  c = soap->ahead;
./stdsoap2.c:      soap->ahead = 0;
./stdsoap2.c:  { if (soap->cdata)
./stdsoap2.c:          { soap->cdata = 0;
./stdsoap2.c:              soap->cdata = 1;
./stdsoap2.c:        soap->mode |= SOAP_ENC_LATIN;
./stdsoap2.c:        soap->mode &= ~SOAP_ENC_LATIN;
./stdsoap2.c:{ return soap->count - soap->buflen + soap->bufidx - (soap->ahead != 0);
./stdsoap2.c:  c = soap->ahead;
./stdsoap2.c:    soap->ahead = 0;
./stdsoap2.c:  if (c < 0x80 || c > 0xFF || (soap->mode & SOAP_ENC_LATIN))
./stdsoap2.c:  if ((soap->mode & SOAP_XML_DOM) && soap->dom)
./stdsoap2.c:  { soap->dom->text = soap_s2hex(soap, s, NULL, n);
./stdsoap2.c:    if (!soap->dom->text)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  if ((soap->mode & SOAP_XML_DOM) && soap->dom)
./stdsoap2.c:  { soap->dom->text = soap_string_in(soap, 0, -1, -1, NULL);
./stdsoap2.c:    return (unsigned char*)soap_hex2s(soap, soap->dom->text, NULL, 0, n);
./stdsoap2.c:  soap->labidx = 0;
./stdsoap2.c:    s = soap->labbuf + soap->labidx;
./stdsoap2.c:    k = soap->lablen - soap->labidx;
./stdsoap2.c:    soap->labidx = soap->lablen;
./stdsoap2.c:        { soap->error = SOAP_TYPE;
./stdsoap2.c:        l = (long)(soap->lablen + i - k);
./stdsoap2.c:        if (soap->maxlength > 0 && l > soap->maxlength)
./stdsoap2.c:          soap->error = SOAP_LENGTH;
./stdsoap2.c:            soap_memcpy((void*)p, (size_t)l, (const void*)soap->labbuf, (size_t)l);
./stdsoap2.c:    l = (long)soap->lablen;
./stdsoap2.c:    if (soap->maxlength > 0 && l > soap->maxlength)
./stdsoap2.c:    { soap->error = SOAP_LENGTH;
./stdsoap2.c:          soap->error = SOAP_TYPE;
./stdsoap2.c:        if (soap->maxlength > 0 && l > soap->maxlength)
./stdsoap2.c:        { soap->error = SOAP_LENGTH;
./stdsoap2.c:    if (soap->maxlength > 0 && l > soap->maxlength)
./stdsoap2.c:    { soap->error = SOAP_LENGTH;
./stdsoap2.c:  if ((soap->mode & SOAP_XML_DOM) && soap->dom)
./stdsoap2.c:  { soap->dom->text = soap_s2base64(soap, s, NULL, n);
./stdsoap2.c:    if (!soap->dom->text)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:      return soap->error;
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  if ((soap->mode & SOAP_XML_DOM) && soap->dom)
./stdsoap2.c:  { soap->dom->text = soap_string_in(soap, 0, -1, -1, NULL);
./stdsoap2.c:    return (unsigned char*)soap_base642s(soap, soap->dom->text, NULL, 0, n);
./stdsoap2.c:  soap->labidx = 0;
./stdsoap2.c:    s = soap->labbuf + soap->labidx;
./stdsoap2.c:    k = soap->lablen - soap->labidx;
./stdsoap2.c:    soap->labidx = 3 * (soap->lablen / 3);
./stdsoap2.c:            l = (long)(soap->lablen + i - k);
./stdsoap2.c:            if (soap->maxlength > 0 && l > soap->maxlength)
./stdsoap2.c:              soap->error = SOAP_LENGTH;
./stdsoap2.c:                soap_memcpy((void*)p, (size_t)l, (const void*)soap->labbuf, (size_t)l);
./stdsoap2.c:            { soap->error = SOAP_TYPE;
./stdsoap2.c:          { soap->error = SOAP_TYPE;
./stdsoap2.c:      l = (long)soap->lablen;
./stdsoap2.c:      if (soap->maxlength > 0 && l > soap->maxlength)
./stdsoap2.c:      { soap->error = SOAP_LENGTH;
./stdsoap2.c:          if (soap->maxlength > 0 && l > soap->maxlength)
./stdsoap2.c:          { soap->error = SOAP_LENGTH;
./stdsoap2.c:          { soap->error = SOAP_TYPE;
./stdsoap2.c:        { soap->error = SOAP_TYPE;
./stdsoap2.c:    if (soap->maxlength > 0 && l > soap->maxlength)
./stdsoap2.c:    { soap->error = SOAP_LENGTH;
./stdsoap2.c:  short body = soap->body; /* should save type too? */
./stdsoap2.c:       || (soap->body && soap_element_end_in(soap, "xop:Include")))
./stdsoap2.c:        return soap->error;
./stdsoap2.c:  soap->body = body;
./stdsoap2.c:  if (!*soap->href)
./stdsoap2.c:  *id = soap_strdup(soap, soap->href);
./stdsoap2.c:    return soap->error = SOAP_EOM;
./stdsoap2.c:  xp->next = soap->xlist;
./stdsoap2.c:  soap->xlist = xp;
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "New block sequence (prev=%p)\n", (void*)soap->blist));
./stdsoap2.c:  { soap->error = SOAP_EOM;
./stdsoap2.c:  p->next = soap->blist;
./stdsoap2.c:  soap->blist = p;
./stdsoap2.c:    b = soap->blist;
./stdsoap2.c:  { soap->error = SOAP_EOM;
./stdsoap2.c:{ if (b && b->item >= soap->maxoccurs) /* restrict block array length */
./stdsoap2.c:  { soap->error = SOAP_OCCURS;
./stdsoap2.c:    b = soap->blist;
./stdsoap2.c:  if ((soap->version && !(soap->imode & SOAP_XML_TREE)) || (soap->mode & SOAP_XML_GRAPH))
./stdsoap2.c:      for (ip = soap->iht[i]; ip; ip = ip->next)
./stdsoap2.c:  for (xp = soap->xlist; xp; xp = xp->next)
./stdsoap2.c:  { for (ip = soap->iht[i]; ip; ip = ip->next)
./stdsoap2.c:    for (ip = soap->iht[i]; ip; ip = ip->next)
./stdsoap2.c:                return soap->error = SOAP_EOM;
./stdsoap2.c:        soap_strcpy(soap->id, sizeof(soap->id), ip->id + 1);
./stdsoap2.c:        return soap->error = SOAP_MISSING_ID;
./stdsoap2.c:      for (ip = soap->iht[i]; ip; ip = ip->next)
./stdsoap2.c:    b = soap->blist;
./stdsoap2.c:    b = soap->blist;
./stdsoap2.c:    b = soap->blist;
./stdsoap2.c:    b = soap->blist;
./stdsoap2.c:    b = soap->blist;
./stdsoap2.c:    if (soap->blist == b)
./stdsoap2.c:      soap->blist = b->next;
./stdsoap2.c:      for (bp = soap->blist; bp; bp = bp->next)
./stdsoap2.c:  DBGLOG(TEST, if (soap->blist) SOAP_MESSAGE(fdebug, "Restored previous block sequence\n"));
./stdsoap2.c:  if (!soap->blist && ((soap->version && !(soap->imode & SOAP_XML_TREE)) || (soap->mode & SOAP_XML_GRAPH)))
./stdsoap2.c:      for (ip = soap->iht[i]; ip; ip = ip->next)
./stdsoap2.c:    b = soap->blist;
./stdsoap2.c:      soap->error = SOAP_EOM;
./stdsoap2.c:  if (soap->version == 2)
./stdsoap2.c:  if (soap->version != 2 && offset)
./stdsoap2.c:  { (SOAP_SNPRINTF(soap->type, sizeof(soap->type) - 1, strlen(type) + 20), "%s[%d", type, size[0] + offset[0]);
./stdsoap2.c:    { size_t l = strlen(soap->type);
./stdsoap2.c:      (SOAP_SNPRINTF(soap->type + l, sizeof(soap->type) - l - 1, 20), t, size[i] + offset[i]);
./stdsoap2.c:  { (SOAP_SNPRINTF(soap->type, sizeof(soap->type) - 1, strlen(type) + 20), "%s[%d", type, size[0]);
./stdsoap2.c:    { size_t l = strlen(soap->type);
./stdsoap2.c:      (SOAP_SNPRINTF(soap->type + l, sizeof(soap->type) - l - 1, 20), t, size[i]);
./stdsoap2.c:  (void)soap_strncat(soap->type, sizeof(soap->type), "]", 1);
./stdsoap2.c:  return soap->type;
./stdsoap2.c:  soap->arrayOffset[0] = '\0';
./stdsoap2.c:  if (soap->version == 1)
./stdsoap2.c:  { (SOAP_SNPRINTF(soap->arrayOffset, sizeof(soap->arrayOffset) - 1, 20), "[%d", offset[0]);
./stdsoap2.c:    { size_t l = strlen(soap->arrayOffset);
./stdsoap2.c:      (SOAP_SNPRINTF(soap->arrayOffset + l, sizeof(soap->arrayOffset) - l - 1, 20), ",%d", offset[i]);
./stdsoap2.c:    (void)soap_strncat(soap->arrayOffset, sizeof(soap->arrayOffset), "]", 1);
./stdsoap2.c:  return soap->arrayOffset;
./stdsoap2.c:  p = soap->local_namespaces;
./stdsoap2.c:  { soap->error = SOAP_EOM;
./stdsoap2.c:  np->next = soap->nlist;
./stdsoap2.c:  soap->nlist = np;
./stdsoap2.c:  np->level = soap->level;
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Push namespace binding (level=%u) '%s'='%s'\n", soap->level, id, ns));
./stdsoap2.c:  for (np = soap->nlist; np && np->level >= soap->level; np = nq)
./stdsoap2.c:    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Pop namespace binding (level=%u) '%s' level=%u\n", soap->level, np->id, np->level));
./stdsoap2.c:  soap->nlist = np;
./stdsoap2.c:{ struct soap_nlist *np = soap->nlist;
./stdsoap2.c:  { if (!(soap->mode & SOAP_XML_IGNORENS) && (n2 > 0 || !np->ns || *np->ns))
./stdsoap2.c:       || ((s = soap->local_namespaces[np->index].id) && (strncmp(s, id2, n2) || (s[n2] && s[n2] != '_'))))
./stdsoap2.c:    return n2 == 0 || (soap->mode & SOAP_XML_IGNORENS) ? SOAP_OK : SOAP_NAMESPACE;
./stdsoap2.c:   || (soap->mode & SOAP_XML_IGNORENS))
./stdsoap2.c:  return soap->error = SOAP_SYNTAX_ERROR;
./stdsoap2.c:  np = soap->nlist;
./stdsoap2.c:      soap->error = SOAP_NAMESPACE;
./stdsoap2.c:      return soap->namespaces[np->index].ns;
./stdsoap2.c:  np = soap->nlist;
./stdsoap2.c:    soap->error = SOAP_NAMESPACE;
./stdsoap2.c:      return soap->namespaces[np->index].ns;
./stdsoap2.c:      if (t != tag2 && !(soap->mode & SOAP_XML_IGNORENS))
./stdsoap2.c:    { if ((soap->mode & SOAP_XML_IGNORENS) || soap_match_namespace(soap, tag1, tag2, 0, t - tag2))
./stdsoap2.c:  { if (!(soap->mode & SOAP_XML_IGNORENS) || SOAP_STRCMP(s + 1, tag2)) /* always fails (except when ignoring ns) */
./stdsoap2.c:  else if (SOAP_STRCMP(tag1, tag2) || ((soap->mode & SOAP_XML_STRICT) && !(soap->mode & SOAP_XML_IGNORENS) && soap_match_namespace(soap, tag1, tag2, 0, 0))) /* strict checking: default namespace must be null namespace */
./stdsoap2.c:      if (t != tag2 && !(soap->mode & SOAP_XML_IGNORENS))
./stdsoap2.c:  { if (!(soap->mode & SOAP_XML_IGNORENS) || SOAP_STRCMP(s + 1, tag2)) /* always fails (except when ignoring ns) */
./stdsoap2.c:{ if (type && *soap->arrayType)
./stdsoap2.c:  { if (soap->version == 1 || !strchr(type, '['))
./stdsoap2.c:    { if (soap_match_tag(soap, soap->arrayType, type)
./stdsoap2.c:        && soap_match_tag(soap, soap->arrayType, "xsd:anyType")
./stdsoap2.c:        && soap_match_tag(soap, soap->arrayType, "xsd:ur-type"))
./stdsoap2.c:      { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SOAP array type mismatch: '%s' '%s'\n", soap->arrayType, type));
./stdsoap2.c:  soap->keyfile = keyfile;
./stdsoap2.c:  soap->keyid = keyid;
./stdsoap2.c:  soap->password = password;
./stdsoap2.c:  soap->cafile = cafile;
./stdsoap2.c:  soap->capath = capath;
./stdsoap2.c:  soap->dhfile = dhfile;
./stdsoap2.c:  soap->randfile = randfile;
./stdsoap2.c:  if (!soap->fsslverify)
./stdsoap2.c:    soap->fsslverify = ssl_verify_callback;
./stdsoap2.c:  soap->ssl_flags = flags | (dhfile == NULL ? SOAP_SSL_RSA : 0);
./stdsoap2.c:    if (!soap->dh_params)
./stdsoap2.c:      gnutls_dh_params_init(&soap->dh_params);
./stdsoap2.c:      gnutls_dh_params_generate2(soap->dh_params, (unsigned int)n);
./stdsoap2.c:      if (gnutls_dh_params_import_pkcs3(soap->dh_params, &dparams, GNUTLS_X509_FMT_PEM))
./stdsoap2.c:  { if (!soap->rsa_params)
./stdsoap2.c:      gnutls_rsa_params_init(&soap->rsa_params);
./stdsoap2.c:    gnutls_rsa_params_generate2(soap->rsa_params, SOAP_SSL_RSA_BITS);
./stdsoap2.c:  if (soap->session)
./stdsoap2.c:  { gnutls_deinit(soap->session);
./stdsoap2.c:    soap->session = NULL;
./stdsoap2.c:  if (soap->xcred)
./stdsoap2.c:  { gnutls_certificate_free_credentials(soap->xcred);
./stdsoap2.c:    soap->xcred = NULL;
./stdsoap2.c:  if (soap->ctx)
./stdsoap2.c:    gsk_environment_close(&soap->ctx);
./stdsoap2.c:  err = soap->fsslauth(soap);
./stdsoap2.c:      SSL_CTX_set_session_id_context(soap->ctx, (unsigned char*)sid, (unsigned int)strlen(sid));
./stdsoap2.c:      SSL_CTX_set_session_cache_mode(soap->ctx, SSL_SESS_CACHE_OFF);
./stdsoap2.c:{ soap->keyfile = keyfile;
./stdsoap2.c:  soap->keyid = keyid;
./stdsoap2.c:  soap->password = password;
./stdsoap2.c:  soap->cafile = cafile;
./stdsoap2.c:  soap->capath = capath;
./stdsoap2.c:  soap->ssl_flags = SOAP_SSL_CLIENT | flags;
./stdsoap2.c:  soap->dhfile = NULL;
./stdsoap2.c:  soap->randfile = randfile;
./stdsoap2.c:  if (!soap->fsslverify)
./stdsoap2.c:    soap->fsslverify = (flags & SOAP_SSL_ALLOW_EXPIRED_CERTIFICATE) == 0 ? ssl_verify_callback : ssl_verify_callback_allow_expired_certificate;
./stdsoap2.c:  if (soap->session)
./stdsoap2.c:  { gnutls_deinit(soap->session);
./stdsoap2.c:    soap->session = NULL;
./stdsoap2.c:  if (soap->xcred)
./stdsoap2.c:  { gnutls_certificate_free_credentials(soap->xcred);
./stdsoap2.c:    soap->xcred = NULL;
./stdsoap2.c:  if (soap->ctx)
./stdsoap2.c:    gsk_environment_close(&soap->ctx);
./stdsoap2.c:  return soap->fsslauth(soap);
./stdsoap2.c:  if (crlfile && soap->ctx)
./stdsoap2.c:    X509_STORE *store = SSL_CTX_get_cert_store(soap->ctx);
./stdsoap2.c:    soap->crlfile = crlfile; /* activate later when store is available */
./stdsoap2.c:  if (crlfile && soap->xcred)
./stdsoap2.c:      if (gnutls_certificate_set_x509_crl_file(soap->xcred, crlfile, GNUTLS_X509_FMT_PEM) < 0)
./stdsoap2.c:    soap->crlfile = crlfile; /* activate later when xcred is available */
./stdsoap2.c:  int err = SSL_get_error(soap->ssl, ret);
./stdsoap2.c:    (SOAP_SNPRINTF(soap->msgbuf, sizeof(soap->msgbuf), strlen(msg) + 1), "%s\n", msg);
./stdsoap2.c:    return ERR_error_string(err, soap->msgbuf);
./stdsoap2.c:    { size_t l = strlen(soap->msgbuf);
./stdsoap2.c:      ERR_error_string_n(r, soap->msgbuf + l, sizeof(soap->msgbuf) - l);
./stdsoap2.c:  { size_t l = strlen(soap->msgbuf);
./stdsoap2.c:        soap_strcpy(soap->msgbuf + l, sizeof(soap->msgbuf) - l, "EOF was observed that violates the SSL/TLS protocol. The client probably provided invalid authentication information.");
./stdsoap2.c:          (SOAP_SNPRINTF(soap->msgbuf + l, sizeof(soap->msgbuf) - l, strlen(s) + 42), "Error observed by underlying SSL/TLS BIO: %s", s);
./stdsoap2.c:  return soap->msgbuf;
./stdsoap2.c:  if (!soap->ctx)
./stdsoap2.c:    soap->ctx = SSL_CTX_new(TLS_method());
./stdsoap2.c:    soap->ctx = SSL_CTX_new(SSLv23_method());
./stdsoap2.c:    if (!soap->ctx)
./stdsoap2.c:    SSL_CTX_set_mode(soap->ctx, SSL_MODE_ENABLE_PARTIAL_WRITE | SSL_MODE_AUTO_RETRY);
./stdsoap2.c:  if (soap->randfile)
./stdsoap2.c:  { if (!RAND_load_file(soap->randfile, -1))
./stdsoap2.c:  if (soap->cafile || soap->capath)
./stdsoap2.c:  { if (!SSL_CTX_load_verify_locations(soap->ctx, soap->cafile, soap->capath))
./stdsoap2.c:    if (soap->cafile && (soap->ssl_flags & SOAP_SSL_REQUIRE_CLIENT_AUTHENTICATION))
./stdsoap2.c:      SSL_CTX_set_client_CA_list(soap->ctx, SSL_load_client_CA_file(soap->cafile));
./stdsoap2.c:  if (!(soap->ssl_flags & SOAP_SSL_NO_DEFAULT_CA_PATH))
./stdsoap2.c:  { if (!SSL_CTX_set_default_verify_paths(soap->ctx))
./stdsoap2.c:  if (soap->crlfile)
./stdsoap2.c:  { if (soap_ssl_crl(soap, soap->crlfile))
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  if (soap->keyfile)
./stdsoap2.c:  { if (!SSL_CTX_use_certificate_chain_file(soap->ctx, soap->keyfile))
./stdsoap2.c:    if (soap->password)
./stdsoap2.c:    { SSL_CTX_set_default_passwd_cb_userdata(soap->ctx, (void*)soap->password);
./stdsoap2.c:      SSL_CTX_set_default_passwd_cb(soap->ctx, ssl_password);
./stdsoap2.c:    if (!SSL_CTX_use_PrivateKey_file(soap->ctx, soap->keyfile, SSL_FILETYPE_PEM))
./stdsoap2.c:  if (soap->password)
./stdsoap2.c:  { SSL_CTX_set_default_passwd_cb_userdata(soap->ctx, (void*)soap->password);
./stdsoap2.c:    SSL_CTX_set_default_passwd_cb(soap->ctx, ssl_password);
./stdsoap2.c:  if (!soap->cafile)
./stdsoap2.c:  { if (soap->keyfile)
./stdsoap2.c:    { if (!SSL_CTX_use_certificate_chain_file(soap->ctx, soap->keyfile))
./stdsoap2.c:      if (!SSL_CTX_use_PrivateKey_file(soap->ctx, soap->keyfile, SSL_FILETYPE_PEM))
./stdsoap2.c:  { if (!SSL_CTX_use_certificate_chain_file(soap->ctx, soap->cafile))
./stdsoap2.c:    if (soap->keyfile)
./stdsoap2.c:      if (!SSL_CTX_use_PrivateKey_file(soap->ctx, soap->keyfile, SSL_FILETYPE_PEM))
./stdsoap2.c:  pkey = ipcom_key_db_pkey_get(soap->keyid);
./stdsoap2.c:  if (!SSL_CTX_use_PrivateKey(soap->ctx, pkey))
./stdsoap2.c:  if ((soap->ssl_flags & SOAP_SSL_RSA))
./stdsoap2.c:    if (SSL_CTX_need_tmp_RSA(soap->ctx))
./stdsoap2.c:      if (!rsa || !SSL_CTX_set_tmp_rsa(soap->ctx, rsa))
./stdsoap2.c:  else if (soap->dhfile)
./stdsoap2.c:    int n = (int)soap_strtoul(soap->dhfile, &s, 10);
./stdsoap2.c:      bio = BIO_new_file(soap->dhfile, "r");
./stdsoap2.c:    if (!dh || DH_check(dh, &n) != 1 || SSL_CTX_set_tmp_dh(soap->ctx, dh) < 0)
./stdsoap2.c:  if ((soap->ssl_flags & SOAP_SSLv3))
./stdsoap2.c:  { if (!(soap->ssl_flags & SOAP_SSLv3_TLSv1))
./stdsoap2.c:    if ((soap->ssl_flags & SOAP_TLSv1_0))
./stdsoap2.c:    else if ((soap->ssl_flags & SOAP_TLSv1_1))
./stdsoap2.c:    else if ((soap->ssl_flags & SOAP_TLSv1_2))
./stdsoap2.c:  SSL_CTX_set_options(soap->ctx, flags);
./stdsoap2.c:  if ((soap->ssl_flags & SOAP_SSL_REQUIRE_CLIENT_AUTHENTICATION))
./stdsoap2.c:  else if ((soap->ssl_flags & SOAP_SSL_REQUIRE_SERVER_AUTHENTICATION))
./stdsoap2.c:  SSL_CTX_set_verify(soap->ctx, mode, soap->fsslverify);
./stdsoap2.c:  SSL_CTX_set_verify_depth(soap->ctx, 1);
./stdsoap2.c:  SSL_CTX_set_verify_depth(soap->ctx, 9);
./stdsoap2.c:  if (!soap->xcred)
./stdsoap2.c:  { gnutls_certificate_allocate_credentials(&soap->xcred);
./stdsoap2.c:    if (soap->cafile)
./stdsoap2.c:    { if (gnutls_certificate_set_x509_trust_file(soap->xcred, soap->cafile, GNUTLS_X509_FMT_PEM) < 0)
./stdsoap2.c:    if (soap->crlfile)
./stdsoap2.c:    { if (soap_ssl_crl(soap, soap->crlfile))
./stdsoap2.c:        return soap->error;
./stdsoap2.c:    if (soap->keyfile)
./stdsoap2.c:    { if (gnutls_certificate_set_x509_key_file(soap->xcred, soap->keyfile, soap->keyfile, GNUTLS_X509_FMT_PEM) < 0) /* Assumes that key and cert(s) are concatenated in the keyfile */
./stdsoap2.c:  if ((soap->ssl_flags & SOAP_SSL_CLIENT))
./stdsoap2.c:  { gnutls_init(&soap->session, GNUTLS_CLIENT);
./stdsoap2.c:    if (soap->cafile || soap->crlfile || soap->keyfile)
./stdsoap2.c:    { ret = gnutls_priority_set_direct(soap->session, "PERFORMANCE", NULL);
./stdsoap2.c:      gnutls_credentials_set(soap->session, GNUTLS_CRD_CERTIFICATE, soap->xcred);
./stdsoap2.c:    { if (!soap->acred)
./stdsoap2.c:        gnutls_anon_allocate_client_credentials(&soap->acred);
./stdsoap2.c:      gnutls_init(&soap->session, GNUTLS_CLIENT);
./stdsoap2.c:      gnutls_priority_set_direct(soap->session, "PERFORMANCE:+ANON-DH:!ARCFOUR-128", NULL);
./stdsoap2.c:      gnutls_credentials_set(soap->session, GNUTLS_CRD_ANON, soap->acred);
./stdsoap2.c:  { if (!soap->keyfile)
./stdsoap2.c:    if ((soap->ssl_flags & SOAP_SSL_RSA) && soap->rsa_params)
./stdsoap2.c:      gnutls_certificate_set_rsa_export_params(soap->xcred, soap->rsa_params);
./stdsoap2.c:    else if (soap->dh_params)
./stdsoap2.c:      gnutls_certificate_set_dh_params(soap->xcred, soap->dh_params);
./stdsoap2.c:    if (!soap->cache)
./stdsoap2.c:      gnutls_priority_init(&soap->cache, "NORMAL", NULL);
./stdsoap2.c:    gnutls_init(&soap->session, GNUTLS_SERVER);
./stdsoap2.c:    gnutls_priority_set(soap->session, soap->cache);
./stdsoap2.c:    gnutls_credentials_set(soap->session, GNUTLS_CRD_CERTIFICATE, soap->xcred);
./stdsoap2.c:    if ((soap->ssl_flags & SOAP_SSL_REQUIRE_CLIENT_AUTHENTICATION))
./stdsoap2.c:      gnutls_certificate_server_set_request(soap->session, GNUTLS_CERT_REQUEST);
./stdsoap2.c:    gnutls_session_enable_compatibility_mode(soap->session);
./stdsoap2.c:    if ((soap->ssl_flags & SOAP_SSLv3))
./stdsoap2.c:      if (gnutls_protocol_set_priority(soap->session, protocol_priority) != GNUTLS_E_SUCCESS)
./stdsoap2.c:    else if ((soap->ssl_flags & SOAP_TLSv1_0))
./stdsoap2.c:      if (gnutls_protocol_set_priority(soap->session, protocol_priority) != GNUTLS_E_SUCCESS)
./stdsoap2.c:    else if ((soap->ssl_flags & SOAP_TLSv1_1))
./stdsoap2.c:      if (gnutls_protocol_set_priority(soap->session, protocol_priority) != GNUTLS_E_SUCCESS)
./stdsoap2.c:    else if ((soap->ssl_flags & SOAP_TLSv1_2))
./stdsoap2.c:      if (gnutls_protocol_set_priority(soap->session, protocol_priority) != GNUTLS_E_SUCCESS)
./stdsoap2.c:    else if ((soap->ssl_flags & SOAP_SSLv3_TLSv1))
./stdsoap2.c:      if (gnutls_protocol_set_priority(soap->session, protocol_priority) != GNUTLS_E_SUCCESS)
./stdsoap2.c:      if (gnutls_protocol_set_priority(soap->session, protocol_priority) != GNUTLS_E_SUCCESS)
./stdsoap2.c:  if (!soap->ctx)
./stdsoap2.c:    err = gsk_environment_open(&soap->ctx);
./stdsoap2.c:      err = gsk_attribute_set_enum(soap->ctx, GSK_PROTOCOL_SSLV2, GSK_PROTOCOL_SSLV2_OFF); 
./stdsoap2.c:    { if ((soap->ssl_flags & SOAP_SSLv3) || (soap->ssl_flags & SOAP_SSLv3_TLSv1))
./stdsoap2.c:        err = gsk_attribute_set_enum(soap->ctx, GSK_PROTOCOL_SSLV3, GSK_PROTOCOL_SSLV3_ON);
./stdsoap2.c:        err = gsk_attribute_set_enum(soap->ctx, GSK_PROTOCOL_SSLV3, GSK_PROTOCOL_SSLV3_OFF);
./stdsoap2.c:    if (!(soap->ssl_flags & SOAP_SSLv3))
./stdsoap2.c:        err = gsk_attribute_set_enum(soap->ctx, GSK_PROTOCOL_TLSV1, GSK_PROTOCOL_TLSV1_ON);
./stdsoap2.c:        err = gsk_attribute_set_enum(soap->ctx, GSK_PROTOCOL_TLSV1_1, GSK_PROTOCOL_TLSV1_1_ON);
./stdsoap2.c:        err = gsk_attribute_set_enum(soap->ctx, GSK_PROTOCOL_TLSV1_2, GSK_PROTOCOL_TLSV1_2_ON); 
./stdsoap2.c:        err = gsk_attribute_set_enum(soap->ctx, GSK_PROTOCOL_TLSV1, GSK_PROTOCOL_TLSV1_OFF);
./stdsoap2.c:        err = gsk_attribute_set_enum(soap->ctx, GSK_PROTOCOL_TLSV1_1, GSK_PROTOCOL_TLSV1_1_OFF);
./stdsoap2.c:        err = gsk_attribute_set_enum(soap->ctx, GSK_PROTOCOL_TLSV1_2, GSK_PROTOCOL_TLSV1_2_OFF); 
./stdsoap2.c:      err = gsk_attribute_set_buffer(soap->ctx, GSK_KEYRING_FILE, soap->keyfile, 0); /* keyfile is a keyring .kdb file */
./stdsoap2.c:      err = gsk_attribute_set_buffer(soap->ctx, GSK_KEYRING_PW, soap->password, 0); /* locked by password */
./stdsoap2.c:      err = gsk_environment_init(soap->ctx);
./stdsoap2.c:  int r = gnutls_certificate_verify_peers2(soap->session, &status);
./stdsoap2.c:  else if (gnutls_certificate_type_get(soap->session) == GNUTLS_CRT_X509)
./stdsoap2.c:    else if ((cert_list = gnutls_certificate_get_peers(soap->session, &cert_list_size)) == NULL)
./stdsoap2.c:    else if (!(soap->ssl_flags & SOAP_SSL_ALLOW_EXPIRED_CERTIFICATE) && gnutls_x509_crt_get_expiration_time(cert) < time(NULL))
./stdsoap2.c:    else if (!(soap->ssl_flags & SOAP_SSL_ALLOW_EXPIRED_CERTIFICATE) && gnutls_x509_crt_get_activation_time(cert) > time(NULL))
./stdsoap2.c:    else if (host && !(soap->ssl_flags & SOAP_SSL_SKIP_HOST_CHECK))
./stdsoap2.c:{ SOAP_SOCKET sk = soap->socket;
./stdsoap2.c:  soap->ssl_flags &= ~SOAP_SSL_CLIENT;
./stdsoap2.c:  if (!soap->ctx && (soap->error = soap->fsslauth(soap)) != SOAP_OK)
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  if (!soap->ssl)
./stdsoap2.c:  { soap->ssl = SSL_new(soap->ctx);
./stdsoap2.c:    if (!soap->ssl)
./stdsoap2.c:    SSL_clear(soap->ssl);
./stdsoap2.c:  SSL_set_bio(soap->ssl, bio, bio);
./stdsoap2.c:  if (soap->accept_timeout)
./stdsoap2.c:    retries = 10*soap->accept_timeout;
./stdsoap2.c:  while ((r = SSL_accept(soap->ssl)) <= 0)
./stdsoap2.c:    err = SSL_get_error(soap->ssl, r);
./stdsoap2.c:    { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:  if ((soap->ssl_flags & SOAP_SSL_REQUIRE_CLIENT_AUTHENTICATION))
./stdsoap2.c:    if ((err = SSL_get_verify_result(soap->ssl)) != X509_V_OK)
./stdsoap2.c:    peer = SSL_get_peer_certificate(soap->ssl);
./stdsoap2.c:  soap->ssl_flags &= ~SOAP_SSL_CLIENT;
./stdsoap2.c:  if (!soap->session && (soap->error = soap->fsslauth(soap)) != SOAP_OK)
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  gnutls_transport_set_ptr(soap->session, (gnutls_transport_ptr_t)(long)sk);
./stdsoap2.c:  if (soap->accept_timeout)
./stdsoap2.c:    retries = 10*soap->accept_timeout;
./stdsoap2.c:  while ((r = gnutls_handshake(soap->session)))
./stdsoap2.c:    { if (!gnutls_record_get_direction(soap->session))
./stdsoap2.c:    { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:  if ((soap->ssl_flags & SOAP_SSL_REQUIRE_CLIENT_AUTHENTICATION))
./stdsoap2.c:  if (soap->accept_timeout)
./stdsoap2.c:    retries = 10*soap->accept_timeout;
./stdsoap2.c:  err = gsk_secure_socket_open(soap->ctx, &soap->ssl);
./stdsoap2.c:    err = gsk_attribute_set_numeric_value(soap->ssl, GSK_FD, sk);
./stdsoap2.c:    err = gsk_attribute_set_buffer(soap->ssl, GSK_KEYRING_LABEL, soap->cafile, 0);
./stdsoap2.c:    err = gsk_attribute_set_enum(soap->ssl, GSK_SESSION_TYPE, GSK_SERVER_SESSION);
./stdsoap2.c:    err = gsk_attribute_set_buffer(soap->ssl, GSK_V3_CIPHER_SPECS_EXPANDED, "0035002F000A", 0);
./stdsoap2.c:    err = gsk_attribute_set_enum(soap->ssl, GSK_V3_CIPHERS, GSK_V3_CIPHERS_CHAR4);
./stdsoap2.c:    err = gsk_attribute_set_callback(soap->ssl, GSK_IO_CALLBACK, &local_io);
./stdsoap2.c:  while ((err = gsk_secure_socket_init(soap->ssl)) != GSK_OK)
./stdsoap2.c:    { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:  if (soap->recv_timeout || soap->send_timeout)
./stdsoap2.c:  soap->imode |= SOAP_ENC_SSL;
./stdsoap2.c:  soap->omode |= SOAP_ENC_SSL;
./stdsoap2.c:{ soap->errmode = 1;
./stdsoap2.c:  switch (soap->errmode)
./stdsoap2.c:      msg = soap_code_str(h_error_codes, soap->errnum);
./stdsoap2.c:      { (SOAP_SNPRINTF(soap->msgbuf, sizeof(soap->msgbuf), 37), "TCP/UDP IP error %d", soap->errnum);
./stdsoap2.c:        msg = soap->msgbuf;
./stdsoap2.c:      return soap->error = SOAP_EOM;
./stdsoap2.c:  if (gethostbyname_r(addr, &hostent, soap->buf, sizeof(soap->buf), &host, &soap->errnum) < 0)
./stdsoap2.c:    soap->errnum = h_errno;
./stdsoap2.c:  host = gethostbyname_r(addr, &hostent, soap->buf, sizeof(soap->buf), &soap->errnum);
./stdsoap2.c:    soap->errnum = soap_errno;
./stdsoap2.c:    soap->errnum = h_errno;
./stdsoap2.c:    return soap->error = SOAP_EOM;
./stdsoap2.c:  if (soap_valid_socket(soap->socket))
./stdsoap2.c:  { if ((soap->omode & SOAP_IO_UDP) && soap->socket == soap->master)
./stdsoap2.c:      if (soap->fresolve(soap, host, &soap->peer.in.sin_addr))
./stdsoap2.c:        soap->fclosesocket(soap, soap->socket);
./stdsoap2.c:        return soap->socket = SOAP_INVALID_SOCKET;
./stdsoap2.c:      soap->peer.in.sin_port = htons((short)port);
./stdsoap2.c:        soap->fclosesocket(soap, soap->socket);
./stdsoap2.c:        return soap->socket = SOAP_INVALID_SOCKET;
./stdsoap2.c:      if (soap_memcpy((void*)&soap->peer.storage, sizeof(soap->peer.storage), (const void*)res->ai_addr, res->ai_addrlen))
./stdsoap2.c:      { soap->error = SOAP_EOM;
./stdsoap2.c:        soap->fclosesocket(soap, soap->socket);
./stdsoap2.c:        return soap->socket = SOAP_INVALID_SOCKET;
./stdsoap2.c:      soap->peerlen = res->ai_addrlen;
./stdsoap2.c:      if (soap->ipv4_multicast_ttl)
./stdsoap2.c:      { unsigned char ttl = soap->ipv4_multicast_ttl;
./stdsoap2.c:        if (setsockopt(soap->socket, IPPROTO_IP, IP_MULTICAST_TTL, (char*)&ttl, sizeof(ttl)))
./stdsoap2.c:        { soap->errnum = soap_socket_errno(soap->socket);
./stdsoap2.c:          soap->fclosesocket(soap, soap->socket);
./stdsoap2.c:          return soap->socket = SOAP_INVALID_SOCKET;
./stdsoap2.c:      if (soap->ipv4_multicast_if && !soap->ipv6_multicast_if)
./stdsoap2.c:      { if (setsockopt(soap->socket, IPPROTO_IP, IP_MULTICAST_IF, (char*)soap->ipv4_multicast_if, sizeof(struct in_addr)))
./stdsoap2.c:        { soap->errnum = soap_socket_errno(soap->socket);
./stdsoap2.c:          soap->fclosesocket(soap, soap->socket);
./stdsoap2.c:          return soap->socket = SOAP_INVALID_SOCKET;
./stdsoap2.c:        if (setsockopt(soap->socket, IPPROTO_IP, IP_MULTICAST_IF, (char*)soap->ipv4_multicast_if, sizeof(struct in_addr)))
./stdsoap2.c:        { soap->errnum = soap_socket_errno(soap->socket);
./stdsoap2.c:          soap->fclosesocket(soap, soap->socket);
./stdsoap2.c:          return soap->socket = SOAP_INVALID_SOCKET;
./stdsoap2.c:      soap->errmode = 0; 
./stdsoap2.c:      return soap->socket;
./stdsoap2.c:    soap->fclosesocket(soap, soap->socket);
./stdsoap2.c:    soap->socket = SOAP_INVALID_SOCKET;
./stdsoap2.c:  { soap->errnum = 0;
./stdsoap2.c:  soap->errmode = 0;
./stdsoap2.c:  if ((soap->omode & SOAP_IO_UDP))
./stdsoap2.c:  soap->errmode = 2;
./stdsoap2.c:  if (soap->proxy_host)
./stdsoap2.c:    err = getaddrinfo(soap->proxy_host, soap_int2s(soap, soap->proxy_port), &hints, &res);
./stdsoap2.c:  soap->error = SOAP_OK;
./stdsoap2.c:  soap->errmode = 0;
./stdsoap2.c:  if ((soap->omode & SOAP_IO_UDP))
./stdsoap2.c:    soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:  if ((soap->connect_flags & SO_LINGER))
./stdsoap2.c:    linger.l_linger = soap->linger_time;
./stdsoap2.c:    { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:      soap->fclosesocket(soap, sk);
./stdsoap2.c:  if ((soap->connect_flags & ~SO_LINGER) && setsockopt(sk, SOL_SOCKET, soap->connect_flags & ~SO_LINGER, (char*)&set, sizeof(int)))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:    soap->fclosesocket(soap, sk);
./stdsoap2.c:  if ((soap->keep_alive || soap->tcp_keep_alive) && setsockopt(sk, SOL_SOCKET, SO_KEEPALIVE, (char*)&set, sizeof(int)))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:    soap->fclosesocket(soap, sk);
./stdsoap2.c:  if (soap->sndbuf > 0 && setsockopt(sk, SOL_SOCKET, SO_SNDBUF, (char*)&soap->sndbuf, sizeof(int)))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:    soap->fclosesocket(soap, sk);
./stdsoap2.c:  if (soap->rcvbuf > 0 && setsockopt(sk, SOL_SOCKET, SO_RCVBUF, (char*)&soap->rcvbuf, sizeof(int)))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:    soap->fclosesocket(soap, sk);
./stdsoap2.c:  if (soap->tcp_keep_idle && setsockopt((SOAP_SOCKET)sk, IPPROTO_TCP, TCP_KEEPIDLE, (char*)&(soap->tcp_keep_idle), sizeof(int)))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:    soap->fclosesocket(soap, (SOAP_SOCKET)sk);
./stdsoap2.c:  if (soap->tcp_keep_intvl && setsockopt((SOAP_SOCKET)sk, IPPROTO_TCP, TCP_KEEPINTVL, (char*)&(soap->tcp_keep_intvl), sizeof(int)))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:    soap->fclosesocket(soap, (SOAP_SOCKET)sk);
./stdsoap2.c:  if (soap->tcp_keep_cnt && setsockopt((SOAP_SOCKET)sk, IPPROTO_TCP, TCP_KEEPCNT, (char*)&(soap->tcp_keep_cnt), sizeof(int)))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:    soap->fclosesocket(soap, (SOAP_SOCKET)sk);
./stdsoap2.c:  if (!(soap->omode & SOAP_IO_UDP) && setsockopt(sk, IPPROTO_TCP, TCP_NODELAY, (char*)&set, sizeof(int)))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:    soap->fclosesocket(soap, sk);
./stdsoap2.c:  if ((soap->omode & SOAP_IO_UDP) && soap->ipv6_multicast_if)
./stdsoap2.c:    in6addr->sin6_scope_id = soap->ipv6_multicast_if;
./stdsoap2.c:  if ((soap->omode & SOAP_IO_UDP))
./stdsoap2.c:  { if (soap->ipv4_multicast_ttl)
./stdsoap2.c:    { unsigned char ttl = soap->ipv4_multicast_ttl;
./stdsoap2.c:      { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:        soap->fclosesocket(soap, sk);
./stdsoap2.c:    if ((soap->omode & SOAP_IO_UDP) && soap->ipv4_multicast_if && !soap->ipv6_multicast_if)
./stdsoap2.c:    { if (setsockopt(sk, IPPROTO_IP, IP_MULTICAST_IF, (char*)soap->ipv4_multicast_if, sizeof(struct in_addr)))
./stdsoap2.c:      { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:        soap->fclosesocket(soap, sk);
./stdsoap2.c:      if (setsockopt(sk, IPPROTO_IP, IP_MULTICAST_IF, (char*)soap->ipv4_multicast_if, sizeof(struct in_addr)))
./stdsoap2.c:      { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:        soap->fclosesocket(soap, sk);
./stdsoap2.c:  soap->peerlen = sizeof(soap->peer.in);
./stdsoap2.c:  memset((void*)&soap->peer.in, 0, sizeof(soap->peer.in));
./stdsoap2.c:  soap->peer.in.sin_family = AF_INET;
./stdsoap2.c:  if (soap->client_port >= 0)
./stdsoap2.c:    addr.sin_port = htons(soap->client_port);
./stdsoap2.c:    { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:      soap->fclosesocket(soap, sk);
./stdsoap2.c:    soap->client_port = -1; /* disable bind before connect, so explicitly need to set client_port before next connect */
./stdsoap2.c:  soap->errmode = 2;
./stdsoap2.c:  if (soap->proxy_host)
./stdsoap2.c:  { if (soap->fresolve(soap, soap->proxy_host, &soap->peer.in.sin_addr))
./stdsoap2.c:      soap->fclosesocket(soap, sk);
./stdsoap2.c:    soap->peer.in.sin_port = htons((short)soap->proxy_port);
./stdsoap2.c:  { if (soap->fresolve(soap, host, &soap->peer.in.sin_addr))
./stdsoap2.c:      soap->fclosesocket(soap, sk);
./stdsoap2.c:    soap->peer.in.sin_port = htons((short)port);
./stdsoap2.c:  soap->errmode = 0;
./stdsoap2.c:  if ((soap->omode & SOAP_IO_UDP))
./stdsoap2.c:  if (soap->client_port >= 0)
./stdsoap2.c:    addr.sin6_port = htons(soap->client_port);
./stdsoap2.c:    { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:      soap->fclosesocket(soap, sk);
./stdsoap2.c:    soap->client_port = -1; /* disable bind before connect, so explicitly need to set client_port before next connect */
./stdsoap2.c:  if ((soap->omode & SOAP_IO_UDP))
./stdsoap2.c:  { if (soap_memcpy((void*)&soap->peer.storage, sizeof(soap->peer.storage), (const void*)res->ai_addr, res->ai_addrlen))
./stdsoap2.c:    { soap->error = SOAP_EOM;
./stdsoap2.c:      soap->fclosesocket(soap, sk);
./stdsoap2.c:    soap->peerlen = res->ai_addrlen;
./stdsoap2.c:  if (soap->connect_timeout)
./stdsoap2.c:    if (connect(sk, &soap->peer.addr, sizeof(soap->peer.in)))
./stdsoap2.c:      { soap->fclosesocket(soap, sk);
./stdsoap2.c:      { soap->fclosesocket(soap, sk);
./stdsoap2.c:      else if (soap->connect_timeout && (err == SOAP_EINPROGRESS || err == SOAP_EAGAIN || err == SOAP_EWOULDBLOCK))
./stdsoap2.c:          r = tcp_select(soap, sk, SOAP_TCP_SELECT_SND, soap->connect_timeout);
./stdsoap2.c:            soap->fclosesocket(soap, sk);
./stdsoap2.c:          r = soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:            soap->fclosesocket(soap, sk);
./stdsoap2.c:        k = (SOAP_SOCKLEN_T)sizeof(soap->errnum);
./stdsoap2.c:        if (!getsockopt(sk, SOL_SOCKET, SO_ERROR, (char*)&soap->errnum, &k) && !soap->errnum)   /* portability note: see SOAP_SOCKLEN_T definition in stdsoap2.h */
./stdsoap2.c:        if (!soap->errnum)
./stdsoap2.c:          soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:        soap->fclosesocket(soap, sk);
./stdsoap2.c:        soap->fclosesocket(soap, sk);
./stdsoap2.c:      { soap->errnum = err;
./stdsoap2.c:        soap->fclosesocket(soap, sk);
./stdsoap2.c:  soap->peerlen = 0; /* IPv6: already connected so use send() */
./stdsoap2.c:  soap->socket = sk;
./stdsoap2.c:  soap->imode &= ~SOAP_ENC_SSL;
./stdsoap2.c:  soap->omode &= ~SOAP_ENC_SSL;
./stdsoap2.c:    if (soap->proxy_host)
./stdsoap2.c:    { soap_mode m = soap->mode; /* preserve settings */
./stdsoap2.c:      soap_mode om = soap->omode; /* make sure we only parse HTTP */
./stdsoap2.c:      size_t n = soap->count; /* save the content length */
./stdsoap2.c:      int status = soap->status; /* save the current status/command */
./stdsoap2.c:      int keep_alive = soap->keep_alive; /* save the KA status */
./stdsoap2.c:      soap->omode &= ~SOAP_ENC; /* mask IO and ENC */
./stdsoap2.c:      soap->omode |= SOAP_IO_BUFFER;
./stdsoap2.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Connecting to %s proxy server %s for destination endpoint %s\n", soap->proxy_http_version, soap->proxy_host, endpoint));
./stdsoap2.c:      if (soap->ntlm_challenge)
./stdsoap2.c:          return soap->error;
./stdsoap2.c:      { soap->fclosesocket(soap, sk);
./stdsoap2.c:      soap->status = SOAP_CONNECT;
./stdsoap2.c:      if (!soap->keep_alive)
./stdsoap2.c:        soap->keep_alive = -1; /* must keep alive */
./stdsoap2.c:      soap->error = soap->fpost(soap, endpoint, host, port, NULL, NULL, 0);
./stdsoap2.c:      if (soap->error
./stdsoap2.c:      { soap->fclosesocket(soap, sk);
./stdsoap2.c:      soap->keep_alive = keep_alive;
./stdsoap2.c:      soap->omode = om;
./stdsoap2.c:      om = soap->imode;
./stdsoap2.c:      soap->imode &= ~SOAP_ENC; /* mask IO and ENC */
./stdsoap2.c:      userid = soap->userid; /* preserve */
./stdsoap2.c:      passwd = soap->passwd; /* preserve */
./stdsoap2.c:      soap->error = soap->fparse(soap);
./stdsoap2.c:      if (soap->error)
./stdsoap2.c:      { soap->fclosesocket(soap, sk);
./stdsoap2.c:      soap->status = status; /* restore */
./stdsoap2.c:      soap->userid = userid; /* restore */
./stdsoap2.c:      soap->passwd = passwd; /* restore */
./stdsoap2.c:      soap->imode = om; /* restore */
./stdsoap2.c:      soap->count = n; /* restore */
./stdsoap2.c:      { soap->fclosesocket(soap, sk);
./stdsoap2.c:        soap_strcpy(soap->endpoint, sizeof(soap->endpoint), endpoint); /* restore */
./stdsoap2.c:      soap->mode = m;
./stdsoap2.c:    soap->ssl_flags |= SOAP_SSL_CLIENT;
./stdsoap2.c:    if (!soap->ctx && (soap->error = soap->fsslauth(soap)) != SOAP_OK)
./stdsoap2.c:      soap->fclosesocket(soap, sk);
./stdsoap2.c:      soap->error = SOAP_SSL_ERROR;
./stdsoap2.c:    if (!soap->ssl)
./stdsoap2.c:    { soap->ssl = SSL_new(soap->ctx);
./stdsoap2.c:      if (!soap->ssl)
./stdsoap2.c:      { soap->fclosesocket(soap, sk);
./stdsoap2.c:        soap->error = SOAP_SSL_ERROR;
./stdsoap2.c:      SSL_clear(soap->ssl);
./stdsoap2.c:    if (soap->session)
./stdsoap2.c:    { if (!strcmp(soap->session_host, host) && soap->session_port == port)
./stdsoap2.c:        SSL_set_session(soap->ssl, soap->session);
./stdsoap2.c:      SSL_SESSION_free(soap->session);
./stdsoap2.c:      soap->session = NULL;
./stdsoap2.c:    if (!(soap->ssl_flags & SOAP_SSLv3) && !SSL_set_tlsext_host_name(soap->ssl, host))
./stdsoap2.c:      soap->fclosesocket(soap, sk);
./stdsoap2.c:    if (!SSL_ctrl(soap->ssl, SSL_CTRL_SET_TLSEXT_HOSTNAME, TLSEXT_NAMETYPE_host_name, (void*)host))
./stdsoap2.c:      soap->fclosesocket(soap, sk);
./stdsoap2.c:    SSL_set_bio(soap->ssl, bio, bio);
./stdsoap2.c:    if (soap->connect_timeout)
./stdsoap2.c:      retries = 10*soap->connect_timeout;
./stdsoap2.c:    { if ((r = SSL_connect(soap->ssl)) <= 0)
./stdsoap2.c:      { int err = SSL_get_error(soap->ssl, r);
./stdsoap2.c:            soap->fclosesocket(soap, sk);
./stdsoap2.c:            soap->fclosesocket(soap, sk);
./stdsoap2.c:          soap->fclosesocket(soap, sk);
./stdsoap2.c:    } while (!SSL_is_init_finished(soap->ssl));
./stdsoap2.c:    if ((soap->ssl_flags & SOAP_SSL_REQUIRE_SERVER_AUTHENTICATION))
./stdsoap2.c:      if ((err = SSL_get_verify_result(soap->ssl)) != X509_V_OK)
./stdsoap2.c:        soap->fclosesocket(soap, sk);
./stdsoap2.c:      if (!(soap->ssl_flags & SOAP_SSL_SKIP_HOST_CHECK))
./stdsoap2.c:        X509 *peer = SSL_get_peer_certificate(soap->ssl);
./stdsoap2.c:          soap->fclosesocket(soap, sk);
./stdsoap2.c:          soap->fclosesocket(soap, sk);
./stdsoap2.c:    soap->ssl_flags |= SOAP_SSL_CLIENT;
./stdsoap2.c:    if (!soap->session && (soap->error = soap->fsslauth(soap)) != SOAP_OK)
./stdsoap2.c:    { soap->fclosesocket(soap, sk);
./stdsoap2.c:    gnutls_transport_set_ptr(soap->session, (gnutls_transport_ptr_t)(long)sk);
./stdsoap2.c:    if (soap->connect_timeout)
./stdsoap2.c:      retries = 10*soap->connect_timeout;
./stdsoap2.c:    while ((r = gnutls_handshake(soap->session)))
./stdsoap2.c:      { if (!gnutls_record_get_direction(soap->session))
./stdsoap2.c:      { soap->errnum = soap_socket_errno(sk);
./stdsoap2.c:      soap->fclosesocket(soap, sk);
./stdsoap2.c:    if ((soap->ssl_flags & SOAP_SSL_REQUIRE_SERVER_AUTHENTICATION))
./stdsoap2.c:      { soap->fclosesocket(soap, sk);
./stdsoap2.c:        soap->error = soap_set_sender_error(soap, "SSL/TLS verify error", err, SOAP_SSL_ERROR);
./stdsoap2.c:    soap->ssl_flags |= SOAP_SSL_CLIENT;
./stdsoap2.c:    if (!soap->ctx && (soap->error = soap->fsslauth(soap)) != SOAP_OK)
./stdsoap2.c:      soap->fclosesocket(soap, sk);
./stdsoap2.c:      soap->error = SOAP_SSL_ERROR;
./stdsoap2.c:    if (soap->connect_timeout)
./stdsoap2.c:      retries = 10*soap->connect_timeout;
./stdsoap2.c:    err = gsk_secure_socket_open(soap->ctx, &soap->ssl);
./stdsoap2.c:      err = gsk_attribute_set_numeric_value(soap->ssl, GSK_FD, sk);
./stdsoap2.c:      err = gsk_attribute_set_buffer(soap->ssl, GSK_KEYRING_LABEL, soap->cafile, 0); /* Certificate label */
./stdsoap2.c:      err = gsk_attribute_set_enum(soap->ssl, GSK_SESSION_TYPE, GSK_CLIENT_SESSION);
./stdsoap2.c:      err = gsk_attribute_set_buffer(soap->ssl, GSK_V3_CIPHER_SPECS_EXPANDED, "0035002F000A", 0);
./stdsoap2.c:      err = gsk_attribute_set_enum(soap->ssl, GSK_V3_CIPHERS, GSK_V3_CIPHERS_CHAR4);
./stdsoap2.c:      err = gsk_attribute_set_callback(soap->ssl, GSK_IO_CALLBACK, &local_io);
./stdsoap2.c:    while ((err = gsk_secure_socket_init(soap->ssl)) != GSK_OK)
./stdsoap2.c:          soap->fclosesocket(soap, sk);
./stdsoap2.c:          soap->fclosesocket(soap, sk);
./stdsoap2.c:        soap->fclosesocket(soap, sk);
./stdsoap2.c:    soap->imode |= SOAP_ENC_SSL;
./stdsoap2.c:    soap->omode |= SOAP_ENC_SSL;
./stdsoap2.c:    soap->fclosesocket(soap, sk);
./stdsoap2.c:    soap->error = SOAP_SSL_ERROR;
./stdsoap2.c:  if (soap->recv_timeout || soap->send_timeout)
./stdsoap2.c:  soap->errnum = 0;
./stdsoap2.c:      if (r < 0 && (soap->errnum = soap_socket_errno(sk)) == SOAP_EINTR && eintr-- > 0)
./stdsoap2.c:      soap->errnum = 0;
./stdsoap2.c:  { soap->error = SOAP_FD_EXCEEDED;
./stdsoap2.c:    if (r < 0 && (soap->errnum = soap_socket_errno(sk)) == SOAP_EINTR && eintr-- > 0)
./stdsoap2.c:    soap->errnum = 0;
./stdsoap2.c:  if (soap->ssl)
./stdsoap2.c:    if (soap->session)
./stdsoap2.c:    { SSL_SESSION_free(soap->session);
./stdsoap2.c:      soap->session = NULL;
./stdsoap2.c:    if (*soap->host)
./stdsoap2.c:    { soap->session = SSL_get1_session(soap->ssl);
./stdsoap2.c:      if (soap->session)
./stdsoap2.c:      { soap_strcpy(soap->session_host, sizeof(soap->session_host), soap->host);
./stdsoap2.c:        soap->session_port = soap->port;
./stdsoap2.c:    r = SSL_shutdown(soap->ssl);
./stdsoap2.c:    { while (SSL_want_read(soap->ssl))
./stdsoap2.c:      { if (SSL_read(soap->ssl, NULL, 0)
./stdsoap2.c:         || soap_socket_errno(soap->socket) != SOAP_EAGAIN)
./stdsoap2.c:        { r = SSL_shutdown(soap->ssl);
./stdsoap2.c:    { if (soap_valid_socket(soap->socket))
./stdsoap2.c:      { if (!soap->fshutdownsocket(soap, soap->socket, SOAP_SHUT_WR))
./stdsoap2.c:          r = tcp_select(soap, soap->socket, SOAP_TCP_SELECT_RCV | SOAP_TCP_SELECT_ERR, 5);
./stdsoap2.c:          { soap->errnum = 0;
./stdsoap2.c:            soap->fclosesocket(soap, soap->socket);
./stdsoap2.c:            soap->socket = SOAP_INVALID_SOCKET;
./stdsoap2.c:            SSL_free(soap->ssl);
./stdsoap2.c:            soap->ssl = NULL;
./stdsoap2.c:          r = SSL_shutdown(soap->ssl);
./stdsoap2.c:    { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Shutdown failed: %d\n", SSL_get_error(soap->ssl, r)));
./stdsoap2.c:      if (soap_valid_socket(soap->socket) && !(soap->omode & SOAP_IO_UDP))
./stdsoap2.c:      { soap->fclosesocket(soap, soap->socket);
./stdsoap2.c:        soap->socket = SOAP_INVALID_SOCKET;
./stdsoap2.c:    SSL_free(soap->ssl);
./stdsoap2.c:    soap->ssl = NULL;
./stdsoap2.c:  if (soap->session)
./stdsoap2.c:  { gnutls_bye(soap->session, GNUTLS_SHUT_RDWR);
./stdsoap2.c:    gnutls_deinit(soap->session);
./stdsoap2.c:    soap->session = NULL;
./stdsoap2.c:  if (soap->ssl)
./stdsoap2.c:  { gsk_secure_socket_shutdown(soap->ssl);
./stdsoap2.c:    gsk_secure_socket_close(&soap->ssl);
./stdsoap2.c:  if (soap_valid_socket(soap->socket) && !(soap->omode & SOAP_IO_UDP))
./stdsoap2.c:  { soap->fshutdownsocket(soap, soap->socket, SOAP_SHUT_RDWR);
./stdsoap2.c:    soap->fclosesocket(soap, soap->socket);
./stdsoap2.c:    soap->socket = SOAP_INVALID_SOCKET;
./stdsoap2.c:  if (soap_valid_socket(soap->master))
./stdsoap2.c:  { soap->fclosesocket(soap, soap->master);
./stdsoap2.c:    soap->master = SOAP_INVALID_SOCKET;
./stdsoap2.c:  soap->socket = SOAP_INVALID_SOCKET;
./stdsoap2.c:  soap->errmode = 1;
./stdsoap2.c:  if ((soap->omode & SOAP_IO_UDP))
./stdsoap2.c:  soap->errmode = 2;
./stdsoap2.c:  if (soap_memcpy((void*)&soap->peer.storage, sizeof(soap->peer.storage), (const void*)addrinfo->ai_addr, addrinfo->ai_addrlen))
./stdsoap2.c:    soap->error = SOAP_EOM;
./stdsoap2.c:  soap->peerlen = addrinfo->ai_addrlen;
./stdsoap2.c:  res.ai_addr = &soap->peer.addr;
./stdsoap2.c:  res.ai_addrlen = soap->peerlen;
./stdsoap2.c:  soap->master = (int)socket(res.ai_family, res.ai_socktype, res.ai_protocol);
./stdsoap2.c:  if ((soap->omode & SOAP_IO_UDP))
./stdsoap2.c:    soap->master = (int)socket(AF_INET, SOCK_DGRAM, 0);
./stdsoap2.c:    soap->master = (int)socket(AF_INET, SOCK_STREAM, 0);
./stdsoap2.c:  soap->errmode = 0;
./stdsoap2.c:  if (!soap_valid_socket(soap->master))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(soap->master);
./stdsoap2.c:  soap->port = port;
./stdsoap2.c:  if ((soap->omode & SOAP_IO_UDP))
./stdsoap2.c:    soap->socket = soap->master;
./stdsoap2.c:  SetHandleInformation((HANDLE)soap->master, HANDLE_FLAG_INHERIT, 0);
./stdsoap2.c:  fcntl(soap->master, F_SETFD, 1);
./stdsoap2.c:  if (soap->bind_flags && setsockopt(soap->master, SOL_SOCKET, soap->bind_flags, (char*)&set, sizeof(int)))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(soap->master);
./stdsoap2.c:  if (((soap->imode | soap->omode) & SOAP_IO_KEEPALIVE) && (!((soap->imode | soap->omode) & SOAP_IO_UDP)) && setsockopt(soap->master, SOL_SOCKET, SO_KEEPALIVE, (char*)&set, sizeof(int)))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(soap->master);
./stdsoap2.c:  if (soap->sndbuf > 0 && setsockopt(soap->master, SOL_SOCKET, SO_SNDBUF, (char*)&soap->sndbuf, sizeof(int)))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(soap->master);
./stdsoap2.c:  if (soap->rcvbuf > 0 && setsockopt(soap->master, SOL_SOCKET, SO_RCVBUF, (char*)&soap->rcvbuf, sizeof(int)))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(soap->master);
./stdsoap2.c:  if (!(soap->omode & SOAP_IO_UDP) && setsockopt(soap->master, IPPROTO_TCP, TCP_NODELAY, (char*)&set, sizeof(int)))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(soap->master);
./stdsoap2.c:  if (!(soap->omode & SOAP_IO_UDP) && setsockopt(soap->master, IPPROTO_TCP, TCP_FASTOPEN, (char*)&set, sizeof(int)))
./stdsoap2.c:  if (res.ai_family == AF_INET6 && setsockopt(soap->master, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&set, sizeof(int)))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(soap->master);
./stdsoap2.c:  if (res.ai_family == AF_INET6 && setsockopt(soap->master, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&unset, sizeof(int)))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(soap->master);
./stdsoap2.c:  soap->errmode = 0;
./stdsoap2.c:  if (bind(soap->master, res.ai_addr, (int)res.ai_addrlen))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(soap->master);
./stdsoap2.c:  soap->peerlen = sizeof(soap->peer.in);
./stdsoap2.c:  memset((void*)&soap->peer.in, 0, sizeof(soap->peer.in));
./stdsoap2.c:  soap->peer.in.sin_family = AF_INET;
./stdsoap2.c:  soap->errmode = 2;
./stdsoap2.c:  { if (soap->fresolve(soap, host, &soap->peer.in.sin_addr))
./stdsoap2.c:    soap->peer.in.sin_addr.s_addr = htonl(INADDR_ANY);
./stdsoap2.c:  soap->peer.in.sin_port = htons((short)port);
./stdsoap2.c:  soap->errmode = 0;
./stdsoap2.c:  if (bind(soap->master, &soap->peer.addr, (int)soap->peerlen))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(soap->master);
./stdsoap2.c:  if (!(soap->omode & SOAP_IO_UDP) && listen(soap->master, backlog))
./stdsoap2.c:  { soap->errnum = soap_socket_errno(soap->master);
./stdsoap2.c:  return soap->master;
./stdsoap2.c:  if (soap_valid_socket(soap->socket))
./stdsoap2.c:  { r = tcp_select(soap, soap->socket, SOAP_TCP_SELECT_ALL, 0);
./stdsoap2.c:  else if (soap_valid_socket(soap->master))
./stdsoap2.c:    r = tcp_select(soap, soap->master, SOAP_TCP_SELECT_SND, 0);
./stdsoap2.c:    if (soap->imode & SOAP_ENC_SSL)
./stdsoap2.c:    { if (soap_valid_socket(soap->socket)
./stdsoap2.c:        || SSL_peek(soap->ssl, soap->tmpbuf, 1) > 0))
./stdsoap2.c:      if (soap_valid_socket(soap->socket)
./stdsoap2.c:        || recv(soap->socket, (char*)&t, 1, MSG_PEEK) > 0))
./stdsoap2.c:  { if ((soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) && soap_socket_errno(soap->master) != SOAP_EINTR)
./stdsoap2.c:      return soap->error = SOAP_TCP_ERROR;
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Polling: other end down on socket=%d select=%d\n", (int)soap->socket, r));
./stdsoap2.c:{ int n = (int)sizeof(soap->peer);
./stdsoap2.c:  soap->error = SOAP_OK;
./stdsoap2.c:  memset((void*)&soap->peer, 0, sizeof(soap->peer));
./stdsoap2.c:  soap->socket = SOAP_INVALID_SOCKET;
./stdsoap2.c:  soap->errmode = 0;
./stdsoap2.c:  soap->keep_alive = 0;
./stdsoap2.c:  if (!soap_valid_socket(soap->master))
./stdsoap2.c:  { soap->errnum = 0;
./stdsoap2.c:  if ((soap->omode & SOAP_IO_UDP))
./stdsoap2.c:    return soap->socket = soap->master;
./stdsoap2.c:  { if (soap->accept_timeout)
./stdsoap2.c:        r = tcp_select(soap, soap->master, SOAP_TCP_SELECT_ALL, soap->accept_timeout);
./stdsoap2.c:        { r = soap->errnum;
./stdsoap2.c:    n = (int)sizeof(soap->peer);
./stdsoap2.c:    soap->socket = soap->faccept(soap, soap->master, &soap->peer.addr, &n);
./stdsoap2.c:    soap->peerlen = (size_t)n;
./stdsoap2.c:    if (soap_valid_socket(soap->socket))
./stdsoap2.c:      char *s = soap->host;
./stdsoap2.c:      getnameinfo(&soap->peer.addr, n, soap->host, sizeof(soap->host), port, sizeof(port), NI_NUMERICHOST | NI_NUMERICSERV);
./stdsoap2.c:      soap->ip = 0;
./stdsoap2.c:      { soap->ip = (soap->ip << 8) + (unsigned int)soap_strtoul(s, &s, 10);
./stdsoap2.c:      soap->port = soap_strtol(port, NULL, 10);
./stdsoap2.c:      soap->ip = ntohl(soap->peer.in.sin_addr.s_addr);
./stdsoap2.c:      (SOAP_SNPRINTF(soap->host, sizeof(soap->host), 80), "%u.%u.%u.%u", (int)(soap->ip>>24)&0xFF, (int)(soap->ip>>16)&0xFF, (int)(soap->ip>>8)&0xFF, (int)soap->ip&0xFF);
./stdsoap2.c:      soap->port = (int)ntohs(soap->peer.in.sin_port); /* does not return port number on some systems */
./stdsoap2.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Accept socket=%d at port=%d from IP='%s'\n", (int)soap->socket, soap->port, soap->host));
./stdsoap2.c:      if ((soap->accept_flags & SO_LINGER))
./stdsoap2.c:        linger.l_linger = soap->linger_time;
./stdsoap2.c:        if (setsockopt(soap->socket, SOL_SOCKET, SO_LINGER, (char*)&linger, sizeof(struct linger)))
./stdsoap2.c:        { soap->errnum = soap_socket_errno(soap->socket);
./stdsoap2.c:      if ((soap->accept_flags & ~SO_LINGER) && setsockopt(soap->socket, SOL_SOCKET, soap->accept_flags & ~SO_LINGER, (char*)&set, sizeof(int)))
./stdsoap2.c:      { soap->errnum = soap_socket_errno(soap->socket);
./stdsoap2.c:      if (((soap->imode | soap->omode) & SOAP_IO_KEEPALIVE) && setsockopt(soap->socket, SOL_SOCKET, SO_KEEPALIVE, (char*)&set, sizeof(int)))
./stdsoap2.c:      { soap->errnum = soap_socket_errno(soap->socket);
./stdsoap2.c:      if (soap->sndbuf > 0 && setsockopt(soap->socket, SOL_SOCKET, SO_SNDBUF, (char*)&soap->sndbuf, sizeof(int)))
./stdsoap2.c:      { soap->errnum = soap_socket_errno(soap->socket);
./stdsoap2.c:      if (soap->rcvbuf > 0 && setsockopt(soap->socket, SOL_SOCKET, SO_RCVBUF, (char*)&soap->rcvbuf, sizeof(int)))
./stdsoap2.c:      { soap->errnum = soap_socket_errno(soap->socket);
./stdsoap2.c:      if (setsockopt(soap->socket, IPPROTO_TCP, TCP_NODELAY, (char*)&set, sizeof(int)))
./stdsoap2.c:      { soap->errnum = soap_socket_errno(soap->socket);
./stdsoap2.c:      soap->keep_alive = -(((soap->imode | soap->omode) & SOAP_IO_KEEPALIVE) != 0);
./stdsoap2.c:      if (soap->send_timeout || soap->recv_timeout)
./stdsoap2.c:        SOAP_SOCKNONBLOCK(soap->socket)
./stdsoap2.c:        SOAP_SOCKBLOCK(soap->socket)
./stdsoap2.c:      return soap->socket;
./stdsoap2.c:    err = soap_socket_errno(soap->socket);
./stdsoap2.c:    { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Accept failed from %s\n", soap->host));
./stdsoap2.c:      soap->errnum = err;
./stdsoap2.c:{ int status = soap->error;
./stdsoap2.c:  { soap->mime.first = NULL;
./stdsoap2.c:    soap->mime.last = NULL;
./stdsoap2.c:    soap->dime.first = NULL;
./stdsoap2.c:    soap->dime.last = NULL;
./stdsoap2.c:  if (soap->fdisconnect && (soap->error = soap->fdisconnect(soap)) != SOAP_OK)
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  if (status == SOAP_EOF || status == SOAP_TCP_ERROR || status == SOAP_SSL_ERROR || !soap->keep_alive)
./stdsoap2.c:  { if (soap->fclose && (soap->error = soap->fclose(soap)) != SOAP_OK)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    soap->keep_alive = 0;
./stdsoap2.c:  if (!(soap->mode & SOAP_MIME_POSTCHECK))
./stdsoap2.c:  { if (soap->zlib_state == SOAP_ZLIB_DEFLATE)
./stdsoap2.c:      deflateEnd(soap->d_stream);
./stdsoap2.c:    else if (soap->zlib_state == SOAP_ZLIB_INFLATE)
./stdsoap2.c:      inflateEnd(soap->d_stream);
./stdsoap2.c:    soap->zlib_state = SOAP_ZLIB_NONE;
./stdsoap2.c:  return soap->error = status;
./stdsoap2.c:{ soap->keep_alive = 0;
./stdsoap2.c:  if (soap_valid_socket(soap->socket))
./stdsoap2.c:    return soap_closesocket(soap->socket);
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Done with context%s\n", soap->state == SOAP_COPY ? " copy" : ""));
./stdsoap2.c:  while (soap->clist)
./stdsoap2.c:  { struct soap_clist *p = soap->clist->next;
./stdsoap2.c:    SOAP_FREE(soap, soap->clist);
./stdsoap2.c:    soap->clist = p;
./stdsoap2.c:  if (soap->state == SOAP_INIT)
./stdsoap2.c:    soap->omode &= ~SOAP_IO_UDP; /* to force close the socket */
./stdsoap2.c:  soap->keep_alive = 0; /* to force close the socket */
./stdsoap2.c:  if (soap->master == soap->socket) /* do not close twice */
./stdsoap2.c:    soap->master = SOAP_INVALID_SOCKET;
./stdsoap2.c:  while (soap->plugins)
./stdsoap2.c:  { struct soap_plugin *p = soap->plugins->next;
./stdsoap2.c:    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Removing plugin '%s'\n", soap->plugins->id));
./stdsoap2.c:    if (soap->plugins->fcopy || soap->state == SOAP_INIT)
./stdsoap2.c:      soap->plugins->fdelete(soap, soap->plugins);
./stdsoap2.c:    SOAP_FREE(soap, soap->plugins);
./stdsoap2.c:    soap->plugins = p;
./stdsoap2.c:  soap->fplugin = fplugin;
./stdsoap2.c:  soap->fmalloc = NULL;
./stdsoap2.c:  soap->fpost = http_post;
./stdsoap2.c:  soap->fget = http_get;
./stdsoap2.c:  soap->fput = http_405;
./stdsoap2.c:  soap->fdel = http_405;
./stdsoap2.c:  soap->fopt = http_200;
./stdsoap2.c:  soap->fhead = http_200;
./stdsoap2.c:  soap->fform = NULL;
./stdsoap2.c:  soap->fposthdr = http_post_header;
./stdsoap2.c:  soap->fresponse = http_response;
./stdsoap2.c:  soap->fparse = http_parse;
./stdsoap2.c:  soap->fparsehdr = http_parse_header;
./stdsoap2.c:  soap->fheader = NULL;
./stdsoap2.c:  soap->fresolve = tcp_gethost;
./stdsoap2.c:  soap->fresolve = NULL;
./stdsoap2.c:  soap->faccept = tcp_accept;
./stdsoap2.c:  soap->fopen = tcp_connect;
./stdsoap2.c:  soap->fclose = tcp_disconnect;
./stdsoap2.c:  soap->fclosesocket = tcp_closesocket;
./stdsoap2.c:  soap->fshutdownsocket = tcp_shutdownsocket;
./stdsoap2.c:  soap->fsend = fsend;
./stdsoap2.c:  soap->frecv = frecv;
./stdsoap2.c:  soap->fpoll = soap_poll;
./stdsoap2.c:  soap->fopen = NULL;
./stdsoap2.c:  soap->fclose = NULL;
./stdsoap2.c:  soap->fpoll = NULL;
./stdsoap2.c:  soap->fsvalidate = NULL;
./stdsoap2.c:  soap->fwvalidate = NULL;
./stdsoap2.c:  soap->feltbegin = NULL;
./stdsoap2.c:  soap->feltendin = NULL;
./stdsoap2.c:  soap->feltbegout = NULL;
./stdsoap2.c:  soap->feltendout = NULL;
./stdsoap2.c:  soap->fprepareinitsend = NULL;
./stdsoap2.c:  soap->fprepareinitrecv = NULL;
./stdsoap2.c:  soap->fpreparesend = NULL;
./stdsoap2.c:  soap->fpreparerecv = NULL;
./stdsoap2.c:  soap->fpreparefinalsend = NULL;
./stdsoap2.c:  soap->fpreparefinalrecv = NULL;
./stdsoap2.c:  soap->ffiltersend = NULL;
./stdsoap2.c:  soap->ffilterrecv = NULL;
./stdsoap2.c:  soap->fseterror = NULL;
./stdsoap2.c:  soap->fignore = NULL;
./stdsoap2.c:  soap->fserveloop = NULL;
./stdsoap2.c:  if (soap->session)
./stdsoap2.c:  { SSL_SESSION_free(soap->session);
./stdsoap2.c:    soap->session = NULL;
./stdsoap2.c:  if (soap->state == SOAP_INIT)
./stdsoap2.c:  { if (soap_valid_socket(soap->master))
./stdsoap2.c:    { soap->fclosesocket(soap, soap->master);
./stdsoap2.c:      soap->master = SOAP_INVALID_SOCKET;
./stdsoap2.c:  if (soap->ssl)
./stdsoap2.c:  { SSL_free(soap->ssl);
./stdsoap2.c:    soap->ssl = NULL;
./stdsoap2.c:  if (soap->state == SOAP_INIT)
./stdsoap2.c:  { if (soap->ctx)
./stdsoap2.c:    { SSL_CTX_free(soap->ctx);
./stdsoap2.c:      soap->ctx = NULL;
./stdsoap2.c:  if (soap->state == SOAP_INIT)
./stdsoap2.c:  { if (soap->xcred)
./stdsoap2.c:    { gnutls_certificate_free_credentials(soap->xcred);
./stdsoap2.c:      soap->xcred = NULL;
./stdsoap2.c:    if (soap->acred)
./stdsoap2.c:    { gnutls_anon_free_client_credentials(soap->acred);
./stdsoap2.c:      soap->acred = NULL;
./stdsoap2.c:    if (soap->cache)
./stdsoap2.c:    { gnutls_priority_deinit(soap->cache);
./stdsoap2.c:      soap->cache = NULL;
./stdsoap2.c:    if (soap->dh_params)
./stdsoap2.c:    { gnutls_dh_params_deinit(soap->dh_params);
./stdsoap2.c:      soap->dh_params = NULL;
./stdsoap2.c:    if (soap->rsa_params)
./stdsoap2.c:    { gnutls_rsa_params_deinit(soap->rsa_params);
./stdsoap2.c:      soap->rsa_params = NULL;
./stdsoap2.c:  if (soap->session)
./stdsoap2.c:  { gnutls_deinit(soap->session);
./stdsoap2.c:    soap->session = NULL;
./stdsoap2.c:  if (soap->ssl)
./stdsoap2.c:    gsk_secure_socket_close(&soap->ssl);
./stdsoap2.c:  if (soap->state == SOAP_INIT)
./stdsoap2.c:    if (soap->ctx)
./stdsoap2.c:      gsk_environment_close(&soap->ctx);
./stdsoap2.c:  if (soap->d_stream)
./stdsoap2.c:  { SOAP_FREE(soap, soap->d_stream);
./stdsoap2.c:    soap->d_stream = NULL;
./stdsoap2.c:  if (soap->z_buf)
./stdsoap2.c:  { SOAP_FREE(soap, soap->z_buf);
./stdsoap2.c:    soap->z_buf = NULL;
./stdsoap2.c:  { if (soap->logfile[i])
./stdsoap2.c:    { SOAP_FREE(soap, soap->logfile[i]);
./stdsoap2.c:      soap->logfile[i] = NULL;
./stdsoap2.c:  soap->state = SOAP_NONE;
./stdsoap2.c:  *soap->endpoint = '\0';
./stdsoap2.c:  if (!soap->ntlm_challenge)
./stdsoap2.c:  { soap->userid = NULL;
./stdsoap2.c:    soap->passwd = NULL;
./stdsoap2.c:    soap->authrealm = NULL;
./stdsoap2.c:  soap->ntlm_challenge = NULL;
./stdsoap2.c:  soap->proxy_from = NULL;
./stdsoap2.c:  soap->cors_origin = NULL;
./stdsoap2.c:  soap->cors_method = NULL;
./stdsoap2.c:  soap->cors_header = NULL;
./stdsoap2.c:  { soap->length = 0;
./stdsoap2.c:    soap->http_content = NULL;
./stdsoap2.c:    soap->action = NULL;
./stdsoap2.c:    soap->status = 0;
./stdsoap2.c:    soap->body = 1;
./stdsoap2.c:    if (soap_getline(soap, soap->msgbuf, sizeof(soap->msgbuf)))
./stdsoap2.c:    { if (soap->error == SOAP_EOF)
./stdsoap2.c:      return soap->error = 414;
./stdsoap2.c:    s = strchr(soap->msgbuf, ' ');
./stdsoap2.c:    { soap->status = (unsigned short)soap_strtoul(s, &s, 10);
./stdsoap2.c:        soap->status = 0;
./stdsoap2.c:      soap->status = 0;
./stdsoap2.c:    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "HTTP status: %s\n", soap->msgbuf));
./stdsoap2.c:      { if (soap->error == SOAP_EOF)
./stdsoap2.c:        { soap->error = SOAP_OK;
./stdsoap2.c:        return soap->error;
./stdsoap2.c:        soap->error = soap->fparsehdr(soap, header, s);
./stdsoap2.c:        if (soap->error)
./stdsoap2.c:        { if (soap->error < SOAP_STOP)
./stdsoap2.c:            return soap->error;
./stdsoap2.c:          status = soap->error;
./stdsoap2.c:          soap->error = SOAP_OK;
./stdsoap2.c:  } while (soap->status == 100);
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Finished HTTP header parsing, status = %d\n", soap->status));
./stdsoap2.c:  s = strstr(soap->msgbuf, "HTTP/");
./stdsoap2.c:  { soap->keep_alive = 0;
./stdsoap2.c:    if (soap->status == 0 && (soap->omode & SOAP_IO) == SOAP_IO_CHUNK) /* soap->status == 0 for HTTP request */
./stdsoap2.c:      soap->omode = (soap->omode & ~SOAP_IO) | SOAP_IO_STORE; /* HTTP 1.0 does not support chunked transfers */
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Keep alive connection = %d\n", soap->keep_alive));
./stdsoap2.c:  if (soap->status == 0)
./stdsoap2.c:    { if (!strncmp(soap->msgbuf, "POST ", l = 5))
./stdsoap2.c:      else if (!strncmp(soap->msgbuf, "PUT ", l = 4))
./stdsoap2.c:      else if (!strncmp(soap->msgbuf, "GET ", l = 4))
./stdsoap2.c:      else if (!strncmp(soap->msgbuf, "DELETE ", l = 7))
./stdsoap2.c:      else if (!strncmp(soap->msgbuf, "OPTIONS ", l = 8))
./stdsoap2.c:      else if (!strncmp(soap->msgbuf, "HEAD ", l = 5))
./stdsoap2.c:      while (soap_blank(soap->msgbuf[l]))
./stdsoap2.c:      m = strlen(soap->endpoint);
./stdsoap2.c:      n = m + (s - soap->msgbuf) - l - 1;
./stdsoap2.c:      if (n >= sizeof(soap->endpoint))
./stdsoap2.c:        n = sizeof(soap->endpoint) - 1;
./stdsoap2.c:      if (k >= sizeof(soap->path))
./stdsoap2.c:        k = sizeof(soap->path) - 1;
./stdsoap2.c:      while (k > 0 && soap_blank(soap->msgbuf[l + k - 1]))
./stdsoap2.c:      if (soap_strncpy(soap->path, sizeof(soap->path), soap->msgbuf + l, k))
./stdsoap2.c:        return soap->error = 414;
./stdsoap2.c:      if (*soap->path && *soap->path != '/')
./stdsoap2.c:        err = soap_strncpy(soap->endpoint, sizeof(soap->endpoint), soap->path, k);
./stdsoap2.c:        err = soap_strncat(soap->endpoint, sizeof(soap->endpoint), soap->path, k);
./stdsoap2.c:        return soap->error = 414;
./stdsoap2.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Target endpoint='%s' path='%s'\n", soap->endpoint, soap->path));
./stdsoap2.c:      { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "HTTP %s handler\n", soap->msgbuf));
./stdsoap2.c:        { case  2: soap->error = soap->fput(soap); break;
./stdsoap2.c:          case  3: soap->error = soap->fget(soap); break;
./stdsoap2.c:          case  4: soap->error = soap->fdel(soap); break;
./stdsoap2.c:          case  5: soap->error = soap->fopt(soap); break;
./stdsoap2.c:          case  6: soap->error = soap->fhead(soap); break;
./stdsoap2.c:          default: soap->error = 405; break;
./stdsoap2.c:        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "HTTP handler return = %d\n", soap->error));
./stdsoap2.c:        if (soap->error == SOAP_OK)
./stdsoap2.c:          soap->error = SOAP_STOP; /* prevents further processing */
./stdsoap2.c:        return soap->error;
./stdsoap2.c:        return soap->error = status;
./stdsoap2.c:      return soap->error = status;
./stdsoap2.c:      return soap->error = 405;
./stdsoap2.c:  if (soap->length > 0 || (soap->http_content && (!soap->keep_alive || soap->recv_timeout)) || (soap->imode & SOAP_IO) == SOAP_IO_CHUNK)
./stdsoap2.c:  if (soap->body)
./stdsoap2.c:  { if ((soap->status >= 200 && soap->status <= 299) /* OK, Accepted, etc */
./stdsoap2.c:     || soap->status == 400                          /* Bad Request */
./stdsoap2.c:     || soap->status == 500)                         /* Internal Server Error */
./stdsoap2.c:      return soap->error = SOAP_OK;
./stdsoap2.c:    soap->keep_alive = 0;
./stdsoap2.c:      return soap_set_receiver_error(soap, soap->msgbuf, s, soap->status);
./stdsoap2.c:  else if (soap->status >= 200 && soap->status <= 299)
./stdsoap2.c:    return soap->error = soap->status;
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "HTTP error %d: %s\n", soap->status, soap->msgbuf));
./stdsoap2.c:  return soap_set_receiver_error(soap, "HTTP Error", soap->msgbuf, soap->status);
./stdsoap2.c:    if (soap->imode & SOAP_ENC_SSL)
./stdsoap2.c:      soap_strcpy(soap->endpoint, sizeof(soap->endpoint), "https://");
./stdsoap2.c:      soap_strcpy(soap->endpoint, sizeof(soap->endpoint), "http://");
./stdsoap2.c:    if (soap_strncat(soap->endpoint, sizeof(soap->endpoint), val, sizeof(soap->endpoint) - 9))
./stdsoap2.c:      return soap->error = SOAP_HDR;
./stdsoap2.c:    soap->http_content = soap_strdup(soap, val);
./stdsoap2.c:      soap->imode |= SOAP_ENC_DIME;
./stdsoap2.c:    { soap->mime.boundary = soap_strdup(soap, soap_get_header_attribute(soap, val, "boundary"));
./stdsoap2.c:      soap->mime.start = soap_strdup(soap, soap_get_header_attribute(soap, val, "start"));
./stdsoap2.c:      soap->imode |= SOAP_ENC_MIME;
./stdsoap2.c:      { soap->action = soap_strdup(soap, action + 1);
./stdsoap2.c:        if (soap->action && *soap->action)
./stdsoap2.c:          soap->action[strlen(soap->action) - 1] = '\0';
./stdsoap2.c:        soap->action = soap_strdup(soap, action);
./stdsoap2.c:  { soap->length = soap_strtoul(val, NULL, 10);
./stdsoap2.c:    if (!soap->length)
./stdsoap2.c:      soap->body = 0;
./stdsoap2.c:      soap->zlib_in = SOAP_ZLIB_DEFLATE;
./stdsoap2.c:      soap->zlib_in = SOAP_ZLIB_GZIP;
./stdsoap2.c:      soap->zlib_out = SOAP_ZLIB_GZIP;
./stdsoap2.c:      soap->zlib_out = SOAP_ZLIB_DEFLATE;
./stdsoap2.c:      soap->zlib_out = SOAP_ZLIB_NONE;
./stdsoap2.c:  { soap->imode &= ~SOAP_IO;
./stdsoap2.c:      soap->imode |= SOAP_IO_CHUNK;
./stdsoap2.c:      soap->keep_alive = 0;
./stdsoap2.c:      soap->ntlm_challenge = soap_strdup(soap, val + 4);
./stdsoap2.c:      soap_base642s(soap, val + 6, soap->tmpbuf, sizeof(soap->tmpbuf) - 1, &n);
./stdsoap2.c:      soap->tmpbuf[n] = '\0';
./stdsoap2.c:      s = strchr(soap->tmpbuf, ':');
./stdsoap2.c:        soap->userid = soap_strdup(soap, soap->tmpbuf);
./stdsoap2.c:        soap->passwd = soap_strdup(soap, s + 1);
./stdsoap2.c:      soap->ntlm_challenge = soap_strdup(soap, val + 4);
./stdsoap2.c:      soap->authrealm = soap_strdup(soap, soap_get_header_attribute(soap, val + 6, "realm"));
./stdsoap2.c:    { if ((soap->error = soap->fposthdr(soap, "HTTP/1.1 100 Continue", NULL)) != SOAP_OK
./stdsoap2.c:       || (soap->error = soap->fposthdr(soap, NULL, NULL)) != SOAP_OK)
./stdsoap2.c:        return soap->error;
./stdsoap2.c:    { soap->action = soap_strdup(soap, val + 1);
./stdsoap2.c:      if (*soap->action)
./stdsoap2.c:        soap->action[strlen(soap->action) - 1] = '\0';
./stdsoap2.c:      soap->action = soap_strdup(soap, val);
./stdsoap2.c:  { soap_strcpy(soap->endpoint, sizeof(soap->endpoint), val);
./stdsoap2.c:  { soap->proxy_from = soap_strdup(soap, val);
./stdsoap2.c:  { soap->origin = soap_strdup(soap, val);
./stdsoap2.c:    soap->cors_origin = soap->cors_allow;
./stdsoap2.c:  { soap->cors_method = soap_strdup(soap, val);
./stdsoap2.c:  { soap->cors_header = soap_strdup(soap, val);
./stdsoap2.c:      s = soap_decode_key(soap->tmpbuf, sizeof(soap->tmpbuf), s);
./stdsoap2.c:      flag = soap_tag_cmp(soap->tmpbuf, key);
./stdsoap2.c:      s = soap_decode_val(soap->tmpbuf, sizeof(soap->tmpbuf), s);
./stdsoap2.c:        return soap->tmpbuf;
./stdsoap2.c:{ if (soap->origin && soap->cors_method) /* CORS Origin and Access-Control-Request-Method headers */
./stdsoap2.c:  { soap->cors_origin = soap->cors_allow; /* modify this code or hook your own soap->fopt() callback with logic */
./stdsoap2.c:    soap->cors_methods = "GET, POST, HEAD, OPTIONS";
./stdsoap2.c:    soap->cors_headers = soap->cors_header;
./stdsoap2.c:  switch (soap->status)
./stdsoap2.c:  /* set l to prevent overruns ('host' and 'soap->host' are substrings of 'endpoint') */
./stdsoap2.c:  l = strlen(endpoint) + strlen(soap->http_version) + 80;
./stdsoap2.c:  if (l > sizeof(soap->tmpbuf))
./stdsoap2.c:    return soap->error = SOAP_EOM;
./stdsoap2.c:  if (soap->status == SOAP_CONNECT)
./stdsoap2.c:    (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), l), "%s %s:%d HTTP/%s", s, soap->host, soap->port, soap->http_version);
./stdsoap2.c:  else if (soap->proxy_host && endpoint)
./stdsoap2.c:    (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), l), "%s %s HTTP/%s", s, endpoint, soap->http_version);
./stdsoap2.c:    (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), l), "%s /%s HTTP/%s", s, (*path == '/' ? path + 1 : path), soap->http_version);
./stdsoap2.c:  err = soap->fposthdr(soap, soap->tmpbuf, NULL);
./stdsoap2.c:  if ((soap->ssl && port != 443) || (!soap->ssl && port != 80))
./stdsoap2.c:      (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), l), "[%s]:%d", host, port); /* RFC 2732 */
./stdsoap2.c:      (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), l), "%s:%d", host, port);
./stdsoap2.c:      (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), l), "[%s]", host); /* RFC 2732 */
./stdsoap2.c:      soap_strcpy(soap->tmpbuf, sizeof(soap->tmpbuf), host);
./stdsoap2.c:  err = soap->fposthdr(soap, "Host", soap->tmpbuf);
./stdsoap2.c:  err = soap->fposthdr(soap, "User-Agent", "gSOAP/2.8");
./stdsoap2.c:  if (soap->origin)
./stdsoap2.c:  { err = soap->fposthdr(soap, "Origin", soap->origin);
./stdsoap2.c:    if (soap->status == SOAP_OPTIONS)
./stdsoap2.c:      err = soap->fposthdr(soap, "Access-Control-Request-Method", soap->cors_method ? soap->cors_method : "POST");
./stdsoap2.c:      if (soap->cors_header)
./stdsoap2.c:      { err = soap->fposthdr(soap, "Access-Control-Request-Headers", soap->cors_header);
./stdsoap2.c:  if (soap->imode & SOAP_ENC_MTOM)
./stdsoap2.c:  { err = soap->fposthdr(soap, "Accept", "multipart/related,application/xop+xml,*/*;q=0.8");
./stdsoap2.c:  err = soap->fposthdr(soap, "Accept-Encoding", "gzip,deflate");
./stdsoap2.c:  err = soap->fposthdr(soap, "Accept-Encoding", "deflate");
./stdsoap2.c:  if (soap->ntlm_challenge)
./stdsoap2.c:  { l = strlen(soap->ntlm_challenge);
./stdsoap2.c:    { (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), l + 5), "NTLM %s", soap->ntlm_challenge);
./stdsoap2.c:      if (soap->proxy_host)
./stdsoap2.c:      { err = soap->fposthdr(soap, "Proxy-Authorization", soap->tmpbuf);
./stdsoap2.c:      { err = soap->fposthdr(soap, "Authorization", soap->tmpbuf);
./stdsoap2.c:  if (soap->userid && soap->passwd)
./stdsoap2.c:  { soap_strcpy(soap->tmpbuf, sizeof(soap->tmpbuf), "Basic ");
./stdsoap2.c:    (SOAP_SNPRINTF(soap->tmpbuf + 262, sizeof(soap->tmpbuf) - 262, strlen(soap->userid) + strlen(soap->passwd) + 1), "%s:%s", soap->userid, soap->passwd);
./stdsoap2.c:    soap_s2base64(soap, (const unsigned char*)(soap->tmpbuf + 262), soap->tmpbuf + 6, (int)strlen(soap->tmpbuf + 262));
./stdsoap2.c:    err = soap->fposthdr(soap, "Authorization", soap->tmpbuf);
./stdsoap2.c:  if (soap->proxy_userid && soap->proxy_passwd)
./stdsoap2.c:  { soap_strcpy(soap->tmpbuf, sizeof(soap->tmpbuf), "Basic ");
./stdsoap2.c:    (SOAP_SNPRINTF(soap->tmpbuf + 262, sizeof(soap->tmpbuf) - 262, strlen(soap->proxy_userid) + strlen(soap->proxy_passwd) + 1), "%s:%s", soap->proxy_userid, soap->proxy_passwd);
./stdsoap2.c:    soap_s2base64(soap, (const unsigned char*)(soap->tmpbuf + 262), soap->tmpbuf + 6, (int)strlen(soap->tmpbuf + 262));
./stdsoap2.c:    err = soap->fposthdr(soap, "Proxy-Authorization", soap->tmpbuf);
./stdsoap2.c:  if (soap_putcookies(soap, host, path, soap->ssl != NULL))
./stdsoap2.c:    return soap->error;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  if (action && soap->status != SOAP_GET && soap->status != SOAP_DEL)
./stdsoap2.c:  { (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), strlen(action) + 2), "\"%s\"", action);
./stdsoap2.c:    err = soap->fposthdr(soap, "SOAPAction", soap->tmpbuf);
./stdsoap2.c:  return soap->fposthdr(soap, NULL, NULL);
./stdsoap2.c:      return soap->error;
./stdsoap2.c:      return soap->error;
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  if (soap->rpmreqid)
./stdsoap2.c:    httpOutputEnable(soap->rpmreqid);
./stdsoap2.c:  if (soap->rpmreqid || soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* RPM behaves as if standalone */
./stdsoap2.c:  if (soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* standalone application (socket) or CGI (stdin/out)? */
./stdsoap2.c:    (SOAP_SNPRINTF(http, sizeof(http), strlen(soap->http_version) + 5), "HTTP/%s", soap->http_version);
./stdsoap2.c:  { if (count || ((soap->omode & SOAP_IO) == SOAP_IO_CHUNK))
./stdsoap2.c:    else if (soap->version == 2 && (!s || !strcmp(s, "SOAP-ENV:Sender")))
./stdsoap2.c:  (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), sizeof(http) + 22 + strlen(line)), "%s %d %s", http, code, line);
./stdsoap2.c:  err = soap->fposthdr(soap, soap->tmpbuf, NULL);
./stdsoap2.c:  { (SOAP_SNPRINTF_SAFE(soap->tmpbuf, sizeof(soap->tmpbuf)), "Basic realm=\"%s\"", (soap->authrealm && strlen(soap->authrealm) + 14 < sizeof(soap->tmpbuf)) ? soap->authrealm : "gSOAP Web Service");
./stdsoap2.c:    err = soap->fposthdr(soap, "WWW-Authenticate", soap->tmpbuf);
./stdsoap2.c:  { err = soap->fposthdr(soap, "Location", soap->endpoint);
./stdsoap2.c:  err = soap->fposthdr(soap, "Server", "gSOAP/2.8");
./stdsoap2.c:  if (soap->cors_origin)
./stdsoap2.c:  { err = soap->fposthdr(soap, "Access-Control-Allow-Origin", soap->cors_origin);
./stdsoap2.c:    err = soap->fposthdr(soap, "Access-Control-Allow-Credentials", "true");
./stdsoap2.c:    if (soap->cors_methods)
./stdsoap2.c:    { err = soap->fposthdr(soap, "Access-Control-Allow-Methods", soap->cors_methods);
./stdsoap2.c:      if (soap->cors_headers)
./stdsoap2.c:      { err = soap->fposthdr(soap, "Access-Control-Allow-Headers", soap->cors_headers);
./stdsoap2.c:  soap->cors_origin = NULL;
./stdsoap2.c:  soap->cors_methods = NULL;
./stdsoap2.c:  soap->cors_headers = NULL;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  return soap->fposthdr(soap, NULL, NULL);
./stdsoap2.c:  if (!(soap->omode & (SOAP_ENC_PLAIN | SOAP_IO_STORE /* this tests for chunking too */))
./stdsoap2.c:    soap->omode = (soap->omode & ~SOAP_IO) | SOAP_IO_STORE;
./stdsoap2.c:  soap->status = status;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  if ((soap->mode & SOAP_IO) != SOAP_IO_STORE && !(soap->mode & SOAP_ENC_PLAIN))
./stdsoap2.c:  { int n = soap->mode;
./stdsoap2.c:    soap->mode &= ~(SOAP_IO | SOAP_ENC_ZLIB);
./stdsoap2.c:      soap->mode |= SOAP_IO_BUFFER;
./stdsoap2.c:    soap->error = soap->fresponse(soap, status, count);
./stdsoap2.c:    if (soap->error)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:        return soap->error;
./stdsoap2.c:    soap->mode = n;
./stdsoap2.c:    soap_strcpy(soap->msgbuf, sizeof(soap->msgbuf), s);
./stdsoap2.c:    *soap->msgbuf = '\0';
./stdsoap2.c:  { char *r = strchr(soap->msgbuf, '?');
./stdsoap2.c:      { (void)soap_strncat(soap->msgbuf, sizeof(soap->msgbuf), "&", 1);
./stdsoap2.c:        (void)soap_strncat(soap->msgbuf, sizeof(soap->msgbuf), t + 1, strlen(t) - 1);
./stdsoap2.c:      { size_t l = r - soap->msgbuf;
./stdsoap2.c:        (void)soap_strncat(soap->msgbuf, sizeof(soap->msgbuf), t, strlen(t));
./stdsoap2.c:          (void)soap_strncat(soap->msgbuf, sizeof(soap->msgbuf), s + l, strlen(s + l));
./stdsoap2.c:      (void)soap_strncat(soap->msgbuf, sizeof(soap->msgbuf), t, strlen(t));
./stdsoap2.c:  return soap->msgbuf;
./stdsoap2.c:  if (strchr(soap->msgbuf, '?'))
./stdsoap2.c:    (void)soap_strncat(soap->msgbuf, sizeof(soap->msgbuf), "&", 1);
./stdsoap2.c:    (void)soap_strncat(soap->msgbuf, sizeof(soap->msgbuf), "?", 1);
./stdsoap2.c:  return soap->msgbuf;
./stdsoap2.c:  { char *r = soap->msgbuf;
./stdsoap2.c:      soap_memmove(r + m - 1, soap->msgbuf + sizeof(soap->msgbuf) - (r + n + 1), r + k + 1, strlen(r + k + 1) + 1);
./stdsoap2.c:        soap_memmove(r - 1, soap->msgbuf + sizeof(soap->msgbuf) - (r - 1), t, m);
./stdsoap2.c:    { (void)soap_strncat(soap->msgbuf, sizeof(soap->msgbuf), s, n);
./stdsoap2.c:      { size_t m = strlen(soap->msgbuf);
./stdsoap2.c:        soap_encode_url(t, soap->msgbuf + m, sizeof(soap->msgbuf) - m);
./stdsoap2.c:      (void)soap_strncat(soap->msgbuf, sizeof(soap->msgbuf), "&", 1);
./stdsoap2.c:    domain = soap->cookie_domain;
./stdsoap2.c:    path = soap->cookie_path;
./stdsoap2.c:  for (p = soap->cookies; p; p = p->next)
./stdsoap2.c:    domain = soap->cookie_domain;
./stdsoap2.c:    path = soap->cookie_path;
./stdsoap2.c:      for (p = &soap->cookies, n = soap->cookie_max; *p && n; p = &(*p)->next, n--)
./stdsoap2.c:    domain = soap->cookie_domain;
./stdsoap2.c:    path = soap->cookie_path;
./stdsoap2.c:  for (p = &soap->cookies, q = *p; q; q = *p)
./stdsoap2.c:  for (p = soap->cookies; p; p = p->next)
./stdsoap2.c:     || (!p->env && !soap->ssl == !p->secure)
./stdsoap2.c:      else if (soap->cookie_domain && (int)strlen(soap->cookie_domain) < 4064 - (s-tmp))
./stdsoap2.c:        soap_strcpy(s + 8, 4088 - (s-tmp), soap->cookie_domain);
./stdsoap2.c:        t = soap->cookie_path;
./stdsoap2.c:       || soap->ssl
./stdsoap2.c:      soap->error = soap->fposthdr(soap, "Set-Cookie", tmp);
./stdsoap2.c:      if (soap->error)
./stdsoap2.c:        return soap->error;
./stdsoap2.c:  p = &soap->cookies;
./stdsoap2.c:          soap->error = soap->fposthdr(soap, "Cookie", tmp);
./stdsoap2.c:          if (soap->error)
./stdsoap2.c:            return soap->error;
./stdsoap2.c:  { soap->error = soap->fposthdr(soap, "Cookie", tmp);
./stdsoap2.c:    if (soap->error)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:        else if (*soap->host)
./stdsoap2.c:        { l = strlen(soap->host) + 1;
./stdsoap2.c:            soap_memcpy((void*)p->domain, l, (const void*)soap->host, l);
./stdsoap2.c:        else if (*soap->path)
./stdsoap2.c:        { l = strlen(soap->path) + 1;
./stdsoap2.c:            soap_memcpy((void*)p->path, l, (const void*)soap->path, l);
./stdsoap2.c:  for (p = soap->cookies; p; p = p->next)
./stdsoap2.c:  for (p = soap->cookies; p; p = soap->cookies)
./stdsoap2.c:  { soap->cookies = p->next;
./stdsoap2.c:  soap->pblk = NULL;
./stdsoap2.c:  soap->pidx = 0;
./stdsoap2.c:    soap->pht[i] = NULL;
./stdsoap2.c:  for (pb = soap->pblk; pb; pb = next)
./stdsoap2.c:  soap->pblk = NULL;
./stdsoap2.c:  soap->pidx = 0;
./stdsoap2.c:    soap->pht[i] = NULL;
./stdsoap2.c:  if (soap->version == 2)
./stdsoap2.c:    soap->encoding = 1;
./stdsoap2.c:  if (!p || (!soap->encodingStyle && !(soap->omode & SOAP_XML_GRAPH)) || (soap->omode & SOAP_XML_TREE))
./stdsoap2.c:  { for (pp = soap->pht[soap_hash_ptr(p)]; pp; pp = pp->next)
./stdsoap2.c:  if (!soap->pblk || soap->pidx >= SOAP_PTRBLK)
./stdsoap2.c:    { soap->error = SOAP_EOM;
./stdsoap2.c:    pb->next = soap->pblk;
./stdsoap2.c:    soap->pblk = pb;
./stdsoap2.c:    soap->pidx = 0;
./stdsoap2.c:  *ppp = pp = &soap->pblk->plist[soap->pidx++];
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Pointer enter location=%p array=%p size=%lu type=%d id=%d\n", p, a, (unsigned long)n, type, soap->idnum+1));
./stdsoap2.c:  pp->next = soap->pht[h];
./stdsoap2.c:  soap->pht[h] = pp;
./stdsoap2.c:  pp->id = ++soap->idnum;
./stdsoap2.c:  for (pp = soap->pht[soap_hash_ptr(a)]; pp; pp = pp->next)
./stdsoap2.c:  if ((soap->mode & SOAP_ENC_DIME) || (soap->omode & SOAP_ENC_DIME))
./stdsoap2.c:    soap->mode = soap->omode | SOAP_IO_LENGTH | SOAP_ENC_DIME;
./stdsoap2.c:  { soap->mode = soap->omode;
./stdsoap2.c:    if ((soap->mode & SOAP_IO_UDP))
./stdsoap2.c:    { soap->mode &= SOAP_IO;
./stdsoap2.c:      soap->mode |= SOAP_IO_BUFFER;
./stdsoap2.c:      soap->mode |= SOAP_ENC_PLAIN;
./stdsoap2.c:    if ((soap->mode & SOAP_IO) == SOAP_IO_STORE
./stdsoap2.c:     || (((soap->mode & SOAP_IO) == SOAP_IO_CHUNK || (soap->mode & SOAP_ENC_PLAIN))
./stdsoap2.c:      && !soap->fpreparesend
./stdsoap2.c:      soap->mode &= ~SOAP_IO_LENGTH;
./stdsoap2.c:      soap->mode |= SOAP_IO_LENGTH;
./stdsoap2.c:  if ((soap->mode & SOAP_ENC_ZLIB) && (soap->mode & SOAP_IO) == SOAP_IO_FLUSH)
./stdsoap2.c:  { if (!(soap->mode & SOAP_ENC_DIME))
./stdsoap2.c:      soap->mode &= ~SOAP_IO_LENGTH;
./stdsoap2.c:    if (soap->mode & SOAP_ENC_PLAIN)
./stdsoap2.c:      soap->mode |= SOAP_IO_BUFFER;
./stdsoap2.c:      soap->mode |= SOAP_IO_STORE;
./stdsoap2.c:  if ((soap->mode & SOAP_ENC_MTOM) && (soap->mode & SOAP_ENC_DIME))
./stdsoap2.c:    soap->mode |= SOAP_ENC_MIME;
./stdsoap2.c:  else if (!(soap->mode & SOAP_ENC_MIME))
./stdsoap2.c:    soap->mode &= ~SOAP_ENC_MTOM;
./stdsoap2.c:  if (soap->mode & SOAP_ENC_MIME)
./stdsoap2.c:  soap->dime.list = soap->dime.last;    /* keep track of last DIME attachment */
./stdsoap2.c:  soap->count = 0;
./stdsoap2.c:  soap->ns = 0;
./stdsoap2.c:  soap->null = 0;
./stdsoap2.c:  soap->position = 0;
./stdsoap2.c:  soap->mustUnderstand = 0;
./stdsoap2.c:  soap->encoding = 0;
./stdsoap2.c:  soap->part = SOAP_BEGIN;
./stdsoap2.c:  soap->event = 0;
./stdsoap2.c:  soap->evlev = 0;
./stdsoap2.c:  soap->idnum = 0;
./stdsoap2.c:  soap->body = 1;
./stdsoap2.c:  soap->level = 0;
./stdsoap2.c:  soap->dime.count = 0; /* count # of attachments */
./stdsoap2.c:  soap->dime.size = 0; /* accumulate total size of attachments */
./stdsoap2.c:  if (soap->fprepareinitsend && (soap->mode & SOAP_IO) != SOAP_IO_STORE && (soap->error = soap->fprepareinitsend(soap)) != SOAP_OK)
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Begin count phase (socket=%d mode=0x%x count=%lu)\n", (int)soap->socket, (unsigned int)soap->mode, (unsigned long)soap->count));
./stdsoap2.c:  if ((soap->mode & SOAP_IO_LENGTH))
./stdsoap2.c:  { if (soap->fpreparefinalsend && (soap->error = soap->fpreparefinalsend(soap)) != SOAP_OK)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:{ DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Initializing for output to socket=%d/fd=%d\n", (int)soap->socket, soap->sendfd));
./stdsoap2.c:  soap->error = SOAP_OK;
./stdsoap2.c:  soap->mode = soap->omode | (soap->mode & (SOAP_IO_LENGTH | SOAP_ENC_DIME));
./stdsoap2.c:  if ((soap->mode & SOAP_IO_UDP))
./stdsoap2.c:  { soap->mode &= SOAP_IO;
./stdsoap2.c:    soap->mode |= SOAP_IO_BUFFER;
./stdsoap2.c:    soap->mode |= SOAP_ENC_PLAIN;
./stdsoap2.c:    if (soap->count > sizeof(soap->buf))
./stdsoap2.c:      return soap->error = SOAP_UDP_ERROR;
./stdsoap2.c:  if ((soap->mode & SOAP_ENC_ZLIB) && (soap->mode & SOAP_IO) == SOAP_IO_FLUSH)
./stdsoap2.c:  { if (soap->mode & SOAP_ENC_PLAIN)
./stdsoap2.c:      soap->mode |= SOAP_IO_BUFFER;
./stdsoap2.c:      soap->mode |= SOAP_IO_STORE;
./stdsoap2.c:  if ((soap->mode & SOAP_IO) == SOAP_IO_FLUSH)
./stdsoap2.c:  { if (soap_valid_socket(soap->socket))
./stdsoap2.c:    { if (soap->count || (soap->mode & SOAP_IO_LENGTH) || (soap->mode & SOAP_ENC_PLAIN))
./stdsoap2.c:        soap->mode |= SOAP_IO_BUFFER;
./stdsoap2.c:        soap->mode |= SOAP_IO_STORE;
./stdsoap2.c:    else if (soap->os != NULL)
./stdsoap2.c:    { *soap->os = NULL;
./stdsoap2.c:      soap->mode |= SOAP_IO_STORE;
./stdsoap2.c:  soap->mode &= ~SOAP_IO_LENGTH;
./stdsoap2.c:  if ((soap->mode & SOAP_IO) == SOAP_IO_STORE)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  if (!(soap->mode & SOAP_IO_KEEPALIVE))
./stdsoap2.c:    soap->keep_alive = 0;
./stdsoap2.c:  if ((soap->mode & SOAP_ENC_MTOM) && (soap->mode & SOAP_ENC_DIME))
./stdsoap2.c:  { soap->mode |= SOAP_ENC_MIME;
./stdsoap2.c:    soap->mode &= ~SOAP_ENC_DIME;
./stdsoap2.c:  else if (!(soap->mode & SOAP_ENC_MIME))
./stdsoap2.c:    soap->mode &= ~SOAP_ENC_MTOM;
./stdsoap2.c:  if (soap->mode & SOAP_ENC_MIME)
./stdsoap2.c:  if (!soap_valid_socket(soap->socket) && !soap->os && soap->sendfd >= 0) /* Set win32 stdout or soap->sendfd to BINARY, e.g. to support DIME */
./stdsoap2.c:    setmode(soap->sendfd, _O_BINARY);
./stdsoap2.c:    _setmode(soap->sendfd, _O_BINARY);
./stdsoap2.c:  if (soap->mode & SOAP_IO)
./stdsoap2.c:  { soap->bufidx = 0;
./stdsoap2.c:    soap->buflen = 0;
./stdsoap2.c:  soap->chunksize = 0;
./stdsoap2.c:  soap->ns = 0;
./stdsoap2.c:  soap->null = 0;
./stdsoap2.c:  soap->position = 0;
./stdsoap2.c:  soap->mustUnderstand = 0;
./stdsoap2.c:  soap->encoding = 0;
./stdsoap2.c:  soap->idnum = 0;
./stdsoap2.c:  soap->body = 1;
./stdsoap2.c:  soap->level = 0;
./stdsoap2.c:  soap->z_ratio_out = 1.0;
./stdsoap2.c:  if ((soap->mode & SOAP_ENC_ZLIB) && soap->zlib_state != SOAP_ZLIB_DEFLATE)
./stdsoap2.c:  { if (!soap->d_stream)
./stdsoap2.c:    { soap->d_stream = (z_stream*)SOAP_MALLOC(soap, sizeof(z_stream));
./stdsoap2.c:      soap->d_stream->zalloc = Z_NULL;
./stdsoap2.c:      soap->d_stream->zfree = Z_NULL;
./stdsoap2.c:      soap->d_stream->opaque = Z_NULL;
./stdsoap2.c:      soap->d_stream->next_in = Z_NULL;
./stdsoap2.c:    if (!soap->z_buf)
./stdsoap2.c:      soap->z_buf = (char*)SOAP_MALLOC(soap, sizeof(soap->buf));
./stdsoap2.c:    soap->d_stream->next_out = (Byte*)soap->z_buf;
./stdsoap2.c:    soap->d_stream->avail_out = sizeof(soap->buf);
./stdsoap2.c:    if (soap->zlib_out != SOAP_ZLIB_DEFLATE)
./stdsoap2.c:    { soap_memcpy((void*)soap->z_buf, sizeof(soap->buf), (const void*)"\37\213\10\0\0\0\0\0\0\377", 10);
./stdsoap2.c:      soap->d_stream->next_out = (Byte*)soap->z_buf + 10;
./stdsoap2.c:      soap->d_stream->avail_out = sizeof(soap->buf) - 10;
./stdsoap2.c:      soap->z_crc = crc32(0L, NULL, 0);
./stdsoap2.c:      soap->zlib_out = SOAP_ZLIB_GZIP;
./stdsoap2.c:      if (soap->z_dict)
./stdsoap2.c:        *((Byte*)soap->z_buf + 2) = 0xff;
./stdsoap2.c:      if (deflateInit2(soap->d_stream, soap->z_level, Z_DEFLATED, -MAX_WBITS, 8, Z_DEFAULT_STRATEGY) != Z_OK)
./stdsoap2.c:        return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:    if (deflateInit(soap->d_stream, soap->z_level) != Z_OK)
./stdsoap2.c:      return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:    if (soap->z_dict)
./stdsoap2.c:    { if (deflateSetDictionary(soap->d_stream, (const Bytef*)soap->z_dict, soap->z_dict_len) != Z_OK)
./stdsoap2.c:        return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:    soap->zlib_state = SOAP_ZLIB_DEFLATE;
./stdsoap2.c:  if (soap->ssl)
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Begin send phase (socket=%d mode=0x%x count=%lu)\n", (int)soap->socket, soap->mode, (unsigned long)soap->count));
./stdsoap2.c:  soap->part = SOAP_BEGIN;
./stdsoap2.c:  if (soap->fprepareinitsend && (soap->mode & SOAP_IO) == SOAP_IO_STORE && (soap->error = soap->fprepareinitsend(soap)) != SOAP_OK)
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  if (!p || (!soap->encodingStyle && !(soap->omode & (SOAP_ENC_DIME|SOAP_ENC_MIME|SOAP_ENC_MTOM|SOAP_XML_GRAPH))) || (soap->omode & SOAP_XML_TREE))
./stdsoap2.c:  if (!p || !a || (!soap->encodingStyle && !(soap->omode & (SOAP_ENC_DIME|SOAP_ENC_MIME|SOAP_ENC_MTOM|SOAP_XML_GRAPH))) || (soap->omode & SOAP_XML_TREE))
./stdsoap2.c:  if (id >= 0 || (!soap->encodingStyle && !(soap->omode & SOAP_XML_GRAPH)) || (soap->omode & SOAP_XML_TREE))
./stdsoap2.c:    if (soap->version == 1 && soap->part != SOAP_IN_HEADER)
./stdsoap2.c:      { if (soap->mode & SOAP_IO_LENGTH)
./stdsoap2.c:    { if (soap->mode & SOAP_IO_LENGTH)
./stdsoap2.c:  if (soap->version == 1 && soap->encodingStyle && !(soap->mode & SOAP_XML_GRAPH) && soap->part != SOAP_IN_HEADER)
./stdsoap2.c:  { if (soap->mode & SOAP_IO_LENGTH)
./stdsoap2.c:  if (soap->mode & SOAP_IO_LENGTH)
./stdsoap2.c:{ if (soap->part == SOAP_IN_HEADER)
./stdsoap2.c:  if (soap->mode & SOAP_IO_LENGTH)
./stdsoap2.c:  if (soap->mode & SOAP_IO_LENGTH)
./stdsoap2.c:    { soap->error = SOAP_EOM;
./stdsoap2.c:  { (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), strlen(soap->dime_id_format) + 20), soap->dime_id_format, id);
./stdsoap2.c:    aid = soap_strdup(soap, soap->tmpbuf);
./stdsoap2.c:  if ((soap->mode & SOAP_ENC_MTOM) && strcmp(tag, "xop:Include"))
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  if (soap->mode & SOAP_IO_LENGTH)
./stdsoap2.c:      if (soap->mode & SOAP_ENC_MTOM)
./stdsoap2.c:        content = soap_alloc_multipart(soap, &soap->mime.first, &soap->mime.last, (char*)a, n);
./stdsoap2.c:        content = soap_alloc_multipart(soap, &soap->dime.first, &soap->dime.last, (char*)a, n);
./stdsoap2.c:      { soap->error = SOAP_EOM;
./stdsoap2.c:      { if (soap->mode & SOAP_ENC_MTOM)
./stdsoap2.c:    soap->iht[i] = NULL;
./stdsoap2.c:  { for (ip = soap->iht[i]; ip; ip = p)
./stdsoap2.c:    soap->iht[i] = NULL;
./stdsoap2.c:  for (ip = soap->iht[soap_hash(id)]; ip; ip = ip->next)
./stdsoap2.c:    h = soap_hash(id); /* h = (HASH(id) % SOAP_IDHASH) so soap->iht[h] is safe */
./stdsoap2.c:    ip->next = soap->iht[h];
./stdsoap2.c:    soap->iht[h] = ip;
./stdsoap2.c:  if (soap->fmalloc)
./stdsoap2.c:    p = (char*)soap->fmalloc(soap, n);
./stdsoap2.c:    { soap->error = SOAP_EOM;
./stdsoap2.c:    *(void**)(p + n) = soap->alist;
./stdsoap2.c:    soap->alist = p + n;
./stdsoap2.c:    soap->mht[i] = NULL;
./stdsoap2.c:  { for (mp = soap->mht[i]; mp; mp = mq)
./stdsoap2.c:    soap->mht[i] = NULL;
./stdsoap2.c:    if (soap->fdebug[SOAP_INDEX_TEST])
./stdsoap2.c:    mp->next = soap->mht[h];
./stdsoap2.c:    soap->mht[h] = mp;
./stdsoap2.c:    for (mp = soap->mht[h]; mp; mp = mp->next)
./stdsoap2.c:      { if (soap->fdebug[SOAP_INDEX_TEST])
./stdsoap2.c:  for (mp = soap->mht[h]; mp; mp = mp->next)
./stdsoap2.c:    for (q = (char**)(void*)&soap->alist; *q; q = *(char***)q)
./stdsoap2.c:        soap->error = SOAP_MOE;
./stdsoap2.c:    while (soap->alist)
./stdsoap2.c:    { q = (char*)soap->alist;
./stdsoap2.c:        soap->error = SOAP_MOE;
./stdsoap2.c:      soap->alist = *(void**)q;
./stdsoap2.c:    soap->http_content = NULL;
./stdsoap2.c:    soap->action = NULL;
./stdsoap2.c:    soap->fault = NULL;
./stdsoap2.c:    soap->header = NULL;
./stdsoap2.c:    soap->userid = NULL;
./stdsoap2.c:    soap->passwd = NULL;
./stdsoap2.c:    soap->authrealm = NULL;
./stdsoap2.c:    soap->ntlm_challenge = NULL;
./stdsoap2.c:  cp = &soap->clist;
./stdsoap2.c:  soap->fault = NULL; /* assume this was deallocated */
./stdsoap2.c:  soap->header = NULL; /* assume this was deallocated */
./stdsoap2.c:  for (q = (char**)(void*)&soap->alist; *q; q = *(char***)q)
./stdsoap2.c:      soap->error = SOAP_MOE;
./stdsoap2.c:    for (mp = &soap->mht[h]; *mp; mp = &(*mp)->next)
./stdsoap2.c:  soap_to->alist = soap->alist;
./stdsoap2.c:  soap->alist = NULL;
./stdsoap2.c:  cp = soap->clist;
./stdsoap2.c:    for (mp = &soap->mht[h]; *mp; mp = &(*mp)->next)
./stdsoap2.c:    cp->next = soap->clist;
./stdsoap2.c:    soap_to->clist = soap->clist;
./stdsoap2.c:  soap->clist = NULL;
./stdsoap2.c:        soap->error = SOAP_EOM;
./stdsoap2.c:      { cp->next = soap->clist;
./stdsoap2.c:        soap->clist = cp;
./stdsoap2.c:    soap->alloced = t;
./stdsoap2.c:  { for (q = (char**)(void*)&soap->alist; *q; q = *(char***)q)
./stdsoap2.c:    for (cp = &soap->clist; *cp; cp = &(*cp)->next)
./stdsoap2.c:{ short f = soap->shaky;
./stdsoap2.c:  soap->shaky = 1;
./stdsoap2.c:{ soap->shaky = f;
./stdsoap2.c:  if (!soap->blist && !soap->shaky)
./stdsoap2.c:    { soap->error = SOAP_EOM;
./stdsoap2.c:  soap->alloced = 0;
./stdsoap2.c:    { p = finstantiate(soap, t, type, arrayType, &n); /* soap->alloced is set in soap_link() */
./stdsoap2.c:      t = soap->alloced;
./stdsoap2.c:      soap->alloced = t;
./stdsoap2.c:    if (!soap->alloced)
./stdsoap2.c:    soap_strcpy(soap->id, sizeof(soap->id), id);
./stdsoap2.c:    soap->error = SOAP_DUPLICATE_ID;
./stdsoap2.c:    if (!soap->alloced)
./stdsoap2.c:    if (soap->alloced || !ip->shaky)
./stdsoap2.c:    for (ip = soap->iht[i]; ip; ip = ip->next)
./stdsoap2.c:  soap_strcpy(soap->id, sizeof(soap->id), id);
./stdsoap2.c:  return soap->error = SOAP_HREF;
./stdsoap2.c:  if (soap->dime.list)
./stdsoap2.c:    soap->dime.last->next = soap->dime.first;
./stdsoap2.c:    soap->dime.first = soap->dime.list->next;
./stdsoap2.c:    soap->dime.list->next = NULL;
./stdsoap2.c:    soap->dime.last = soap->dime.list;
./stdsoap2.c:  soap->mime.list = NULL;
./stdsoap2.c:  soap->mime.first = NULL;
./stdsoap2.c:  soap->mime.last = NULL;
./stdsoap2.c:  soap->dime.list = NULL;
./stdsoap2.c:  soap->dime.first = NULL;
./stdsoap2.c:  soap->dime.last = NULL;
./stdsoap2.c:{ DBGLOG(TEST, SOAP_MESSAGE(fdebug, "End send mode=0x%x\n", soap->mode));
./stdsoap2.c:  if (soap->mode & SOAP_IO) /* need to flush the remaining data in buffer */
./stdsoap2.c:    { if (soap->mode & SOAP_ENC_ZLIB && soap->zlib_state == SOAP_ZLIB_DEFLATE)
./stdsoap2.c:      { soap->zlib_state = SOAP_ZLIB_NONE;
./stdsoap2.c:        deflateEnd(soap->d_stream);
./stdsoap2.c:      return soap->error;
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    if ((soap->mode & SOAP_ENC_ZLIB) && soap->d_stream)
./stdsoap2.c:      soap->d_stream->avail_in = 0;
./stdsoap2.c:        r = deflate(soap->d_stream, Z_FINISH);
./stdsoap2.c:        if (soap->d_stream->avail_out != sizeof(soap->buf))
./stdsoap2.c:        { if (soap_flush_raw(soap, soap->z_buf, sizeof(soap->buf) - soap->d_stream->avail_out))
./stdsoap2.c:          { soap->zlib_state = SOAP_ZLIB_NONE;
./stdsoap2.c:            deflateEnd(soap->d_stream);
./stdsoap2.c:            return soap->error;
./stdsoap2.c:          soap->d_stream->next_out = (Byte*)soap->z_buf;
./stdsoap2.c:          soap->d_stream->avail_out = sizeof(soap->buf);
./stdsoap2.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Deflated total %lu->%lu bytes\n", soap->d_stream->total_in, soap->d_stream->total_out));
./stdsoap2.c:      soap->z_ratio_out = (float)soap->d_stream->total_out / (float)soap->d_stream->total_in;
./stdsoap2.c:      soap->mode &= ~SOAP_ENC_ZLIB;
./stdsoap2.c:      soap->zlib_state = SOAP_ZLIB_NONE;
./stdsoap2.c:      if (deflateEnd(soap->d_stream) != Z_OK || r != Z_STREAM_END)
./stdsoap2.c:      { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unable to end deflate: %s\n", soap->d_stream->msg ? soap->d_stream->msg : SOAP_STR_EOS));
./stdsoap2.c:        return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:      if (soap->zlib_out != SOAP_ZLIB_DEFLATE)
./stdsoap2.c:      { soap->z_buf[0] = soap->z_crc & 0xFF;
./stdsoap2.c:        soap->z_buf[1] = (soap->z_crc >> 8) & 0xFF;
./stdsoap2.c:        soap->z_buf[2] = (soap->z_crc >> 16) & 0xFF;
./stdsoap2.c:        soap->z_buf[3] = (soap->z_crc >> 24) & 0xFF;
./stdsoap2.c:        soap->z_buf[4] = soap->d_stream->total_in & 0xFF;
./stdsoap2.c:        soap->z_buf[5] = (soap->d_stream->total_in >> 8) & 0xFF;
./stdsoap2.c:        soap->z_buf[6] = (soap->d_stream->total_in >> 16) & 0xFF;
./stdsoap2.c:        soap->z_buf[7] = (soap->d_stream->total_in >> 24) & 0xFF;
./stdsoap2.c:        if (soap_flush_raw(soap, soap->z_buf, 8))
./stdsoap2.c:          return soap->error;
./stdsoap2.c:        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "gzip crc32=%lu\n", (unsigned long)soap->z_crc));
./stdsoap2.c:    if ((soap->mode & SOAP_IO) == SOAP_IO_STORE)
./stdsoap2.c:      if (soap->os)
./stdsoap2.c:          *soap->os = soap_save_block(soap, NULL, NULL, 0);
./stdsoap2.c:        if (!(soap->mode & SOAP_ENC_PLAIN))
./stdsoap2.c:        { soap->mode--;
./stdsoap2.c:          DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Sending buffered message of length %u\n", (unsigned int)soap->blist->size));
./stdsoap2.c:          if (soap->status >= SOAP_POST)
./stdsoap2.c:            soap->error = soap->fpost(soap, soap->endpoint, soap->host, soap->port, soap->path, soap->action, soap->blist->size);
./stdsoap2.c:          else if (soap->status != SOAP_STOP)
./stdsoap2.c:            soap->error = soap->fresponse(soap, soap->status, soap->blist->size);
./stdsoap2.c:          if (soap->error || soap_flush(soap))
./stdsoap2.c:            return soap->error;
./stdsoap2.c:          soap->mode++;
./stdsoap2.c:          DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Send %u bytes to socket=%d/fd=%d\n", (unsigned int)soap_block_size(soap, NULL), (int)soap->socket, soap->sendfd));
./stdsoap2.c:          soap->error = soap->fsend(soap, p, soap_block_size(soap, NULL));
./stdsoap2.c:          if (soap->error)
./stdsoap2.c:            return soap->error;
./stdsoap2.c:      if (soap->fpreparefinalsend && (soap->error = soap->fpreparefinalsend(soap)) != SOAP_OK)
./stdsoap2.c:        return soap->error;
./stdsoap2.c:    else if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK)
./stdsoap2.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Send 7 bytes to socket=%d/fd=%d\n", (int)soap->socket, soap->sendfd));
./stdsoap2.c:      soap->error = soap->fsend(soap, "\r\n0\r\n\r\n", 7);
./stdsoap2.c:      if (soap->error)
./stdsoap2.c:        return soap->error;
./stdsoap2.c:  if (!soap->ssl)
./stdsoap2.c:    if (soap_valid_socket(soap->socket) && !soap->keep_alive && !(soap->omode & SOAP_IO_UDP))
./stdsoap2.c:      soap->fshutdownsocket(soap, soap->socket, SOAP_SHUT_WR); /* Send TCP FIN */
./stdsoap2.c:  if (soap->os)
./stdsoap2.c:    soap->os->flush();
./stdsoap2.c:  soap->omode &= ~SOAP_SEC_WSUID;
./stdsoap2.c:  soap->count = 0;
./stdsoap2.c:  soap->part = SOAP_END;
./stdsoap2.c:{ soap->part = SOAP_END;
./stdsoap2.c:  soap->wsuid = NULL;           /* reset before next send */
./stdsoap2.c:  soap->c14nexclude = NULL;     /* reset before next send */
./stdsoap2.c:  soap->c14ninclude = NULL;     /* reset before next send */
./stdsoap2.c:  soap->ffilterrecv = NULL;
./stdsoap2.c:  if ((soap->mode & SOAP_ENC_DIME) && soap_getdime(soap))
./stdsoap2.c:  { soap->dime.first = NULL;
./stdsoap2.c:    soap->dime.last = NULL;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  soap->dime.list = soap->dime.first;
./stdsoap2.c:  soap->dime.first = NULL;
./stdsoap2.c:  soap->dime.last = NULL;
./stdsoap2.c:  if (soap->mode & SOAP_ENC_MIME)
./stdsoap2.c:  { if (soap->mode & SOAP_MIME_POSTCHECK)
./stdsoap2.c:      if (!soap->keep_alive)
./stdsoap2.c:        soap->keep_alive = -2; /* special case to keep alive */
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  soap->mime.list = soap->mime.first;
./stdsoap2.c:  soap->mime.first = NULL;
./stdsoap2.c:  soap->mime.last = NULL;
./stdsoap2.c:  soap->mime.boundary = NULL;
./stdsoap2.c:  if (soap->xlist)
./stdsoap2.c:    for (content = soap->mime.list; content; content = content->next)
./stdsoap2.c:  if ((soap->mode & SOAP_ENC_ZLIB) && soap->d_stream)
./stdsoap2.c:    while (soap->d_stream->next_out != Z_NULL)
./stdsoap2.c:    soap->mode &= ~SOAP_ENC_ZLIB;
./stdsoap2.c:    soap_memcpy((void*)soap->buf, sizeof(soap->buf), (const void*)soap->z_buf, sizeof(soap->buf));
./stdsoap2.c:    soap->bufidx = (char*)soap->d_stream->next_in - soap->z_buf;
./stdsoap2.c:    soap->buflen = soap->z_buflen;
./stdsoap2.c:    soap->zlib_state = SOAP_ZLIB_NONE;
./stdsoap2.c:    if (inflateEnd(soap->d_stream) != Z_OK)
./stdsoap2.c:      return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:    if (soap->zlib_in == SOAP_ZLIB_GZIP)
./stdsoap2.c:          return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:        soap->z_buf[i] = (char)c;
./stdsoap2.c:      if (soap->z_crc != ((uLong)(unsigned char)soap->z_buf[0] | ((uLong)(unsigned char)soap->z_buf[1] << 8) | ((uLong)(unsigned char)soap->z_buf[2] << 16) | ((uLong)(unsigned char)soap->z_buf[3] << 24)))
./stdsoap2.c:      { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Gzip inflate error: crc check failed, message corrupted? (crc32=%lu)\n", (unsigned long)soap->z_crc));
./stdsoap2.c:        return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:      if (soap->d_stream->total_out != ((uLong)(unsigned char)soap->z_buf[4] | ((uLong)(unsigned char)soap->z_buf[5] << 8) | ((uLong)(unsigned char)soap->z_buf[6] << 16) | ((uLong)(unsigned char)soap->z_buf[7] << 24)))
./stdsoap2.c:        return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:    soap->zlib_in = SOAP_ZLIB_NONE;
./stdsoap2.c:  if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK)
./stdsoap2.c:    while (soap->ahead != EOF && !soap_recv_raw(soap))
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  if (soap->xlist)
./stdsoap2.c:  { if (soap->mode & SOAP_ENC_MTOM)
./stdsoap2.c:      return soap->error = SOAP_MIME_HREF;
./stdsoap2.c:    return soap->error = SOAP_DIME_HREF;
./stdsoap2.c:  if (soap->fpreparefinalrecv)
./stdsoap2.c:    return soap->error = soap->fpreparefinalrecv(soap);
./stdsoap2.c:  while (soap->blist)
./stdsoap2.c:  for (tp = soap->attributes; tp; tp = tq)
./stdsoap2.c:  soap->attributes = NULL;
./stdsoap2.c:  if (soap->labbuf)
./stdsoap2.c:    SOAP_FREE(soap, soap->labbuf);
./stdsoap2.c:  soap->labbuf = NULL;
./stdsoap2.c:  soap->lablen = 0;
./stdsoap2.c:  soap->labidx = 0;
./stdsoap2.c:  ns = soap->local_namespaces;
./stdsoap2.c:    SOAP_FREE(soap, soap->local_namespaces);
./stdsoap2.c:    soap->local_namespaces = NULL;
./stdsoap2.c:  while (soap->xlist)
./stdsoap2.c:  { struct soap_xlist *xp = soap->xlist->next;
./stdsoap2.c:    SOAP_FREE(soap, soap->xlist);
./stdsoap2.c:    soap->xlist = xp;
./stdsoap2.c:  for (np = soap->nlist; np; np = nq)
./stdsoap2.c:  soap->nlist = NULL;
./stdsoap2.c:  { soap->logfile[i] = NULL;
./stdsoap2.c:    soap->fdebug[i] = NULL;
./stdsoap2.c:{ if (soap->logfile[i])
./stdsoap2.c:    soap->fdebug[i] = fopen(soap->logfile[i], i < 2 ? "ab" : "a");
./stdsoap2.c:{ if (soap->fdebug[i])
./stdsoap2.c:  { fclose(soap->fdebug[i]);
./stdsoap2.c:    soap->fdebug[i] = NULL;
./stdsoap2.c:  s = soap->logfile[i];
./stdsoap2.c:  soap->logfile[i] = logfile;
./stdsoap2.c:  soap->logfile[i] = t;
./stdsoap2.c:    soap_set_test_logfile(copy, soap->logfile[SOAP_INDEX_TEST]);
./stdsoap2.c:    soap_set_sent_logfile(copy, soap->logfile[SOAP_INDEX_SENT]);
./stdsoap2.c:    soap_set_recv_logfile(copy, soap->logfile[SOAP_INDEX_RECV]);
./stdsoap2.c:    copy->namespaces = soap->local_namespaces;
./stdsoap2.c:    soap_set_local_namespaces(copy); /* copy content of soap->local_namespaces */
./stdsoap2.c:    copy->namespaces = soap->namespaces; /* point to shared read-only namespaces table */
./stdsoap2.c:    for (p = soap->plugins; p; p = p->next)
./stdsoap2.c:  copy->header = soap->header;
./stdsoap2.c:  copy->mode = soap->mode;
./stdsoap2.c:  copy->imode = soap->imode;
./stdsoap2.c:  copy->omode = soap->omode;
./stdsoap2.c:  copy->socket = soap->socket;
./stdsoap2.c:  copy->sendsk = soap->sendsk;
./stdsoap2.c:  copy->recvsk = soap->recvsk;
./stdsoap2.c:  copy->recv_timeout = soap->recv_timeout;
./stdsoap2.c:  copy->send_timeout = soap->send_timeout;
./stdsoap2.c:  copy->connect_timeout = soap->connect_timeout;
./stdsoap2.c:  copy->accept_timeout = soap->accept_timeout;
./stdsoap2.c:  copy->socket_flags = soap->socket_flags;
./stdsoap2.c:  copy->connect_flags = soap->connect_flags;
./stdsoap2.c:  copy->bind_flags = soap->bind_flags;
./stdsoap2.c:  copy->accept_flags = soap->accept_flags;
./stdsoap2.c:  copy->sndbuf = soap->sndbuf;
./stdsoap2.c:  copy->rcvbuf = soap->rcvbuf;
./stdsoap2.c:  copy->linger_time = soap->linger_time;
./stdsoap2.c:  copy->maxlevel = soap->maxlevel;
./stdsoap2.c:  copy->maxlength = soap->maxlength;
./stdsoap2.c:  copy->maxoccurs = soap->maxoccurs;
./stdsoap2.c:  copy->os = soap->os;
./stdsoap2.c:  copy->is = soap->is;
./stdsoap2.c:  copy->sendfd = soap->sendfd;
./stdsoap2.c:  copy->recvfd = soap->recvfd;
./stdsoap2.c:  copy->bufidx = soap->bufidx;
./stdsoap2.c:  copy->buflen = soap->buflen;
./stdsoap2.c:  copy->ahead = soap->ahead;
./stdsoap2.c:  copy->cdata = soap->cdata;
./stdsoap2.c:  copy->chunksize = soap->chunksize;
./stdsoap2.c:  copy->chunkbuflen = soap->chunkbuflen;
./stdsoap2.c:  copy->keep_alive = soap->keep_alive;
./stdsoap2.c:  copy->tcp_keep_alive = soap->tcp_keep_alive;
./stdsoap2.c:  copy->tcp_keep_idle = soap->tcp_keep_idle;
./stdsoap2.c:  copy->tcp_keep_intvl = soap->tcp_keep_intvl;
./stdsoap2.c:  copy->tcp_keep_cnt = soap->tcp_keep_cnt;
./stdsoap2.c:  copy->max_keep_alive = soap->max_keep_alive;
./stdsoap2.c:  copy->peer = soap->peer;
./stdsoap2.c:  copy->peerlen = soap->peerlen;
./stdsoap2.c:  copy->ip = soap->ip;
./stdsoap2.c:  copy->port = soap->port;
./stdsoap2.c:  soap_memcpy((void*)copy->host, sizeof(copy->host), (const void*)soap->host, sizeof(soap->host));
./stdsoap2.c:  soap_memcpy((void*)copy->endpoint, sizeof(copy->endpoint), (const void*)soap->endpoint, sizeof(soap->endpoint));
./stdsoap2.c:  copy->bio = soap->bio;
./stdsoap2.c:  copy->ctx = soap->ctx;
./stdsoap2.c:  copy->ssl = soap->ssl;
./stdsoap2.c:  copy->session = soap->session;
./stdsoap2.c:  copy->ctx = soap->ctx;
./stdsoap2.c:  copy->ssl = soap->ssl;
./stdsoap2.c:  copy->zlib_state = soap->zlib_state;
./stdsoap2.c:  copy->zlib_in = soap->zlib_in;
./stdsoap2.c:  copy->zlib_out = soap->zlib_out;
./stdsoap2.c:  if (soap->d_stream && soap->zlib_state != SOAP_ZLIB_NONE)
./stdsoap2.c:      soap_memcpy((void*)copy->d_stream, sizeof(z_stream), (const void*)soap->d_stream, sizeof(z_stream));
./stdsoap2.c:  copy->z_crc = soap->z_crc;
./stdsoap2.c:  copy->z_ratio_in = soap->z_ratio_in;
./stdsoap2.c:  copy->z_ratio_out = soap->z_ratio_out;
./stdsoap2.c:  copy->z_buflen = soap->z_buflen;
./stdsoap2.c:  copy->z_level = soap->z_level;
./stdsoap2.c:  if (soap->z_buf && soap->zlib_state != SOAP_ZLIB_NONE)
./stdsoap2.c:  { copy->z_buf = (char*)SOAP_MALLOC(copy, sizeof(soap->buf));
./stdsoap2.c:      soap_memcpy((void*)copy->z_buf, sizeof(soap->buf), (const void*)soap->z_buf, sizeof(soap->buf));
./stdsoap2.c:  copy->z_dict = soap->z_dict;
./stdsoap2.c:  copy->z_dict_len = soap->z_dict_len;
./stdsoap2.c:  soap_memcpy((void*)copy->buf, sizeof(copy->buf), (const void*)soap->buf, sizeof(soap->buf));
./stdsoap2.c:  copy->version = soap->version;
./stdsoap2.c:  if (soap->nlist && soap->local_namespaces)
./stdsoap2.c:    for (nq = soap->nlist; nq; nq = nq->next)
./stdsoap2.c:      { s = soap->local_namespaces[np->index].out;
./stdsoap2.c:          s = soap->local_namespaces[np->index].ns;
./stdsoap2.c:  soap_memcpy((void*)copy->tag, sizeof(copy->tag), (const void*)soap->tag, sizeof(soap->tag));
./stdsoap2.c:  soap_memcpy((void*)copy->id, sizeof(copy->id), (const void*)soap->id, sizeof(soap->id));
./stdsoap2.c:  soap_memcpy((void*)copy->href, sizeof(copy->href), (const void*)soap->href, sizeof(soap->href));
./stdsoap2.c:  soap_memcpy((void*)copy->type, sizeof(copy->type), (const void*)soap->type, sizeof(soap->type));
./stdsoap2.c:  copy->other = soap->other;
./stdsoap2.c:  copy->root = soap->root;
./stdsoap2.c:  copy->null = soap->null;
./stdsoap2.c:  copy->body = soap->body;
./stdsoap2.c:  copy->part = soap->part;
./stdsoap2.c:  copy->mustUnderstand = soap->mustUnderstand;
./stdsoap2.c:  copy->level = soap->level;
./stdsoap2.c:  copy->peeked = soap->peeked;
./stdsoap2.c:  for (tq = soap->attributes; tq; tq = tq->next)
./stdsoap2.c:{ soap->socket = SOAP_INVALID_SOCKET;
./stdsoap2.c:  soap->sendsk = SOAP_INVALID_SOCKET;
./stdsoap2.c:  soap->recvsk = SOAP_INVALID_SOCKET;
./stdsoap2.c:  soap->bio = NULL;
./stdsoap2.c:  soap->ctx = NULL;
./stdsoap2.c:  soap->ssl = NULL;
./stdsoap2.c:  soap->xcred = NULL;
./stdsoap2.c:  soap->acred = NULL;
./stdsoap2.c:  soap->cache = NULL;
./stdsoap2.c:  soap->session = NULL;
./stdsoap2.c:  soap->dh_params = NULL;
./stdsoap2.c:  soap->rsa_params = NULL;
./stdsoap2.c:  soap->ctx = (gsk_handle)NULL;
./stdsoap2.c:  soap->ssl = (gsk_handle)NULL;
./stdsoap2.c:  if (soap->z_buf)
./stdsoap2.c:    SOAP_FREE(soap, soap->z_buf);
./stdsoap2.c:  soap->z_buf = NULL;
./stdsoap2.c:  soap->state = SOAP_INIT;
./stdsoap2.c:  soap->version = 0;
./stdsoap2.c:  soap->imode = imode;
./stdsoap2.c:  soap->omode = omode;
./stdsoap2.c:  soap->mode = imode;
./stdsoap2.c:  soap->plugins = NULL;
./stdsoap2.c:  soap->user = NULL;
./stdsoap2.c:  for (i = 0; i < sizeof(soap->data)/sizeof(*soap->data); i++)
./stdsoap2.c:    soap->data[i] = NULL;
./stdsoap2.c:  soap->userid = NULL;
./stdsoap2.c:  soap->passwd = NULL;
./stdsoap2.c:  soap->authrealm = NULL;
./stdsoap2.c:  soap->ntlm_challenge = NULL;
./stdsoap2.c:  soap->fpost = http_post;
./stdsoap2.c:  soap->fget = http_get;
./stdsoap2.c:  soap->fput = http_405;
./stdsoap2.c:  soap->fdel = http_405;
./stdsoap2.c:  soap->fopt = http_200;
./stdsoap2.c:  soap->fhead = http_200;
./stdsoap2.c:  soap->fform = NULL;
./stdsoap2.c:  soap->fposthdr = http_post_header;
./stdsoap2.c:  soap->fresponse = http_response;
./stdsoap2.c:  soap->fparse = http_parse;
./stdsoap2.c:  soap->fparsehdr = http_parse_header;
./stdsoap2.c:  soap->fheader = NULL;
./stdsoap2.c:  soap->fconnect = NULL;
./stdsoap2.c:  soap->fdisconnect = NULL;
./stdsoap2.c:  soap->ipv6_multicast_if = 0; /* in_addr_t value */
./stdsoap2.c:  soap->ipv4_multicast_if = NULL; /* points to struct in_addr or in_addr_t */
./stdsoap2.c:  soap->ipv4_multicast_ttl = 0; /* 0: use default */
./stdsoap2.c:  soap->client_port = -1;
./stdsoap2.c:  soap->fresolve = tcp_gethost;
./stdsoap2.c:  soap->fresolve = NULL;
./stdsoap2.c:  soap->faccept = tcp_accept;
./stdsoap2.c:  soap->fopen = tcp_connect;
./stdsoap2.c:  soap->fclose = tcp_disconnect;
./stdsoap2.c:  soap->fclosesocket = tcp_closesocket;
./stdsoap2.c:  soap->fshutdownsocket = tcp_shutdownsocket;
./stdsoap2.c:  soap->fsend = fsend;
./stdsoap2.c:  soap->frecv = frecv;
./stdsoap2.c:  soap->fpoll = soap_poll;
./stdsoap2.c:  soap->fopen = NULL;
./stdsoap2.c:  soap->fclose = NULL;
./stdsoap2.c:  soap->fpoll = NULL;
./stdsoap2.c:  soap->fseterror = NULL;
./stdsoap2.c:  soap->fignore = NULL;
./stdsoap2.c:  soap->fserveloop = NULL;
./stdsoap2.c:  soap->fplugin = fplugin;
./stdsoap2.c:  soap->fmalloc = NULL;
./stdsoap2.c:  soap->fsvalidate = NULL;
./stdsoap2.c:  soap->fwvalidate = NULL;
./stdsoap2.c:  soap->feltbegin = NULL;
./stdsoap2.c:  soap->feltendin = NULL;
./stdsoap2.c:  soap->feltbegout = NULL;
./stdsoap2.c:  soap->feltendout = NULL;
./stdsoap2.c:  soap->fprepareinitsend = NULL;
./stdsoap2.c:  soap->fprepareinitrecv = NULL;
./stdsoap2.c:  soap->fpreparesend = NULL;
./stdsoap2.c:  soap->fpreparerecv = NULL;
./stdsoap2.c:  soap->fpreparefinalsend = NULL;
./stdsoap2.c:  soap->fpreparefinalrecv = NULL;
./stdsoap2.c:  soap->ffiltersend = NULL;
./stdsoap2.c:  soap->ffilterrecv = NULL;
./stdsoap2.c:  soap->fdimereadopen = NULL;
./stdsoap2.c:  soap->fdimewriteopen = NULL;
./stdsoap2.c:  soap->fdimereadclose = NULL;
./stdsoap2.c:  soap->fdimewriteclose = NULL;
./stdsoap2.c:  soap->fdimeread = NULL;
./stdsoap2.c:  soap->fdimewrite = NULL;
./stdsoap2.c:  soap->fmimereadopen = NULL;
./stdsoap2.c:  soap->fmimewriteopen = NULL;
./stdsoap2.c:  soap->fmimereadclose = NULL;
./stdsoap2.c:  soap->fmimewriteclose = NULL;
./stdsoap2.c:  soap->fmimeread = NULL;
./stdsoap2.c:  soap->fmimewrite = NULL;
./stdsoap2.c:  soap->float_format = "%.9G"; /* Alternative: use "%G" */
./stdsoap2.c:  soap->double_format = "%.17lG"; /* Alternative: use "%lG" */
./stdsoap2.c:  soap->long_double_format = NULL; /* Defined in custom serializer custom/long_double.c */
./stdsoap2.c:  soap->dime_id_format = "cid:id%d"; /* default DIME id format for int id index */
./stdsoap2.c:  soap->recv_timeout = 0;
./stdsoap2.c:  soap->send_timeout = 0;
./stdsoap2.c:  soap->connect_timeout = 0;
./stdsoap2.c:  soap->accept_timeout = 0;
./stdsoap2.c:  soap->socket_flags = 0;
./stdsoap2.c:  soap->connect_flags = 0;
./stdsoap2.c:  soap->bind_flags = 0;
./stdsoap2.c:  soap->accept_flags = 0;
./stdsoap2.c:  soap->sndbuf = SOAP_BUFLEN + 1; /* this size speeds up windows xfer */
./stdsoap2.c:  soap->rcvbuf = SOAP_BUFLEN + 1;
./stdsoap2.c:  soap->sndbuf = SOAP_BUFLEN;
./stdsoap2.c:  soap->rcvbuf = SOAP_BUFLEN;
./stdsoap2.c:  soap->linger_time = 0;
./stdsoap2.c:  soap->maxlevel = SOAP_MAXLEVEL;
./stdsoap2.c:  soap->maxlength = SOAP_MAXLENGTH;
./stdsoap2.c:  soap->maxoccurs = SOAP_MAXOCCURS;
./stdsoap2.c:  soap->http_version = "1.1";
./stdsoap2.c:  soap->proxy_http_version = "1.0";
./stdsoap2.c:  soap->http_content = NULL;
./stdsoap2.c:  soap->http_extra_header = NULL;
./stdsoap2.c:  soap->actor = NULL;
./stdsoap2.c:  soap->lang = "en";
./stdsoap2.c:  soap->keep_alive = 0;
./stdsoap2.c:  soap->tcp_keep_alive = 0;
./stdsoap2.c:  soap->tcp_keep_idle = 0;
./stdsoap2.c:  soap->tcp_keep_intvl = 0;
./stdsoap2.c:  soap->tcp_keep_cnt = 0;
./stdsoap2.c:  soap->max_keep_alive = SOAP_MAXKEEPALIVE;
./stdsoap2.c:  soap->ip = 0;
./stdsoap2.c:  soap->labbuf = NULL;
./stdsoap2.c:  soap->lablen = 0;
./stdsoap2.c:  soap->labidx = 0;
./stdsoap2.c:  soap->encodingStyle = NULL;
./stdsoap2.c:  soap->namespaces = namespaces;
./stdsoap2.c:  soap->namespaces = NULL;
./stdsoap2.c:  soap->local_namespaces = NULL;
./stdsoap2.c:  soap->nlist = NULL;
./stdsoap2.c:  soap->blist = NULL;
./stdsoap2.c:  soap->clist = NULL;
./stdsoap2.c:  soap->alist = NULL;
./stdsoap2.c:  soap->shaky = 0;
./stdsoap2.c:  soap->attributes = NULL;
./stdsoap2.c:  soap->header = NULL;
./stdsoap2.c:  soap->fault = NULL;
./stdsoap2.c:  soap->master = SOAP_INVALID_SOCKET;
./stdsoap2.c:  soap->socket = SOAP_INVALID_SOCKET;
./stdsoap2.c:  soap->sendsk = SOAP_INVALID_SOCKET;
./stdsoap2.c:  soap->recvsk = SOAP_INVALID_SOCKET;
./stdsoap2.c:  soap->os = NULL;
./stdsoap2.c:  soap->is = NULL;
./stdsoap2.c:  soap->dom = NULL;
./stdsoap2.c:  soap->dime.list = NULL;
./stdsoap2.c:  soap->dime.first = NULL;
./stdsoap2.c:  soap->dime.last = NULL;
./stdsoap2.c:  soap->mime.list = NULL;
./stdsoap2.c:  soap->mime.first = NULL;
./stdsoap2.c:  soap->mime.last = NULL;
./stdsoap2.c:  soap->mime.boundary = NULL;
./stdsoap2.c:  soap->mime.start = NULL;
./stdsoap2.c:  soap->xlist = NULL;
./stdsoap2.c:  soap->recvfd = 0;
./stdsoap2.c:  soap->sendfd = 1;
./stdsoap2.c:  soap->recvfd = stdin;
./stdsoap2.c:  soap->sendfd = stdout;
./stdsoap2.c:  soap->host[0] = '\0';
./stdsoap2.c:  soap->path[0] = '\0';
./stdsoap2.c:  soap->port = 0;
./stdsoap2.c:  soap->action = NULL;
./stdsoap2.c:  soap->proxy_host = NULL;
./stdsoap2.c:  soap->proxy_port = 8080;
./stdsoap2.c:  soap->proxy_userid = NULL;
./stdsoap2.c:  soap->proxy_passwd = NULL;
./stdsoap2.c:  soap->proxy_from = NULL;
./stdsoap2.c:  soap->origin = NULL;
./stdsoap2.c:  soap->cors_origin = NULL;
./stdsoap2.c:  soap->cors_allow = "*";
./stdsoap2.c:  soap->cors_method = NULL;
./stdsoap2.c:  soap->cors_header = NULL;
./stdsoap2.c:  soap->cors_methods = NULL;
./stdsoap2.c:  soap->cors_headers = NULL;
./stdsoap2.c:  soap->prolog = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
./stdsoap2.c:  soap->zlib_state = SOAP_ZLIB_NONE;
./stdsoap2.c:  soap->zlib_in = SOAP_ZLIB_NONE;
./stdsoap2.c:  soap->zlib_out = SOAP_ZLIB_NONE;
./stdsoap2.c:  soap->d_stream = NULL;
./stdsoap2.c:  soap->z_buf = NULL;
./stdsoap2.c:  soap->z_level = 6;
./stdsoap2.c:  soap->z_dict = NULL;
./stdsoap2.c:  soap->z_dict_len = 0;
./stdsoap2.c:  soap->wsuid = NULL;
./stdsoap2.c:  soap->c14nexclude = NULL;
./stdsoap2.c:  soap->c14ninclude = NULL;
./stdsoap2.c:  soap->cookies = NULL;
./stdsoap2.c:  soap->cookie_domain = NULL;
./stdsoap2.c:  soap->cookie_path = NULL;
./stdsoap2.c:  soap->cookie_max = 32;
./stdsoap2.c:  soap->rpmreqid = NULL;
./stdsoap2.c:  soap->fsslauth = ssl_auth_init;
./stdsoap2.c:  soap->fsslverify = NULL;
./stdsoap2.c:  soap->bio = NULL;
./stdsoap2.c:  soap->ssl = NULL;
./stdsoap2.c:  soap->ctx = NULL;
./stdsoap2.c:  soap->session = NULL;
./stdsoap2.c:  soap->session_host[0] = '\0';
./stdsoap2.c:  soap->session_port = 443;
./stdsoap2.c:  soap->ssl_flags = SOAP_SSL_DEFAULT;
./stdsoap2.c:  soap->keyfile = NULL;
./stdsoap2.c:  soap->keyid = NULL;
./stdsoap2.c:  soap->password = NULL;
./stdsoap2.c:  soap->cafile = NULL;
./stdsoap2.c:  soap->capath = NULL;
./stdsoap2.c:  soap->crlfile = NULL;
./stdsoap2.c:  soap->dhfile = NULL;
./stdsoap2.c:  soap->randfile = NULL;
./stdsoap2.c:  soap->fsslauth = ssl_auth_init;
./stdsoap2.c:  soap->fsslverify = NULL;
./stdsoap2.c:  soap->xcred = NULL;
./stdsoap2.c:  soap->acred = NULL;
./stdsoap2.c:  soap->cache = NULL;
./stdsoap2.c:  soap->session = NULL;
./stdsoap2.c:  soap->ssl_flags = SOAP_SSL_DEFAULT;
./stdsoap2.c:  soap->keyfile = NULL;
./stdsoap2.c:  soap->keyid = NULL;
./stdsoap2.c:  soap->password = NULL;
./stdsoap2.c:  soap->cafile = NULL;
./stdsoap2.c:  soap->capath = NULL;
./stdsoap2.c:  soap->crlfile = NULL;
./stdsoap2.c:  soap->dh_params = NULL;
./stdsoap2.c:  soap->rsa_params = NULL;
./stdsoap2.c:  soap->fsslauth = ssl_auth_init;
./stdsoap2.c:  soap->fsslverify = NULL;
./stdsoap2.c:  soap->bio = NULL;
./stdsoap2.c:  soap->ssl = (gsk_handle)NULL;
./stdsoap2.c:  soap->ctx = (gsk_handle)NULL;
./stdsoap2.c:  soap->session = NULL;
./stdsoap2.c:  soap->ssl_flags = SOAP_SSL_DEFAULT;
./stdsoap2.c:  soap->keyfile = NULL;
./stdsoap2.c:  soap->keyid = NULL;
./stdsoap2.c:  soap->password = NULL;
./stdsoap2.c:  soap->cafile = NULL;
./stdsoap2.c:  soap->capath = NULL;
./stdsoap2.c:  soap->crlfile = NULL;
./stdsoap2.c:  soap->dhfile = NULL;
./stdsoap2.c:  soap->randfile = NULL;
./stdsoap2.c:  soap->c_locale = NULL;
./stdsoap2.c:  soap->buflen = 0;
./stdsoap2.c:  soap->bufidx = 0;
./stdsoap2.c:  soap->dime.chunksize = 0;
./stdsoap2.c:  soap->dime.buflen = 0;
./stdsoap2.c:  soap->other = 0;
./stdsoap2.c:  soap->root = -1;
./stdsoap2.c:  soap->null = 0;
./stdsoap2.c:  soap->position = 0;
./stdsoap2.c:  soap->encoding = 0;
./stdsoap2.c:  soap->mustUnderstand = 0;
./stdsoap2.c:  soap->ns = 0;
./stdsoap2.c:  soap->part = SOAP_END;
./stdsoap2.c:  soap->event = 0;
./stdsoap2.c:  soap->evlev = 0;
./stdsoap2.c:  soap->alloced = 0;
./stdsoap2.c:  soap->count = 0;
./stdsoap2.c:  soap->length = 0;
./stdsoap2.c:  soap->cdata = 0;
./stdsoap2.c:  soap->peeked = 0;
./stdsoap2.c:  soap->ahead = 0;
./stdsoap2.c:  soap->idnum = 0;
./stdsoap2.c:  soap->level = 0;
./stdsoap2.c:  soap->endpoint[0] = '\0';
./stdsoap2.c:  soap->status = 0;
./stdsoap2.c:  soap->error = SOAP_OK;
./stdsoap2.c:  soap->errmode = 0;
./stdsoap2.c:  soap->errnum = 0;
./stdsoap2.c:  if (!soap->keep_alive)
./stdsoap2.c:  { soap->buflen = 0;
./stdsoap2.c:    soap->bufidx = 0;
./stdsoap2.c:  soap->null = 0;
./stdsoap2.c:  soap->position = 0;
./stdsoap2.c:  soap->encoding = 0;
./stdsoap2.c:  soap->mustUnderstand = 0;
./stdsoap2.c:  soap->mode = 0;
./stdsoap2.c:  soap->ns = 0;
./stdsoap2.c:  soap->part = SOAP_END;
./stdsoap2.c:  soap->event = 0;
./stdsoap2.c:  soap->evlev = 0;
./stdsoap2.c:  soap->count = 0;
./stdsoap2.c:  soap->length = 0;
./stdsoap2.c:  soap->cdata = 0;
./stdsoap2.c:  soap->error = SOAP_OK;
./stdsoap2.c:  soap->peeked = 0;
./stdsoap2.c:  soap->ahead = 0;
./stdsoap2.c:  soap->idnum = 0;
./stdsoap2.c:  soap->level = 0;
./stdsoap2.c:  soap->endpoint[0] = '\0';
./stdsoap2.c:  soap->encodingStyle = SOAP_STR_EOS;
./stdsoap2.c:  soap->dime.chunksize = 0;
./stdsoap2.c:  soap->dime.buflen = 0;
./stdsoap2.c:  while (soap->clist)
./stdsoap2.c:  { struct soap_clist *cp = soap->clist->next;
./stdsoap2.c:    SOAP_FREE(soap, soap->clist);
./stdsoap2.c:    soap->clist = cp;
./stdsoap2.c:  if (soap->version != version && soap->local_namespaces && soap->local_namespaces[0].id && soap->local_namespaces[1].id)
./stdsoap2.c:    { soap->local_namespaces[0].ns = soap_env1;
./stdsoap2.c:      soap->local_namespaces[1].ns = soap_enc1;
./stdsoap2.c:    { soap->local_namespaces[0].ns = soap_env2;
./stdsoap2.c:      soap->local_namespaces[1].ns = soap_enc2;
./stdsoap2.c:    soap->version = version;
./stdsoap2.c:    soap->encodingStyle = SOAP_STR_EOS;
./stdsoap2.c:    soap->encodingStyle = NULL;
./stdsoap2.c:{ struct Namespace *p = soap->local_namespaces;
./stdsoap2.c:    { soap->version = 1; /* make sure we use SOAP 1.1 */
./stdsoap2.c:    { soap->version = 2; /* make sure we use SOAP 1.2 */
./stdsoap2.c:{ struct Namespace *ns = soap->local_namespaces;
./stdsoap2.c:  unsigned int level = soap->level;
./stdsoap2.c:  soap->namespaces = p;
./stdsoap2.c:  soap->local_namespaces = NULL;
./stdsoap2.c:  np = soap->nlist;
./stdsoap2.c:  soap->nlist = NULL;
./stdsoap2.c:    soap->level = np->level; /* preserve element nesting level */
./stdsoap2.c:  soap->level = level; /* restore level */
./stdsoap2.c:{ if (soap->namespaces && !soap->local_namespaces)
./stdsoap2.c:    for (ns1 = soap->namespaces; ns1->id; ns1++)
./stdsoap2.c:    { soap_memcpy((void*)ns2, n, (const void*)soap->namespaces, n);
./stdsoap2.c:          soap->version = 1;
./stdsoap2.c:          soap->version = 2;
./stdsoap2.c:      soap->local_namespaces = ns2;
./stdsoap2.c:  for (np = soap->nlist; np; np = np->next)
./stdsoap2.c:  if (soap_tagsearch(soap->c14nexclude, id))
./stdsoap2.c:  { for (np = soap->nlist; np; np = np->next)
./stdsoap2.c:    { if ((np->level < soap->level || !np->ns) && np->index == 1)
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Adding namespace binding (level=%u) '%s' '%s' utilized=%d\n", soap->level, id, ns ? ns : "(null)", utilized));
./stdsoap2.c:  { soap->error = SOAP_EOM;
./stdsoap2.c:  np->next = soap->nlist;
./stdsoap2.c:  soap->nlist = np;
./stdsoap2.c:  np->level = soap->level;
./stdsoap2.c:    { if (np->level == soap->level)
./stdsoap2.c:  { (void)soap_strncpy(soap->tmpbuf, sizeof(soap->tmpbuf), tag, n);
./stdsoap2.c:    soap_push_ns(soap, soap->tmpbuf, NULL, 1);
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Element begin tag='%s' level='%u' id='%d' type='%s'\n", tag, soap->level, id, type ? type : SOAP_STR_EOS));
./stdsoap2.c:  soap->level++;
./stdsoap2.c:  if (soap->level > soap->maxlevel)
./stdsoap2.c:    return soap->error = SOAP_LEVEL;
./stdsoap2.c:  if (soap_tagsearch(soap->wsuid, tag))
./stdsoap2.c:    for (s = tag, i = 0; *s && i < sizeof(soap->tag) - 1; s++, i++)
./stdsoap2.c:      soap->tag[i] = *s == ':' ? '-' : *s;
./stdsoap2.c:    soap->tag[i] = '\0';
./stdsoap2.c:    if (soap_set_attr(soap, "wsu:Id", soap->tag, 1))
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  if ((soap->mode & SOAP_XML_CANONICAL) && !(soap->mode & SOAP_DOM_ASIS))
./stdsoap2.c:  { if (soap->evlev >= soap->level)
./stdsoap2.c:      soap->evlev = 0;
./stdsoap2.c:    if (soap->event == SOAP_SEC_BEGIN && !soap->evlev)
./stdsoap2.c:      for (np = soap->nlist; np; np = np->next)
./stdsoap2.c:      { int p = soap_tagsearch(soap->c14ninclude, np->id) != NULL;
./stdsoap2.c:      soap->evlev = soap->level;
./stdsoap2.c:  if (soap->mode & SOAP_XML_DOM)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Adding DOM element tag='%s' %p (parent='%s' %p)\n", tag, elt, soap->dom ? soap->dom->name : "(null)", soap->dom));
./stdsoap2.c:    elt->prnt = soap->dom;
./stdsoap2.c:    if (soap->dom)
./stdsoap2.c:    { struct soap_dom_element *p = soap->dom->elts;
./stdsoap2.c:        soap->dom->elts = elt;
./stdsoap2.c:    soap->dom = elt;
./stdsoap2.c:    if (!soap->ns)
./stdsoap2.c:    { if (!(soap->mode & SOAP_XML_CANONICAL) && soap_send(soap, soap->prolog))
./stdsoap2.c:        return soap->error;
./stdsoap2.c:    else if (soap->mode & SOAP_XML_INDENT)
./stdsoap2.c:    { if (soap->ns == 1 && soap_send_raw(soap, soap_indent, soap->level < sizeof(soap_indent) ? soap->level : sizeof(soap_indent) - 1))
./stdsoap2.c:        return soap->error;
./stdsoap2.c:      soap->body = 1;
./stdsoap2.c:    if ((soap->mode & SOAP_XML_DEFAULTNS))
./stdsoap2.c:    { struct Namespace *ns = soap->local_namespaces;
./stdsoap2.c:        return soap->error;
./stdsoap2.c:      { if (soap->nlist && !strncmp(soap->nlist->id, tag, n) && !soap->nlist->id[n])
./stdsoap2.c:              return soap->error;
./stdsoap2.c:      else if (!soap->nlist || *soap->nlist->id)
./stdsoap2.c:          return soap->error;
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  if (!soap->ns)
./stdsoap2.c:  { struct Namespace *ns = soap->local_namespaces;
./stdsoap2.c:      if ((soap->mode & SOAP_XML_DEFAULTNS))
./stdsoap2.c:      { if (soap->version)
./stdsoap2.c:        else if (!(soap->mode & SOAP_XML_NOTYPE) || (soap->mode & SOAP_XML_NIL))
./stdsoap2.c:        { (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), strlen(ns->id) + 6), "xmlns:%s", ns->id);
./stdsoap2.c:          if (soap_attribute(soap, soap->tmpbuf, t))
./stdsoap2.c:            return soap->error;
./stdsoap2.c:  soap->ns = 1; /* namespace table control: ns = 0 or 2 to start, then 1 to stop dumping the table  */
./stdsoap2.c:  if ((soap->mode & SOAP_XML_CANONICAL))
./stdsoap2.c:  { (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), sizeof(SOAP_BASEREFNAME) + 20), SOAP_BASEREFNAME "%d", id);
./stdsoap2.c:    if (soap->version == 2)
./stdsoap2.c:    { if (soap_attribute(soap, "SOAP-ENC:id", soap->tmpbuf))
./stdsoap2.c:        return soap->error;
./stdsoap2.c:    else if (soap_attribute(soap, "id", soap->tmpbuf))
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  if (type && *type && !(soap->mode & SOAP_XML_NOTYPE))
./stdsoap2.c:    if ((soap->mode & SOAP_XML_DEFAULTNS))
./stdsoap2.c:    else if ((soap->mode & SOAP_XML_CANONICAL))
./stdsoap2.c:    if (soap->attributes ? soap_set_attr(soap, "xsi:type", t, 1) : soap_attribute(soap, "xsi:type", t))
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  if (soap->null && soap->position > 0 && soap->version == 1)
./stdsoap2.c:    (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf) - 1, 20), "[%d", soap->positions[0]);
./stdsoap2.c:    for (i = 1; i < soap->position; i++)
./stdsoap2.c:    { size_t l = strlen(soap->tmpbuf);
./stdsoap2.c:      (SOAP_SNPRINTF(soap->tmpbuf + l, sizeof(soap->tmpbuf) - l - 1, 20), ",%d", soap->positions[i]);
./stdsoap2.c:    (void)soap_strncat(soap->tmpbuf, sizeof(soap->tmpbuf), "]", 1);
./stdsoap2.c:    if (soap_attribute(soap, "SOAP-ENC:position", soap->tmpbuf))
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  if (soap->mustUnderstand)
./stdsoap2.c:  { if (soap->actor && *soap->actor)
./stdsoap2.c:    { if (soap_attribute(soap, soap->version == 2 ? "SOAP-ENV:role" : "SOAP-ENV:actor", soap->actor))
./stdsoap2.c:        return soap->error;
./stdsoap2.c:    if (soap_attribute(soap, "SOAP-ENV:mustUnderstand", soap->version == 2 ? "true" : "1"))
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    soap->mustUnderstand = 0;
./stdsoap2.c:  if (soap->encoding)
./stdsoap2.c:  { if (soap->encodingStyle && soap->local_namespaces && soap->local_namespaces[0].id && soap->local_namespaces[1].id)
./stdsoap2.c:    { if (!*soap->encodingStyle)
./stdsoap2.c:      { if (soap->local_namespaces[1].out)
./stdsoap2.c:          soap->encodingStyle = soap->local_namespaces[1].out;
./stdsoap2.c:          soap->encodingStyle = soap->local_namespaces[1].ns;
./stdsoap2.c:      if (soap->encodingStyle && soap_attribute(soap, "SOAP-ENV:encodingStyle", soap->encodingStyle))
./stdsoap2.c:        return soap->error;
./stdsoap2.c:      soap->encodingStyle = NULL;
./stdsoap2.c:    soap->encoding = 0;
./stdsoap2.c:  soap->null = 0;
./stdsoap2.c:  soap->position = 0;
./stdsoap2.c:  if (soap->event == SOAP_SEC_BEGIN)
./stdsoap2.c:    soap->event = 0;
./stdsoap2.c:  if (soap->feltbegout)
./stdsoap2.c:    return soap->error = soap->feltbegout(soap, tag, id, type);
./stdsoap2.c:    return soap->error;
./stdsoap2.c:{ if (!type || !*type || soap->version == 0)
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  if (soap->version == 1)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    if (s && (size_t)(s - type) < sizeof(soap->tmpbuf))
./stdsoap2.c:    { (void)soap_strncpy(soap->tmpbuf, sizeof(soap->tmpbuf), type, s - type);
./stdsoap2.c:      if (soap_attribute(soap, "SOAP-ENC:itemType", soap->tmpbuf))
./stdsoap2.c:        return soap->error;
./stdsoap2.c:      { soap_strcpy(soap->tmpbuf, sizeof(soap->tmpbuf), s);
./stdsoap2.c:        soap->tmpbuf[strlen(soap->tmpbuf) - 1] = '\0';
./stdsoap2.c:        if (soap_attribute(soap, "SOAP-ENC:arraySize", soap->tmpbuf))
./stdsoap2.c:          return soap->error;
./stdsoap2.c:  if ((soap->mode & SOAP_XML_CANONICAL))
./stdsoap2.c:  if ((soap->mode & SOAP_XML_CANONICAL))
./stdsoap2.c:    for (tp = soap->attributes; tp; tp = tp->next)
./stdsoap2.c:    for (np = soap->nlist; np; np = np->next)
./stdsoap2.c:    { if (np->ns && (np->index == 1 || (np->index == 0 && soap->event == SOAP_SEC_BEGIN && soap_tagsearch(soap->c14ninclude, np->id))))
./stdsoap2.c:          (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), strlen(np->id) + 6), "xmlns:%s", np->id);
./stdsoap2.c:          soap_strcpy(soap->tmpbuf, sizeof(soap->tmpbuf), "xmlns");
./stdsoap2.c:        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Enabling utilized binding (level=%u) %s='%s' c14ninclude='%s'\n", np->level, soap->tmpbuf, np->ns, soap->c14ninclude ? soap->c14ninclude : "(null)"));
./stdsoap2.c:        soap_set_attr(soap, soap->tmpbuf, np->ns, 1);
./stdsoap2.c:  if ((soap->mode & SOAP_XML_DOM) && soap->dom)
./stdsoap2.c:    att = &soap->dom->atts;
./stdsoap2.c:    for (tp = soap->attributes; tp; tp = tp->next)
./stdsoap2.c:          return soap->error;
./stdsoap2.c:  for (tp = soap->attributes; tp; tp = tp->next)
./stdsoap2.c:        return soap->error;
./stdsoap2.c:          return soap->error;
./stdsoap2.c:      else if (soap->mode & SOAP_XML_STRICT)
./stdsoap2.c:          return soap->error;
./stdsoap2.c:    if ((soap->mode & SOAP_XML_CANONICAL))
./stdsoap2.c:        return soap->error;
./stdsoap2.c:    if (soap->nlist)
./stdsoap2.c:    soap->level--;      /* decrement level just before /> */
./stdsoap2.c:    soap->body = 0;
./stdsoap2.c:  if (soap->feltendout)
./stdsoap2.c:    return soap->error = soap->feltendout(soap, tag);
./stdsoap2.c:  if ((soap->mode & SOAP_XML_DOM) && soap->dom)
./stdsoap2.c:  { if (soap->dom->prnt)
./stdsoap2.c:      soap->dom = soap->dom->prnt;
./stdsoap2.c:  if (soap->nlist)
./stdsoap2.c:  if (soap->mode & SOAP_XML_INDENT)
./stdsoap2.c:  { if (!soap->body)
./stdsoap2.c:    { if (soap_send_raw(soap, soap_indent, soap->level < sizeof(soap_indent) ? soap->level : sizeof(soap_indent) - 1))
./stdsoap2.c:        return soap->error;
./stdsoap2.c:    soap->body = 0;
./stdsoap2.c:  if ((soap->mode & SOAP_XML_DEFAULTNS) && (s = strchr(tag, ':')) != NULL)
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  soap->level--;        /* decrement level just before > */
./stdsoap2.c:  if (soap->version == 1)
./stdsoap2.c:  else if (soap->version == 2)
./stdsoap2.c:  (SOAP_SNPRINTF(soap->href, sizeof(soap->href), sizeof(SOAP_BASEREFNAME) + 21), "#" SOAP_BASEREFNAME "%d", href);
./stdsoap2.c:  return soap_element_href(soap, tag, id, s, soap->href + n);
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  soap->body = 0;
./stdsoap2.c:  for (tp = soap->attributes; tp; tp = tp->next)
./stdsoap2.c:  if (tp || (soap->version == 2 && soap->position > 0) || id > 0 || (soap->mode & SOAP_XML_NIL))
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    soap->body = 0;
./stdsoap2.c:  { soap->null = 1;
./stdsoap2.c:    soap->position = 0;
./stdsoap2.c:    soap->mustUnderstand = 0;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  { soap->error = soap_element_null(soap, tag, id, type);
./stdsoap2.c:  if ((!soap->encodingStyle && !(soap->omode & SOAP_XML_GRAPH)) || (soap->omode & SOAP_XML_TREE))
./stdsoap2.c:    if (soap->mode & SOAP_IO_LENGTH)
./stdsoap2.c:  if (mark || !(soap->mode & SOAP_XML_TREE))
./stdsoap2.c:    else if (!(soap->mode & SOAP_XML_TREE))
./stdsoap2.c:  return pp && pp->mark1 == 2 && (soap->mode & SOAP_XML_TREE);
./stdsoap2.c:{ if (soap->version == 2 && soap->encodingStyle)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  if (soap->version == 2 && soap->encodingStyle)
./stdsoap2.c:  if ((soap->mode & SOAP_XML_DOM) && !(soap->mode & SOAP_XML_CANONICAL) && soap->dom)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    a->next = soap->dom->atts;
./stdsoap2.c:    soap->dom->atts = a;
./stdsoap2.c:  if ((soap->mode & SOAP_XML_CANONICAL))
./stdsoap2.c:      return soap->error;
./stdsoap2.c:      return soap->error;
./stdsoap2.c:        return soap->error;
./stdsoap2.c:  { if (soap->other)
./stdsoap2.c:      return soap->error = SOAP_TAG_MISMATCH;
./stdsoap2.c:    soap->error = soap_match_tag(soap, soap->tag, tag);
./stdsoap2.c:    if (!soap->error)
./stdsoap2.c:    { soap->peeked = 0;
./stdsoap2.c:      if (type && *soap->type && soap_match_tag(soap, soap->type, type))
./stdsoap2.c:        return soap->error = SOAP_TYPE;
./stdsoap2.c:      if (!nillable && soap->null && (soap->mode & SOAP_XML_STRICT))
./stdsoap2.c:        return soap->error = SOAP_NULL;
./stdsoap2.c:      if (soap->body)
./stdsoap2.c:      { soap->level++;
./stdsoap2.c:        if (soap->level > soap->maxlevel)
./stdsoap2.c:          return soap->error = SOAP_LEVEL;
./stdsoap2.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Begin tag found (level=%u) '%s'='%s'\n", soap->level, soap->tag, tag ? tag : SOAP_STR_EOS ));
./stdsoap2.c:      soap->error = SOAP_OK;
./stdsoap2.c:  else if (soap->error == SOAP_NO_TAG && tag && *tag == '-')
./stdsoap2.c:    soap->error = SOAP_OK;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  if (soap->error == SOAP_NO_TAG)
./stdsoap2.c:    soap->error = SOAP_OK;
./stdsoap2.c:  if ((soap->mode & SOAP_XML_DOM) && soap->dom)
./stdsoap2.c:    if (!soap->peeked && !s)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    if (soap->dom->prnt)
./stdsoap2.c:      soap->dom = soap->dom->prnt;
./stdsoap2.c:    if ((soap->mode & SOAP_XML_STRICT))
./stdsoap2.c:          return soap->error = SOAP_SYNTAX_ERROR; /* reject mixed content before ending tag */
./stdsoap2.c:  if (soap->peeked)
./stdsoap2.c:  { if (*soap->tag)
./stdsoap2.c:    soap->peeked = 0;
./stdsoap2.c:        return soap->error = SOAP_CHK_EOF;
./stdsoap2.c:      { if ((soap->mode & SOAP_XML_STRICT))
./stdsoap2.c:          return soap->error = SOAP_SYNTAX_ERROR; /* reject mixed content before ending tag */
./stdsoap2.c:  s = soap->tag;
./stdsoap2.c:  n = sizeof(soap->tag);
./stdsoap2.c:    return soap->error = SOAP_CHK_EOF;
./stdsoap2.c:    return soap->error = SOAP_SYNTAX_ERROR;
./stdsoap2.c:  if (soap->feltendin)
./stdsoap2.c:  { soap->level--;
./stdsoap2.c:    return soap->error = soap->feltendin(soap, soap->tag, tag);
./stdsoap2.c:  if (tag && (soap->mode & SOAP_XML_STRICT))
./stdsoap2.c:    if (soap_match_tag(soap, soap->tag, tag))
./stdsoap2.c:    { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "End tag '%s' does not match '%s'\n", soap->tag, tag ? tag : SOAP_STR_EOS));
./stdsoap2.c:      return soap->error = SOAP_SYNTAX_ERROR;
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "End tag found (level=%u) '%s'='%s'\n", soap->level, soap->tag, tag ? tag : SOAP_STR_EOS));
./stdsoap2.c:  soap->level--;
./stdsoap2.c:  for (tp = soap->attributes; tp; tp = tp->next)
./stdsoap2.c:  { if (flag == 4 || (flag == 2 && (soap->mode & SOAP_XML_STRICT)))
./stdsoap2.c:      soap->error = SOAP_PROHIBITED;
./stdsoap2.c:  else if (flag == 3 || (flag == 1 && (soap->mode & SOAP_XML_STRICT)))
./stdsoap2.c:    soap->error = SOAP_REQUIRED;
./stdsoap2.c:    soap->error = SOAP_OK;
./stdsoap2.c:  for (tp = soap->attributes; tp; tq = tp, tp = tp->next)
./stdsoap2.c:      return soap->error = SOAP_EOM;
./stdsoap2.c:    if ((soap->mode & SOAP_XML_CANONICAL))
./stdsoap2.c:    { struct soap_attribute **tpp = &soap->attributes;
./stdsoap2.c:          for (tq = soap->attributes; tq; tq = tq->next)
./stdsoap2.c:    { tp->next = soap->attributes;
./stdsoap2.c:      soap->attributes = tp;
./stdsoap2.c:        return soap->error = SOAP_EOM;
./stdsoap2.c:    { soap->event = SOAP_SEC_BEGIN;
./stdsoap2.c:      soap_strcpy(soap->id, sizeof(soap->id), value);
./stdsoap2.c:    if ((soap->mode & SOAP_XML_CANONICAL))
./stdsoap2.c:        if (np && np->ns && soap->local_namespaces)
./stdsoap2.c:        { if ((!strcmp(s + 1, "type") && !strcmp(np->ns, soap->local_namespaces[2].ns)) /* xsi:type QName */
./stdsoap2.c:            || ((!strcmp(s + 1, "arrayType") || !strcmp(s + 1, "itemType")) && !strcmp(np->ns, soap->local_namespaces[1].ns))) /* SOAP-ENC:arrayType and SOAP-ENC:itemType QName */
./stdsoap2.c:  if ((soap->mode & SOAP_XML_CANONICAL))
./stdsoap2.c:  { while (soap->attributes)
./stdsoap2.c:    { tp = soap->attributes->next;
./stdsoap2.c:      if (soap->attributes->value)
./stdsoap2.c:        SOAP_FREE(soap, soap->attributes->value);
./stdsoap2.c:      SOAP_FREE(soap, soap->attributes);
./stdsoap2.c:      soap->attributes = tp;
./stdsoap2.c:  { for (tp = soap->attributes; tp; tp = tp->next)
./stdsoap2.c:    if ((soap->mode & SOAP_C_UTFSTRING))
./stdsoap2.c:          return soap->error = SOAP_EOM;
./stdsoap2.c:        return soap->error = SOAP_CHK_EOF;
./stdsoap2.c:  return soap->error = SOAP_EOM;
./stdsoap2.c:{ soap->labidx = 0;
./stdsoap2.c:{ if (soap->labidx + n >= soap->lablen)
./stdsoap2.c:  { char *t = soap->labbuf;
./stdsoap2.c:    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Enlarging look-aside buffer to append data, size=%lu\n", (unsigned long)soap->lablen));
./stdsoap2.c:    if (soap->lablen == 0)
./stdsoap2.c:      soap->lablen = SOAP_LABLEN;
./stdsoap2.c:    while (soap->labidx + n >= soap->lablen)
./stdsoap2.c:      soap->lablen <<= 1;
./stdsoap2.c:    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "New look-aside buffer size=%lu\n", (unsigned long)soap->lablen));
./stdsoap2.c:    soap->labbuf = (char*)SOAP_MALLOC(soap, soap->lablen);
./stdsoap2.c:    if (!soap->labbuf)
./stdsoap2.c:      return soap->error = SOAP_EOM;
./stdsoap2.c:    { soap_memcpy((void*)soap->labbuf, soap->lablen, (const void*)t, soap->labidx);
./stdsoap2.c:  { soap_memcpy((void*)(soap->labbuf + soap->labidx), soap->lablen - soap->labidx, (const void*)s, n);
./stdsoap2.c:    soap->labidx += n;
./stdsoap2.c:  if (soap->peeked)
./stdsoap2.c:  { if (!*soap->tag)
./stdsoap2.c:      return soap->error = SOAP_NO_TAG;
./stdsoap2.c:  soap->peeked = 1;
./stdsoap2.c:  soap->id[0] = '\0';
./stdsoap2.c:  soap->href[0] = '\0';
./stdsoap2.c:  soap->type[0] = '\0';
./stdsoap2.c:  soap->arrayType[0] = '\0';
./stdsoap2.c:  soap->arraySize[0] = '\0';
./stdsoap2.c:  soap->arrayOffset[0] = '\0';
./stdsoap2.c:  soap->other = 0;
./stdsoap2.c:  soap->root = -1;
./stdsoap2.c:  soap->position = 0;
./stdsoap2.c:  soap->null = 0;
./stdsoap2.c:  soap->mustUnderstand = 0;
./stdsoap2.c:      soap->mode &= ~SOAP_ENC_LATIN;
./stdsoap2.c:    return soap->error = SOAP_UTF_ERROR;
./stdsoap2.c:  { soap->labidx = 0;
./stdsoap2.c:        return soap->error;
./stdsoap2.c:      s = soap->labbuf + soap->labidx;
./stdsoap2.c:      i = soap->lablen - soap->labidx;
./stdsoap2.c:      soap->labidx = soap->lablen;
./stdsoap2.c:    lead = soap->labbuf;
./stdsoap2.c:  { *soap->tag = '\0';
./stdsoap2.c:      return soap->error = SOAP_CHK_EOF;
./stdsoap2.c:    if ((soap->mode & SOAP_XML_DOM) && soap->dom)
./stdsoap2.c:        soap->dom->tail = soap_strdup(soap, lead);
./stdsoap2.c:        soap->dom->tail = SOAP_STR_EOS; /* body with closing tag instead of <tag/> */
./stdsoap2.c:    return soap->error = SOAP_NO_TAG;
./stdsoap2.c:  s = soap->tag;
./stdsoap2.c:  i = sizeof(soap->tag);
./stdsoap2.c:  if (soap->mode & SOAP_XML_DOM)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    elt->prnt = soap->dom;
./stdsoap2.c:    elt->name = soap_strdup(soap, soap->tag);
./stdsoap2.c:    if (soap->dom)
./stdsoap2.c:    { struct soap_dom_element *p = soap->dom->elts;
./stdsoap2.c:        soap->dom->elts = elt;
./stdsoap2.c:    soap->dom = elt;
./stdsoap2.c:  for (tp = soap->attributes; tp; tp = tp->next)
./stdsoap2.c:  { s = soap->tmpbuf;
./stdsoap2.c:    i = sizeof(soap->tmpbuf);
./stdsoap2.c:    if (i == sizeof(soap->tmpbuf))
./stdsoap2.c:      return soap->error = SOAP_SYNTAX_ERROR;
./stdsoap2.c:         return soap->error;
./stdsoap2.c:       (*att)->name = soap_strdup(soap, soap->tmpbuf);
./stdsoap2.c:    if (!strncmp(soap->tmpbuf, "xmlns", 5))
./stdsoap2.c:    { if (soap->tmpbuf[5] == ':')
./stdsoap2.c:        t = soap->tmpbuf + 6;
./stdsoap2.c:      else if (soap->tmpbuf[5])
./stdsoap2.c:    for (tp = soap->attributes; tp; tq = tp, tp = tp->next)
./stdsoap2.c:    { if (!SOAP_STRCMP(tp->name, soap->tmpbuf))
./stdsoap2.c:    { size_t l = strlen(soap->tmpbuf);
./stdsoap2.c:        return soap->error = SOAP_EOM;
./stdsoap2.c:      soap_strcpy((char*)tp->name, l + 1, soap->tmpbuf);
./stdsoap2.c:      { tp->next = soap->attributes;
./stdsoap2.c:        soap->attributes = tp;
./stdsoap2.c:        if (soap->error != SOAP_EOM)
./stdsoap2.c:          return soap->error;
./stdsoap2.c:        soap->error = SOAP_OK;
./stdsoap2.c:          return soap->error;
./stdsoap2.c:        { k = soap->lablen - soap->labidx;
./stdsoap2.c:          if (soap_getattrval(soap, soap->labbuf + soap->labidx, &k, c))
./stdsoap2.c:          { if (soap->error != SOAP_EOM)
./stdsoap2.c:              return soap->error;
./stdsoap2.c:            soap->error = SOAP_OK;
./stdsoap2.c:            soap->labidx = soap->lablen;
./stdsoap2.c:              return soap->error;
./stdsoap2.c:        if (soap->labidx)
./stdsoap2.c:          tp->size = soap->lablen;
./stdsoap2.c:        { tp->size = strlen(soap->labbuf) + 1;
./stdsoap2.c:          return soap->error = SOAP_EOM;
./stdsoap2.c:        soap_strcpy(tp->value, tp->size, soap->labbuf);
./stdsoap2.c:        if (soap->error != SOAP_EOM)
./stdsoap2.c:          return soap->error;
./stdsoap2.c:        soap->error = SOAP_OK;
./stdsoap2.c:          return soap->error;
./stdsoap2.c:            return soap->error;
./stdsoap2.c:          { if (soap->error != SOAP_EOM)
./stdsoap2.c:              return soap->error;
./stdsoap2.c:            soap->error = SOAP_OK;
./stdsoap2.c:        k = tp->size + soap->blist->size;
./stdsoap2.c:          return soap->error = SOAP_EOM;
./stdsoap2.c:        return soap->error;
./stdsoap2.c:  { soap->dom->nstr = soap_current_namespace_tag(soap, soap->tag);
./stdsoap2.c:    for (att = &soap->dom->atts; *att; att = &(*att)->next)
./stdsoap2.c:    return soap->error = SOAP_CHK_EOF;
./stdsoap2.c:  soap->body = (c != '/');
./stdsoap2.c:  if (!soap->body)
./stdsoap2.c:  if (soap->mode & SOAP_XML_DOM)
./stdsoap2.c:  { if (!soap->body && soap->dom->prnt)
./stdsoap2.c:      soap->dom = soap->dom->prnt;
./stdsoap2.c:  for (tp = soap->attributes; tp; tp = tp->next)
./stdsoap2.c:      { if ((soap->version > 0 && !(soap->imode & SOAP_XML_TREE))
./stdsoap2.c:         || (soap->mode & SOAP_XML_GRAPH))
./stdsoap2.c:        { *soap->id = '#';
./stdsoap2.c:          soap_strcpy(soap->id + 1, sizeof(soap->id) - 1, tp->value);
./stdsoap2.c:      { if ((soap->version == 1 && !(soap->imode & SOAP_XML_TREE))
./stdsoap2.c:         || (soap->mode & SOAP_XML_GRAPH)
./stdsoap2.c:         || ((soap->mode & (SOAP_ENC_MTOM | SOAP_ENC_DIME)) && *tp->value != '#'))
./stdsoap2.c:          soap_strcpy(soap->href, sizeof(soap->href), tp->value);
./stdsoap2.c:      { if ((soap->version == 2 && !(soap->imode & SOAP_XML_TREE))
./stdsoap2.c:         || (soap->mode & SOAP_XML_GRAPH))
./stdsoap2.c:        { *soap->href = '#';
./stdsoap2.c:          soap_strcpy(soap->href + (*tp->value != '#'), sizeof(soap->href) - 1, tp->value);
./stdsoap2.c:      { if ((soap->mode & (SOAP_ENC_MTOM | SOAP_ENC_DIME)) && *tp->value != '#')
./stdsoap2.c:          soap_strcpy(soap->href, sizeof(soap->href), tp->value);
./stdsoap2.c:      { soap_strcpy(soap->type, sizeof(soap->type), tp->value);
./stdsoap2.c:      { soap->null = 1;
./stdsoap2.c:      { if (!soap->encodingStyle)
./stdsoap2.c:          soap->encodingStyle = SOAP_STR_EOS;
./stdsoap2.c:      else if (soap->version == 1)
./stdsoap2.c:          if (s && (size_t)(s - tp->value) < sizeof(soap->arrayType))
./stdsoap2.c:          { (void)soap_strncpy(soap->arrayType, sizeof(soap->arrayType), tp->value, s - tp->value);
./stdsoap2.c:            soap_strcpy(soap->arraySize, sizeof(soap->arraySize), s);
./stdsoap2.c:            soap_strcpy(soap->arrayType, sizeof(soap->arrayType), tp->value);
./stdsoap2.c:          soap_strcpy(soap->arrayOffset, sizeof(soap->arrayOffset), tp->value);
./stdsoap2.c:          soap->position = soap_getposition(tp->value, soap->positions);
./stdsoap2.c:          soap->root = ((!strcmp(tp->value, "1") || !strcmp(tp->value, "true")));
./stdsoap2.c:          soap->mustUnderstand = 1;
./stdsoap2.c:        { if ((!soap->actor || strcmp(soap->actor, tp->value))
./stdsoap2.c:            soap->other = 1;
./stdsoap2.c:      else if (soap->version == 2)
./stdsoap2.c:        { *soap->id = '#';
./stdsoap2.c:          soap_strcpy(soap->id + 1, sizeof(soap->id) - 1, tp->value);
./stdsoap2.c:        { *soap->href = '#';
./stdsoap2.c:          soap_strcpy(soap->href + (*tp->value != '#'), sizeof(soap->href) - 1, tp->value);
./stdsoap2.c:          soap_strcpy(soap->arrayType, sizeof(soap->arrayType), tp->value);
./stdsoap2.c:          soap_strcpy(soap->arraySize, sizeof(soap->arraySize), tp->value);
./stdsoap2.c:          soap->mustUnderstand = 1;
./stdsoap2.c:        { if ((!soap->actor || strcmp(soap->actor, tp->value))
./stdsoap2.c:           && strcmp(tp->value, "http://www.w3.org/2003/05/soap-envelope/role/next"))
./stdsoap2.c:            soap->other = 1;
./stdsoap2.c:          soap->mustUnderstand = 1;
./stdsoap2.c:  if (soap->feltbegin)
./stdsoap2.c:    return soap->error = soap->feltbegin(soap, soap->tag);
./stdsoap2.c:  return soap->error = SOAP_OK;
./stdsoap2.c:{ soap->error = SOAP_OK;
./stdsoap2.c:{ if (!soap->peeked)
./stdsoap2.c:  { soap->peeked = 1;
./stdsoap2.c:    if (soap->body)
./stdsoap2.c:      soap->level--;
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Reverting to last element '%s' (level=%u)\n", soap->tag, soap->level));
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Ignoring XML content at level=%u\n", soap->level));
./stdsoap2.c:  if ((soap->mode & SOAP_XML_DOM) && soap->dom)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  if ((soap->mode & SOAP_XML_DOM) && soap->dom)
./stdsoap2.c:  { soap->dom->text = soap_strdup(soap, s);
./stdsoap2.c:  if (flag == 2 || (soap->mode & SOAP_C_UTFSTRING))
./stdsoap2.c:          return soap->error;
./stdsoap2.c:      if (flag || !(soap->mode & SOAP_XML_CANONICAL))
./stdsoap2.c:          return soap->error;
./stdsoap2.c:        return soap->error;
./stdsoap2.c:        return soap->error;
./stdsoap2.c:          return soap->error;
./stdsoap2.c:          return soap->error;
./stdsoap2.c:        return soap->error;
./stdsoap2.c:      if (soap->mode & SOAP_C_MBSTRING)
./stdsoap2.c:            return soap->error;
./stdsoap2.c:          return soap->error;
./stdsoap2.c:  if (maxlen < 0 && soap->maxlength > 0)
./stdsoap2.c:    maxlen = soap->maxlength;
./stdsoap2.c:  if (flag <= 0 && soap->peeked && *soap->tag)
./stdsoap2.c:    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "String content includes tag '%s' and attributes\n", soap->tag));
./stdsoap2.c:    t = soap->tmpbuf;
./stdsoap2.c:    soap_strcpy(t + 1, sizeof(soap->tmpbuf) - 1, soap->tag);
./stdsoap2.c:    for (tp = soap->attributes; tp; tp = tp->next)
./stdsoap2.c:        if (t + l + 1 >= soap->tmpbuf + sizeof(soap->tmpbuf))
./stdsoap2.c:        (void)soap_strncpy(t, sizeof(soap->tmpbuf) - (t - soap->tmpbuf), tp->name, l);
./stdsoap2.c:          if (t + l + 3 >= soap->tmpbuf + sizeof(soap->tmpbuf))
./stdsoap2.c:          (void)soap_strncpy(t, sizeof(soap->tmpbuf) - (t - soap->tmpbuf), tp->value, l);
./stdsoap2.c:    if (!soap->body)
./stdsoap2.c:    t = soap->tmpbuf;
./stdsoap2.c:    m = (int)strlen(soap->tmpbuf);
./stdsoap2.c:    if (soap->body)
./stdsoap2.c:    soap->peeked = 0;
./stdsoap2.c:    soap->labidx = 0;                   /* use look-aside buffer */
./stdsoap2.c:      s = soap->labbuf + soap->labidx;  /* space to populate */
./stdsoap2.c:      k = soap->lablen - soap->labidx;  /* number of bytes available */
./stdsoap2.c:      soap->labidx = soap->lablen;      /* claim this space */
./stdsoap2.c:        if ((c >= 0x80 || c < SOAP_AP) && state != 1 && !(soap->mode & SOAP_ENC_LATIN))
./stdsoap2.c:          if ((c & 0x7FFFFFFF) >= 0x80 && (flag <= 0 || (soap->mode & SOAP_C_UTFSTRING)))
./stdsoap2.c:          if (soap->mode & SOAP_C_MBSTRING)
./stdsoap2.c:          soap->error = SOAP_LENGTH;
./stdsoap2.c:  soap->labidx = 0;                     /* use look-aside buffer */
./stdsoap2.c:    s = soap->labbuf + soap->labidx;    /* space to populate */
./stdsoap2.c:    k = soap->lablen - soap->labidx;    /* number of bytes available */
./stdsoap2.c:    soap->labidx = soap->lablen;        /* claim this space */
./stdsoap2.c:        if ((soap->mode & SOAP_C_UTFSTRING))
./stdsoap2.c:              soap->error = SOAP_LENGTH;
./stdsoap2.c:        if (soap->mode & SOAP_C_MBSTRING)
./stdsoap2.c:        soap->error = SOAP_LENGTH;
./stdsoap2.c:  t = soap_strdup(soap, soap->labbuf);
./stdsoap2.c:    soap->error = SOAP_LENGTH;
./stdsoap2.c:  if ((soap->mode & SOAP_XML_DOM) && soap->dom)
./stdsoap2.c:      soap->dom->text = t;
./stdsoap2.c:      soap->dom->code = t;
./stdsoap2.c:  else if (pattern && soap->fsvalidate)
./stdsoap2.c:  { soap->error = soap->fsvalidate(soap, pattern, t);
./stdsoap2.c:    if (soap->error)
./stdsoap2.c:  if ((soap->mode & SOAP_XML_DOM) && soap->dom)
./stdsoap2.c:  { soap->dom->text = soap_wchar2s(soap, s);
./stdsoap2.c:      if (flag || !(soap->mode & SOAP_XML_CANONICAL))
./stdsoap2.c:          return soap->error;
./stdsoap2.c:          return soap->error;
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  if (maxlen < 0 && soap->maxlength > 0)
./stdsoap2.c:    maxlen = soap->maxlength;
./stdsoap2.c:  if (flag <= 0 && soap->peeked && *soap->tag)
./stdsoap2.c:    t = soap->tmpbuf;
./stdsoap2.c:    soap_strcpy(t + 1, sizeof(soap->tmpbuf) - 1, soap->tag);
./stdsoap2.c:    for (tp = soap->attributes; tp; tp = tp->next)
./stdsoap2.c:        if (t + l + 1 >= soap->tmpbuf + sizeof(soap->tmpbuf))
./stdsoap2.c:        (void)soap_strncpy(t, sizeof(soap->tmpbuf) - (t - soap->tmpbuf), tp->name, l);
./stdsoap2.c:          if (t + l + 3 >= soap->tmpbuf + sizeof(soap->tmpbuf))
./stdsoap2.c:          (void)soap_strncpy(t, sizeof(soap->tmpbuf) - (t - soap->tmpbuf), tp->value, l);
./stdsoap2.c:    if (!soap->body)
./stdsoap2.c:    t = soap->tmpbuf;
./stdsoap2.c:    if (soap->body)
./stdsoap2.c:    soap->peeked = 0;
./stdsoap2.c:        soap->error = SOAP_LENGTH;
./stdsoap2.c:    soap->error = SOAP_LENGTH;
./stdsoap2.c:  if (pattern && soap->fwvalidate)
./stdsoap2.c:  { soap->error = soap->fwvalidate(soap, pattern, s);
./stdsoap2.c:    if (soap->error)
./stdsoap2.c:  if ((soap->mode & SOAP_XML_DOM) && soap->dom)
./stdsoap2.c:    soap->dom->text = soap_wchar2s(soap, s);
./stdsoap2.c:    return soap->error;
./stdsoap2.c:      soap->error = SOAP_TYPE;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  if (*soap->type
./stdsoap2.c:   && soap_match_tag(soap, soap->type, type)
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":int")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":short")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":byte"))
./stdsoap2.c:  { soap->error = SOAP_TYPE;
./stdsoap2.c:  p = (int*)soap_id_enter(soap, soap->id, p, t, sizeof(int), NULL, NULL, NULL, NULL);
./stdsoap2.c:  if (*soap->href)
./stdsoap2.c:    p = (int*)soap_id_forward(soap, soap->href, p, 0, t, t, sizeof(int), 0, NULL, NULL);
./stdsoap2.c:  if (soap->body && soap_element_end_in(soap, tag))
./stdsoap2.c:{ (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), 20), "%ld", n);
./stdsoap2.c:  return soap->tmpbuf;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:      soap->error = SOAP_TYPE;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  if (*soap->type
./stdsoap2.c:   && soap_match_tag(soap, soap->type, type)
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":int")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":short")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":byte"))
./stdsoap2.c:  { soap->error = SOAP_TYPE;
./stdsoap2.c:  p = (long*)soap_id_enter(soap, soap->id, p, t, sizeof(long), NULL, NULL, NULL, NULL);
./stdsoap2.c:  if (*soap->href)
./stdsoap2.c:    p = (long*)soap_id_forward(soap, soap->href, p, 0, t, t, sizeof(long), 0, NULL, NULL);
./stdsoap2.c:  if (soap->body && soap_element_end_in(soap, tag))
./stdsoap2.c:{ (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), 20), SOAP_LONG_FORMAT, n);
./stdsoap2.c:  return soap->tmpbuf;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:      soap->error = SOAP_TYPE;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  if (*soap->type
./stdsoap2.c:   && soap_match_tag(soap, soap->type, type)
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":integer")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":positiveInteger")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":negativeInteger")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":nonPositiveInteger")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":nonNegativeInteger")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":long")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":int")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":short")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":byte"))
./stdsoap2.c:  { soap->error = SOAP_TYPE;
./stdsoap2.c:  p = (LONG64*)soap_id_enter(soap, soap->id, p, t, sizeof(LONG64), NULL, NULL, NULL, NULL);
./stdsoap2.c:  if (*soap->href)
./stdsoap2.c:    p = (LONG64*)soap_id_forward(soap, soap->href, p, 0, t, t, sizeof(LONG64), 0, NULL, NULL);
./stdsoap2.c:  if (soap->body && soap_element_end_in(soap, tag))
./stdsoap2.c:    return soap->error;
./stdsoap2.c:      soap->error = SOAP_TYPE;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  if (*soap->type
./stdsoap2.c:   && soap_match_tag(soap, soap->type, type)
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":byte"))
./stdsoap2.c:  { soap->error = SOAP_TYPE;
./stdsoap2.c:  p = (char*)soap_id_enter(soap, soap->id, p, t, sizeof(char), NULL, NULL, NULL, NULL);
./stdsoap2.c:  if (*soap->href)
./stdsoap2.c:    p = (char*)soap_id_forward(soap, soap->href, p, 0, t, t, sizeof(char), 0, NULL, NULL);
./stdsoap2.c:  if (soap->body && soap_element_end_in(soap, tag))
./stdsoap2.c:    return soap->error;
./stdsoap2.c:      soap->error = SOAP_TYPE;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  if (*soap->type
./stdsoap2.c:   && soap_match_tag(soap, soap->type, type)
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":short")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":byte"))
./stdsoap2.c:  { soap->error = SOAP_TYPE;
./stdsoap2.c:  p = (short*)soap_id_enter(soap, soap->id, p, t, sizeof(short), NULL, NULL, NULL, NULL);
./stdsoap2.c:  if (*soap->href)
./stdsoap2.c:    p = (short*)soap_id_forward(soap, soap->href, p, 0, t, t, sizeof(short), 0, NULL, NULL);
./stdsoap2.c:  if (soap->body && soap_element_end_in(soap, tag))
./stdsoap2.c:  _sprintf_s_l(soap->tmpbuf, _countof(soap->tmpbuf), soap->float_format, SOAP_LOCALE(soap), n);
./stdsoap2.c:  (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), 20), soap->float_format, n);
./stdsoap2.c:  (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), 20), soap->float_format, n);
./stdsoap2.c:  s = strchr(soap->tmpbuf, ',');        /* convert decimal comma to DP */
./stdsoap2.c:  return soap->tmpbuf;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:      return soap->error = SOAP_TYPE;
./stdsoap2.c:        soap->error = SOAP_TYPE;
./stdsoap2.c:        soap->error = SOAP_TYPE;
./stdsoap2.c:        soap->error = SOAP_TYPE;
./stdsoap2.c:        soap->error = SOAP_TYPE;
./stdsoap2.c:        soap->error = SOAP_TYPE;
./stdsoap2.c:        soap->error = SOAP_TYPE;
./stdsoap2.c:      soap->error = SOAP_TYPE;
./stdsoap2.c:        soap->error = SOAP_TYPE;
./stdsoap2.c:        soap->error = SOAP_TYPE;
./stdsoap2.c:        soap->error = SOAP_TYPE;
./stdsoap2.c:      soap->error = SOAP_TYPE;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:{ if (soap_match_tag(soap, soap->type, type)
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":float")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":double")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":decimal")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":integer")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":positiveInteger")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":negativeInteger")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":nonPositiveInteger")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":nonNegativeInteger")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":long")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":int")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":short")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":byte")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":unsignedLong")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":unsignedInt")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":unsignedShort")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":unsignedByte"))
./stdsoap2.c:  { soap->error = SOAP_TYPE;
./stdsoap2.c:  if (*soap->type != '\0' && soap_isnumeric(soap, type))
./stdsoap2.c:  p = (float*)soap_id_enter(soap, soap->id, p, t, sizeof(float), NULL, NULL, NULL, NULL);
./stdsoap2.c:  if (*soap->href)
./stdsoap2.c:    p = (float*)soap_id_forward(soap, soap->href, p, 0, t, t, sizeof(float), 0, NULL, NULL);
./stdsoap2.c:  if (soap->body && soap_element_end_in(soap, tag))
./stdsoap2.c:  _sprintf_s_l(soap->tmpbuf, _countof(soap->tmpbuf), soap->double_format, SOAP_LOCALE(soap), n);
./stdsoap2.c:  (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), 40), soap->double_format, n);
./stdsoap2.c:  (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), 40), soap->double_format, n);
./stdsoap2.c:  s = strchr(soap->tmpbuf, ',');        /* convert decimal comma to DP */
./stdsoap2.c:  return soap->tmpbuf;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:      return soap->error = SOAP_TYPE;
./stdsoap2.c:        soap->error = SOAP_TYPE;
./stdsoap2.c:        soap->error = SOAP_TYPE;
./stdsoap2.c:        soap->error = SOAP_TYPE;
./stdsoap2.c:      soap->error = SOAP_TYPE;
./stdsoap2.c:        soap->error = SOAP_TYPE;
./stdsoap2.c:        soap->error = SOAP_TYPE;
./stdsoap2.c:      soap->error = SOAP_TYPE;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  if (*soap->type != '\0' && soap_isnumeric(soap, type))
./stdsoap2.c:  p = (double*)soap_id_enter(soap, soap->id, p, t, sizeof(double), NULL, NULL, NULL, NULL);
./stdsoap2.c:  if (*soap->href)
./stdsoap2.c:    p = (double*)soap_id_forward(soap, soap->href, p, 0, t, t, sizeof(double), 0, NULL, NULL);
./stdsoap2.c:  if (soap->body && soap_element_end_in(soap, tag))
./stdsoap2.c:    return soap->error;
./stdsoap2.c:      soap->error = SOAP_TYPE;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  if (*soap->type
./stdsoap2.c:   && soap_match_tag(soap, soap->type, type)
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":unsignedByte"))
./stdsoap2.c:  { soap->error = SOAP_TYPE;
./stdsoap2.c:  p = (unsigned char*)soap_id_enter(soap, soap->id, p, t, sizeof(unsigned char), NULL, NULL, NULL, NULL);
./stdsoap2.c:  if (*soap->href)
./stdsoap2.c:    p = (unsigned char*)soap_id_forward(soap, soap->href, p, 0, t, t, sizeof(unsigned char), 0, NULL, NULL);
./stdsoap2.c:  if (soap->body && soap_element_end_in(soap, tag))
./stdsoap2.c:    return soap->error;
./stdsoap2.c:      soap->error = SOAP_TYPE;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  if (*soap->type
./stdsoap2.c:   && soap_match_tag(soap, soap->type, type)
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":unsignedShort")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":unsignedByte"))
./stdsoap2.c:  { soap->error = SOAP_TYPE;
./stdsoap2.c:  p = (unsigned short*)soap_id_enter(soap, soap->id, p, t, sizeof(unsigned short), NULL, NULL, NULL, NULL);
./stdsoap2.c:  if (*soap->href)
./stdsoap2.c:    p = (unsigned short*)soap_id_forward(soap, soap->href, p, 0, t, t, sizeof(unsigned short), 0, NULL, NULL);
./stdsoap2.c:  if (soap->body && soap_element_end_in(soap, tag))
./stdsoap2.c:    return soap->error;
./stdsoap2.c:      soap->error = SOAP_TYPE;
./stdsoap2.c:      return soap->error = SOAP_TYPE;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  if (*soap->type
./stdsoap2.c:   && soap_match_tag(soap, soap->type, type)
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":unsignedInt")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":unsignedShort")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":unsignedByte"))
./stdsoap2.c:  { soap->error = SOAP_TYPE;
./stdsoap2.c:  p = (unsigned int*)soap_id_enter(soap, soap->id, p, t, sizeof(unsigned int), NULL, NULL, NULL, NULL);
./stdsoap2.c:  if (*soap->href)
./stdsoap2.c:    p = (unsigned int*)soap_id_forward(soap, soap->href, p, 0, t, t, sizeof(unsigned int), 0, NULL, NULL);
./stdsoap2.c:  if (soap->body && soap_element_end_in(soap, tag))
./stdsoap2.c:{ (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), 20), "%lu", n);
./stdsoap2.c:  return soap->tmpbuf;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:      soap->error = SOAP_TYPE;
./stdsoap2.c:      return soap->error = SOAP_TYPE;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  if (*soap->type
./stdsoap2.c:   && soap_match_tag(soap, soap->type, type)
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":unsignedInt")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":unsignedShort")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":unsignedByte"))
./stdsoap2.c:  { soap->error = SOAP_TYPE;
./stdsoap2.c:  p = (unsigned long*)soap_id_enter(soap, soap->id, p, t, sizeof(unsigned long), NULL, NULL, NULL, NULL);
./stdsoap2.c:  if (*soap->href)
./stdsoap2.c:    p = (unsigned long*)soap_id_forward(soap, soap->href, p, 0, t, t, sizeof(unsigned long), 0, NULL, NULL);
./stdsoap2.c:  if (soap->body && soap_element_end_in(soap, tag))
./stdsoap2.c:{ (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), 20), SOAP_ULONG_FORMAT, n);
./stdsoap2.c:  return soap->tmpbuf;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:      soap->error = SOAP_TYPE;
./stdsoap2.c:      return soap->error = SOAP_TYPE;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  if (*soap->type
./stdsoap2.c:   && soap_match_tag(soap, soap->type, type)
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":positiveInteger")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":nonNegativeInteger")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":unsignedLong")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":unsignedInt")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":unsignedShort")
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":unsignedByte"))
./stdsoap2.c:  { soap->error = SOAP_TYPE;
./stdsoap2.c:  p = (ULONG64*)soap_id_enter(soap, soap->id, p, t, sizeof(ULONG64), NULL, NULL, NULL, NULL);
./stdsoap2.c:  if (*soap->href)
./stdsoap2.c:    p = (ULONG64*)soap_id_forward(soap, soap->href, p, 0, t, t, sizeof(ULONG64), 0, NULL, NULL);
./stdsoap2.c:  if (soap->body && soap_element_end_in(soap, tag))
./stdsoap2.c:      return soap->error = SOAP_EOM;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  { if (maxlen < 0 && soap->maxlength > 0)
./stdsoap2.c:      maxlen = soap->maxlength;
./stdsoap2.c:      if ((soap->mode & SOAP_C_UTFSTRING))
./stdsoap2.c:      { soap->error = SOAP_LENGTH;
./stdsoap2.c:    if (pattern && soap->fsvalidate)
./stdsoap2.c:    { soap->error = soap->fsvalidate(soap, pattern, s);
./stdsoap2.c:      if (soap->error)
./stdsoap2.c:      return soap->error = SOAP_EOM;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:    if (maxlen < 0 && soap->maxlength > 0)
./stdsoap2.c:      maxlen = soap->maxlength;
./stdsoap2.c:      if ((soap->mode & SOAP_C_UTFSTRING))
./stdsoap2.c:      { soap->error = SOAP_LENGTH;
./stdsoap2.c:    soap->labidx = 0;
./stdsoap2.c:      np = soap->nlist;
./stdsoap2.c:        { if (np->index >= 0 && soap->local_namespaces && (q = soap->local_namespaces[np->index].id) != NULL)
./stdsoap2.c:              r = soap->local_namespaces[np->index].ns;
./stdsoap2.c:            soap->error = SOAP_NAMESPACE;
./stdsoap2.c:        { soap->error = SOAP_EOM;
./stdsoap2.c:        { soap->error = SOAP_EOM;
./stdsoap2.c:    b = soap->labbuf;
./stdsoap2.c:    if (pattern && soap->fsvalidate)
./stdsoap2.c:    { soap->error = soap->fsvalidate(soap, pattern, b);
./stdsoap2.c:      if (soap->error)
./stdsoap2.c:    soap->labidx = 0;
./stdsoap2.c:        soap->labbuf[soap->labidx > 0 ? soap->labidx - 1 : 0] = '\0';
./stdsoap2.c:        if ((soap->mode & SOAP_XML_CANONICAL))
./stdsoap2.c:        if ((soap->mode & SOAP_XML_DEFAULTNS))
./stdsoap2.c:          if (r && soap->nlist && !strncmp(soap->nlist->id, s, r - s) && !soap->nlist->id[r - s])
./stdsoap2.c:        { struct Namespace *p = soap->local_namespaces;
./stdsoap2.c:            if ((soap->mode & SOAP_XML_DEFAULTNS) && soap->nlist && !strcmp(soap->nlist->id, r))
./stdsoap2.c:            (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), 27), "xmlns:_%d", soap->idnum++);
./stdsoap2.c:            soap_set_attr(soap, soap->tmpbuf, x, 1);
./stdsoap2.c:            r = soap->tmpbuf + 6;
./stdsoap2.c:      { soap->error = SOAP_EOM;
./stdsoap2.c:      { soap->error = SOAP_EOM;
./stdsoap2.c:        { soap->error = SOAP_EOM;
./stdsoap2.c:    t = soap_strdup(soap, soap->labbuf);
./stdsoap2.c:      return soap->error = SOAP_EOM;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:    if (maxlen < 0 && soap->maxlength > 0)
./stdsoap2.c:      maxlen = soap->maxlength;
./stdsoap2.c:    soap->labidx = 0;
./stdsoap2.c:    if (soap->mode & SOAP_ENC_LATIN)
./stdsoap2.c:      r = (wchar_t*)soap->labbuf;
./stdsoap2.c:    l = (long)(soap->labidx / sizeof(wchar_t));
./stdsoap2.c:    { soap->error = SOAP_LENGTH;
./stdsoap2.c:    if (pattern && soap->fwvalidate)
./stdsoap2.c:    { soap->error = soap->fwvalidate(soap, pattern, (wchar_t*)soap->labbuf);
./stdsoap2.c:      if (soap->error)
./stdsoap2.c:    return (wchar_t*)soap->labbuf;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  if (!**p && (soap->mode & SOAP_C_NILSTRING))
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  { if (!tag || *tag != '-' || soap->error != SOAP_NO_TAG)
./stdsoap2.c:    soap->error = SOAP_OK;
./stdsoap2.c:  if (soap->null)
./stdsoap2.c:  else if (soap->body)
./stdsoap2.c:    if (!*p || !(char*)soap_id_enter(soap, soap->id, *p, t, sizeof(char*), NULL, NULL, NULL, NULL))
./stdsoap2.c:    { soap->error = SOAP_NO_TAG;
./stdsoap2.c:  { soap->error = SOAP_NO_TAG;
./stdsoap2.c:  else if (!*soap->href)
./stdsoap2.c:    { soap->error = SOAP_LENGTH;
./stdsoap2.c:  if (*soap->href)
./stdsoap2.c:    p = (char**)soap_id_lookup(soap, soap->href, (void**)p, t, sizeof(char**), 0, NULL);
./stdsoap2.c:  if (soap->body && soap_element_end_in(soap, tag))
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  if (!**p && (soap->mode & SOAP_C_NILSTRING))
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  { if (!tag || *tag != '-' || soap->error != SOAP_NO_TAG)
./stdsoap2.c:    soap->error = SOAP_OK;
./stdsoap2.c:  if (soap->null)
./stdsoap2.c:  else if (soap->body)
./stdsoap2.c:    if (!*p || !(wchar_t*)soap_id_enter(soap, soap->id, *p, t, sizeof(wchar_t*), NULL, NULL, NULL, NULL))
./stdsoap2.c:    { soap->error = SOAP_NO_TAG;
./stdsoap2.c:  { soap->error = SOAP_NO_TAG;
./stdsoap2.c:  else if (!*soap->href)
./stdsoap2.c:    { soap->error = SOAP_LENGTH;
./stdsoap2.c:  if (*soap->href)
./stdsoap2.c:    p = (wchar_t**)soap_id_lookup(soap, soap->href, (void**)p, t, sizeof(wchar_t**), 0, NULL);
./stdsoap2.c:  if (soap->body && soap_element_end_in(soap, tag))
./stdsoap2.c:    l = strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%SZ", pT);
./stdsoap2.c:    l = strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%SZ", pT);
./stdsoap2.c:  { l = strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S%z", pT);
./stdsoap2.c:    { soap_memmove(soap->tmpbuf + 23, sizeof(soap->tmpbuf) - 23, soap->tmpbuf + 22, 3); /* 2000-03-01T02:00:00+0300 */
./stdsoap2.c:      soap->tmpbuf[22] = ':';                                                           /* 2000-03-01T02:00:00+03:00 */
./stdsoap2.c:  { l = strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S%z", pT);
./stdsoap2.c:    { soap_memmove(soap->tmpbuf + 23, sizeof(soap->tmpbuf) - 23, soap->tmpbuf + 22, 3); /* 2000-03-01T02:00:00+0300 */
./stdsoap2.c:      soap->tmpbuf[22] = ':';                                                           /* 2000-03-01T02:00:00+03:00 */
./stdsoap2.c:    l = strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);
./stdsoap2.c:      (SOAP_SNPRINTF(soap->tmpbuf + l, sizeof(soap->tmpbuf) - l, 7), "%+03d:%02d", -tz.tz_minuteswest/60+(pT->tm_isdst!=0), abs(tz.tz_minuteswest)%60);
./stdsoap2.c:    l = strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);
./stdsoap2.c:      (SOAP_SNPRINTF(soap->tmpbuf + l, sizeof(soap->tmpbuf) - l, 7), "%+03d:%02d", -tz.tz_minuteswest/60+(pT->tm_isdst!=0), abs(tz.tz_minuteswest)%60);
./stdsoap2.c:    l = strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);
./stdsoap2.c:      (SOAP_SNPRINTF(soap->tmpbuf + l, sizeof(soap->tmpbuf) - l, 7), "%+03d:%02d", -t.timezone/60+(pT->tm_isdst!=0), abs(t.timezone)%60);
./stdsoap2.c:    l = strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);
./stdsoap2.c:      (SOAP_SNPRINTF(soap->tmpbuf + l, sizeof(soap->tmpbuf) - l, 7), "%+03d:%02d", -t.timezone/60+(pT->tm_isdst!=0), abs(t.timezone)%60);
./stdsoap2.c:    l = strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);
./stdsoap2.c:    l = strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);
./stdsoap2.c:    soap_strcpy(soap->tmpbuf, sizeof(soap->tmpbuf), "1969-12-31T23:59:59Z");
./stdsoap2.c:  return soap->tmpbuf;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:    else if (!(soap->mode & SOAP_XML_STRICT))
./stdsoap2.c:      return soap->error = SOAP_TYPE;
./stdsoap2.c:    if (*t == 'T' || ((*t == 't' || *t == ' ') && !(soap->mode & SOAP_XML_STRICT)))
./stdsoap2.c:      else if (!(soap->mode & SOAP_XML_STRICT))
./stdsoap2.c:        return soap->error = SOAP_TYPE;
./stdsoap2.c:    if (*t == ' ' && !(soap->mode & SOAP_XML_STRICT))
./stdsoap2.c:        else if (!(soap->mode & SOAP_XML_STRICT))
./stdsoap2.c:          return soap->error = SOAP_TYPE;
./stdsoap2.c:        return soap->error = SOAP_TYPE;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  if (*soap->type
./stdsoap2.c:   && soap_match_tag(soap, soap->type, type)
./stdsoap2.c:   && soap_match_tag(soap, soap->type, ":dateTime"))
./stdsoap2.c:  { soap->error = SOAP_TYPE;
./stdsoap2.c:  p = (time_t*)soap_id_enter(soap, soap->id, p, t, sizeof(time_t), NULL, NULL, NULL, NULL);
./stdsoap2.c:  if (*soap->href)
./stdsoap2.c:    p = (time_t*)soap_id_forward(soap, soap->href, p, 0, t, t, sizeof(time_t), 0, NULL, NULL);
./stdsoap2.c:  if (soap->body && soap_element_end_in(soap, tag))
./stdsoap2.c:      return soap->error;
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  { if (soap->error != SOAP_NO_TAG || soap_peek(soap) == SOAP_TT)
./stdsoap2.c:    soap->error = SOAP_OK;
./stdsoap2.c:  if (soap->body || (tag && *tag == '-'))
./stdsoap2.c:    { soap->error = SOAP_NO_TAG;
./stdsoap2.c:  else if (soap->null)
./stdsoap2.c:  if (soap->body && soap_element_end_in(soap, tag))
./stdsoap2.c:      return soap->error;
./stdsoap2.c:        return soap->error;
./stdsoap2.c:  { if (soap->error != SOAP_NO_TAG || soap_peek(soap) == SOAP_TT)
./stdsoap2.c:    soap->error = SOAP_OK;
./stdsoap2.c:  if (soap->body)
./stdsoap2.c:    { soap->error = SOAP_NO_TAG;
./stdsoap2.c:  { soap->error = SOAP_NO_TAG;
./stdsoap2.c:  else if (soap->null)
./stdsoap2.c:  if (soap->body && soap_element_end_in(soap, tag))
./stdsoap2.c:  char *s = soap->tmpbuf;
./stdsoap2.c:  if (!soap->body)
./stdsoap2.c:  for (i = 0; i < sizeof(soap->tmpbuf) - 1; i++)
./stdsoap2.c:  soap->tmpbuf[sizeof(soap->tmpbuf) - 1] = '\0'; /* appease */
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Element content value='%s'\n", soap->tmpbuf));
./stdsoap2.c:  { soap->error = SOAP_LENGTH;
./stdsoap2.c:  if ((soap->mode & SOAP_XML_DOM) && soap->dom)
./stdsoap2.c:    soap->dom->text = soap_strdup(soap, soap->tmpbuf);
./stdsoap2.c:  return soap->tmpbuf; /* return non-null pointer */
./stdsoap2.c:        return soap->error = SOAP_CHK_EOF;
./stdsoap2.c:      return soap->error = SOAP_CHK_EOF;
./stdsoap2.c:      return soap->error = SOAP_HDR;
./stdsoap2.c:  size_t count = soap->count;
./stdsoap2.c:  if ((soap->mode & SOAP_ENC_DIME) && !(soap->mode & SOAP_ENC_MTOM))
./stdsoap2.c:    for (content = soap->dime.first; content; content = content->next)
./stdsoap2.c:  if ((soap->mode & SOAP_ENC_MIME) && soap->mime.boundary)
./stdsoap2.c:  { size_t n = strlen(soap->mime.boundary);
./stdsoap2.c:    for (content = soap->mime.first; content; content = content->next)
./stdsoap2.c:  return soap->count;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Put DIME header id='%s'\n", soap->dime.id ? soap->dime.id : SOAP_STR_EOS));
./stdsoap2.c:  if (soap->dime.options)
./stdsoap2.c:    optlen = (((unsigned char)soap->dime.options[2] << 8) | ((unsigned char)soap->dime.options[3])) + 4;
./stdsoap2.c:  if (soap->dime.id)
./stdsoap2.c:  { idlen = strlen(soap->dime.id);
./stdsoap2.c:  if (soap->dime.type)
./stdsoap2.c:  { typelen = strlen(soap->dime.type);
./stdsoap2.c:  tmp[0] = SOAP_DIME_VERSION | (soap->dime.flags & 0x7);
./stdsoap2.c:  tmp[1] = soap->dime.flags & 0xF0;
./stdsoap2.c:  tmp[8] = (char)(soap->dime.size >> 24);
./stdsoap2.c:  tmp[9] = (char)((soap->dime.size >> 16) & 0xFF);
./stdsoap2.c:  tmp[10] = (char)((soap->dime.size >> 8) & 0xFF);
./stdsoap2.c:  tmp[11] = (char)(soap->dime.size & 0xFF);
./stdsoap2.c:   || soap_putdimefield(soap, soap->dime.options, optlen)
./stdsoap2.c:   || soap_putdimefield(soap, soap->dime.id, idlen)
./stdsoap2.c:   || soap_putdimefield(soap, soap->dime.type, typelen))
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  if (!(soap->mode & SOAP_ENC_DIME))
./stdsoap2.c:  for (content = soap->dime.first; content; content = content->next)
./stdsoap2.c:    soap->dime.size = content->size;
./stdsoap2.c:    soap->dime.id = content->id;
./stdsoap2.c:    soap->dime.type = content->type;
./stdsoap2.c:    soap->dime.options = content->options;
./stdsoap2.c:    soap->dime.flags = SOAP_DIME_VERSION | SOAP_DIME_MEDIA;
./stdsoap2.c:    if (soap->fdimereadopen && ((handle = soap->fdimereadopen(soap, (void*)content->ptr, content->id, content->type, content->options)) != NULL || soap->error))
./stdsoap2.c:        return soap->error;
./stdsoap2.c:      if (!size && ((soap->mode & SOAP_ENC_PLAIN) || (soap->mode & SOAP_IO) == SOAP_IO_CHUNK || (soap->mode & SOAP_IO) == SOAP_IO_STORE))
./stdsoap2.c:      { size_t chunksize = sizeof(soap->tmpbuf);
./stdsoap2.c:        { size = soap->fdimeread(soap, handle, soap->tmpbuf, chunksize);
./stdsoap2.c:          { soap->dime.flags &= ~SOAP_DIME_CF;
./stdsoap2.c:              soap->dime.flags |= SOAP_DIME_ME;
./stdsoap2.c:            soap->dime.flags |= SOAP_DIME_CF;
./stdsoap2.c:          soap->dime.size = size;
./stdsoap2.c:           || soap_putdimefield(soap, soap->tmpbuf, size))
./stdsoap2.c:          if (soap->dime.id)
./stdsoap2.c:          { soap->dime.flags &= ~(SOAP_DIME_MB | SOAP_DIME_MEDIA);
./stdsoap2.c:            soap->dime.id = NULL;
./stdsoap2.c:            soap->dime.type = NULL;
./stdsoap2.c:            soap->dime.options = NULL;
./stdsoap2.c:          soap->dime.flags |= SOAP_DIME_ME;
./stdsoap2.c:          return soap->error;
./stdsoap2.c:          if (size < sizeof(soap->tmpbuf))
./stdsoap2.c:            bufsize = sizeof(soap->tmpbuf);
./stdsoap2.c:          bufsize = soap->fdimeread(soap, handle, soap->tmpbuf, bufsize);
./stdsoap2.c:            soap->error = SOAP_CHK_EOF;
./stdsoap2.c:          if (soap_send_raw(soap, soap->tmpbuf, bufsize))
./stdsoap2.c:        if (soap_send_raw(soap, SOAP_STR_PADDING, -(long)soap->dime.size&3))
./stdsoap2.c:          return soap->error;
./stdsoap2.c:      if (soap->fdimereadclose)
./stdsoap2.c:        soap->fdimereadclose(soap, handle);
./stdsoap2.c:        soap->dime.flags |= SOAP_DIME_ME;
./stdsoap2.c:        return soap->error;
./stdsoap2.c:        { soap->error = SOAP_CHK_EOF;
./stdsoap2.c:      soap->error = soap_move(soap, (size_t)(-(long)n&3));
./stdsoap2.c:      if (soap->error)
./stdsoap2.c:      soap->error = SOAP_EOM;
./stdsoap2.c:  if (!(soap->mode & SOAP_ENC_DIME))
./stdsoap2.c:    return soap->error = SOAP_DIME_END;
./stdsoap2.c:  if (soap->dime.buflen || soap->dime.chunksize)
./stdsoap2.c:  { if (soap_move(soap, soap->dime.size - soap_tell(soap)))
./stdsoap2.c:      return soap->error = SOAP_CHK_EOF;
./stdsoap2.c:      return soap->error = SOAP_CHK_EOF;
./stdsoap2.c:    return soap->error = SOAP_DIME_MISMATCH;
./stdsoap2.c:  soap->dime.flags = (tmp[0] & 0x7) | (tmp[1] & 0xF0);
./stdsoap2.c:  soap->dime.size = ((size_t)tmp[8] << 24) | ((size_t)tmp[9] << 16) | ((size_t)tmp[10] << 8) | ((size_t)tmp[11]);
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "DIME size=%lu flags=0x%X\n", (unsigned long)soap->dime.size, soap->dime.flags));
./stdsoap2.c:  soap->dime.options = soap_getdimefield(soap, optlen);
./stdsoap2.c:  if (!soap->dime.options && soap->error)
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  soap->dime.id = soap_getdimefield(soap, idlen);
./stdsoap2.c:  if (!soap->dime.id && soap->error)
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  soap->dime.type = soap_getdimefield(soap, typelen);
./stdsoap2.c:  if (!soap->dime.type && soap->error)
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "DIME id='%s', type='%s', options='%s'\n", soap->dime.id ? soap->dime.id : SOAP_STR_EOS, soap->dime.type ? soap->dime.type : "", soap->dime.options ? soap->dime.options+4 : SOAP_STR_EOS));
./stdsoap2.c:  if (soap->dime.flags & SOAP_DIME_ME)
./stdsoap2.c:    soap->mode &= ~SOAP_ENC_DIME;
./stdsoap2.c:{ while (soap->dime.flags & SOAP_DIME_CF)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    if (soap_move(soap, soap->dime.size))
./stdsoap2.c:      return soap->error = SOAP_EOF;
./stdsoap2.c:  if (soap_move(soap, (size_t)(((soap->dime.size+3)&(~3)) - soap_tell(soap))))
./stdsoap2.c:    return soap->error = SOAP_EOF;
./stdsoap2.c:    if (soap->fdimewriteopen && ((soap->dime.ptr = (char*)soap->fdimewriteopen(soap, soap->dime.id, soap->dime.type, soap->dime.options)) != NULL || soap->error))
./stdsoap2.c:      if (!soap->dime.ptr)
./stdsoap2.c:        return soap->error;
./stdsoap2.c:      id = soap->dime.id;
./stdsoap2.c:      type = soap->dime.type;
./stdsoap2.c:      options = soap->dime.options;
./stdsoap2.c:      { size = soap->dime.size;
./stdsoap2.c:        { n = soap->buflen - soap->bufidx;
./stdsoap2.c:          soap->error = soap->fdimewrite(soap, (void*)soap->dime.ptr, soap->buf + soap->bufidx, n);
./stdsoap2.c:          if (soap->error)
./stdsoap2.c:          { soap->bufidx += n;
./stdsoap2.c:          { soap->error = SOAP_EOF;
./stdsoap2.c:        if (soap_move(soap, (size_t)(-(long)soap->dime.size&3)))
./stdsoap2.c:        { soap->error = SOAP_EOF;
./stdsoap2.c:        if (!(soap->dime.flags & SOAP_DIME_CF))
./stdsoap2.c:      if (soap->fdimewriteclose)
./stdsoap2.c:        soap->fdimewriteclose(soap, (void*)soap->dime.ptr);
./stdsoap2.c:      soap->dime.size = 0;
./stdsoap2.c:      soap->dime.id = id;
./stdsoap2.c:      soap->dime.type = type;
./stdsoap2.c:      soap->dime.options = options;
./stdsoap2.c:    else if (soap->dime.flags & SOAP_DIME_CF)
./stdsoap2.c:      id = soap->dime.id;
./stdsoap2.c:      type = soap->dime.type;
./stdsoap2.c:      options = soap->dime.options;
./stdsoap2.c:        if (soap->dime.size > SOAP_MAXDIMESIZE)
./stdsoap2.c:        { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "DIME size=%lu exceeds SOAP_MAXDIMESIZE=%lu\n", (unsigned long)soap->dime.size, (unsigned long)SOAP_MAXDIMESIZE));
./stdsoap2.c:          return soap->error = SOAP_DIME_ERROR;
./stdsoap2.c:        s = (char*)soap_push_block(soap, NULL, soap->dime.size);
./stdsoap2.c:          return soap->error = SOAP_EOM;
./stdsoap2.c:        for (i = soap->dime.size; i > 0; i--)
./stdsoap2.c:            return soap->error = SOAP_EOF;
./stdsoap2.c:        if (soap_move(soap, (size_t)(-(long)soap->dime.size&3)))
./stdsoap2.c:          return soap->error = SOAP_EOF;
./stdsoap2.c:        if (!(soap->dime.flags & SOAP_DIME_CF))
./stdsoap2.c:          return soap->error;
./stdsoap2.c:      soap->dime.size = soap->blist->size++; /* allocate one more byte in blist for the terminating '\0' */
./stdsoap2.c:      soap->dime.ptr = soap_save_block(soap, NULL, NULL, 0);
./stdsoap2.c:      if (!soap->dime.ptr)
./stdsoap2.c:        return soap->error;
./stdsoap2.c:      soap->dime.ptr[soap->dime.size] = '\0'; /* make 0-terminated */
./stdsoap2.c:      soap->dime.id = id;
./stdsoap2.c:      soap->dime.type = type;
./stdsoap2.c:      soap->dime.options = options;
./stdsoap2.c:      soap->dime.ptr = soap_getdimefield(soap, soap->dime.size);
./stdsoap2.c:    content = soap_alloc_multipart(soap, &soap->dime.first, &soap->dime.last, soap->dime.ptr, soap->dime.size);
./stdsoap2.c:      return soap->error = SOAP_EOM;
./stdsoap2.c:    content->id = soap->dime.id;
./stdsoap2.c:    content->type = soap->dime.type;
./stdsoap2.c:    content->options = soap->dime.options;
./stdsoap2.c:    if (soap->error)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  if (soap->error != SOAP_DIME_END)
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  return soap->error = SOAP_OK;
./stdsoap2.c:  { if (soap_getline(soap, soap->msgbuf, sizeof(soap->msgbuf)))
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  } while (!*soap->msgbuf);
./stdsoap2.c:  if (soap->msgbuf[0] == '-' && soap->msgbuf[1] == '-')
./stdsoap2.c:  { char *s = soap->msgbuf + strlen(soap->msgbuf) - 1;
./stdsoap2.c:    if (soap->mime.boundary)
./stdsoap2.c:    { if (strcmp(soap->msgbuf + 2, soap->mime.boundary))
./stdsoap2.c:        return soap->error = SOAP_MIME_ERROR;
./stdsoap2.c:      soap->mime.boundary = soap_strdup(soap, soap->msgbuf + 2);
./stdsoap2.c:    if (soap_getline(soap, soap->msgbuf, sizeof(soap->msgbuf)))
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    return soap->error = SOAP_EOM;
./stdsoap2.c:  content = soap->mime.last;
./stdsoap2.c:  { char *key = soap->msgbuf;
./stdsoap2.c:    val = strchr(soap->msgbuf, ':');
./stdsoap2.c:    if (soap_getline(soap, key, sizeof(soap->msgbuf)))
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:{ soap->imode |= SOAP_MIME_POSTCHECK;
./stdsoap2.c:{ if (soap->mode & SOAP_MIME_POSTCHECK)
./stdsoap2.c:  if (!(soap->mode & SOAP_ENC_MIME))
./stdsoap2.c:  content = soap->mime.last;
./stdsoap2.c:    content = soap->mime.last;
./stdsoap2.c:  else if (content != soap->mime.first)
./stdsoap2.c:  { if (soap->fmimewriteopen && ((content->ptr = (char*)soap->fmimewriteopen(soap, (void*)handle, content->id, content->type, content->description, content->encoding)) != NULL || soap->error))
./stdsoap2.c:  { soap->error = SOAP_EOM;
./stdsoap2.c:    { s = soap->tmpbuf;
./stdsoap2.c:    { s = (char*)soap_push_block(soap, NULL, sizeof(soap->tmpbuf));
./stdsoap2.c:      { soap->error = SOAP_EOM;
./stdsoap2.c:    for (i = 0; i < sizeof(soap->tmpbuf); i++)
./stdsoap2.c:          { if (content->ptr && soap->fmimewriteclose)
./stdsoap2.c:              soap->fmimewriteclose(soap, (void*)content->ptr);
./stdsoap2.c:            soap->error = SOAP_CHK_EOF;
./stdsoap2.c:        { memset((void*)soap->msgbuf, 0, sizeof(soap->msgbuf));
./stdsoap2.c:          soap_strcpy(soap->msgbuf, sizeof(soap->msgbuf), "\n--");
./stdsoap2.c:          if (soap->mime.boundary)
./stdsoap2.c:          { if (soap_strncat(soap->msgbuf, sizeof(soap->msgbuf), soap->mime.boundary, sizeof(soap->msgbuf) - 4))
./stdsoap2.c:            { soap->error = SOAP_MIME_ERROR;
./stdsoap2.c:          t = soap->msgbuf;
./stdsoap2.c:          { if (content->ptr && soap->fmimewriteclose)
./stdsoap2.c:              soap->fmimewriteclose(soap, (void*)content->ptr);
./stdsoap2.c:            soap->error = SOAP_CHK_EOF;
./stdsoap2.c:          m = t - soap->msgbuf + 1 - flag;
./stdsoap2.c:          t = soap->msgbuf;
./stdsoap2.c:    if (content->ptr && soap->fmimewrite)
./stdsoap2.c:    { soap->error = soap->fmimewrite(soap, (void*)content->ptr, soap->tmpbuf, i);
./stdsoap2.c:      if (soap->error)
./stdsoap2.c:  { if (!soap->error && soap->fmimewrite)
./stdsoap2.c:      soap->error = soap->fmimewrite(soap, (void*)content->ptr, soap->tmpbuf, i);
./stdsoap2.c:    if (soap->fmimewriteclose)
./stdsoap2.c:      soap->fmimewriteclose(soap, (void*)content->ptr);
./stdsoap2.c:    if (soap->error)
./stdsoap2.c:  { soap->mode &= ~SOAP_ENC_MIME;
./stdsoap2.c:    if ((soap->mode & SOAP_MIME_POSTCHECK) && soap_end_recv(soap))
./stdsoap2.c:    { if (soap->keep_alive == -2) /* special case to keep alive */
./stdsoap2.c:        soap->keep_alive = 0;
./stdsoap2.c:    { soap->error = SOAP_MIME_ERROR;
./stdsoap2.c:  soap_decode(soap->tmpbuf, sizeof(soap->tmpbuf), s, SOAP_STR_EOS);
./stdsoap2.c:  if (!strncmp(soap->tmpbuf, t, n) && !soap->tmpbuf[n])
./stdsoap2.c:  for (i = 0; i < (sizeof(soap->buf) < 16UL ? sizeof(soap->buf) : 16UL); i++)
./stdsoap2.c:    r2 += soap->buf[i];
./stdsoap2.c:  (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), prefix ? strlen(prefix) + 37 : 37), "%s%8.8x-%4.4hx-4%3.3hx-%4.4hx-%4.4hx%8.8x", prefix ? prefix : SOAP_STR_EOS, r1, (short)(r2 >> 16), (short)(((short)r2 >> 4) & 0x0FFF), (short)(((short)(r3 >> 16) & 0x3FFF) | 0x8000), (short)r3, r4);
./stdsoap2.c:  return soap->tmpbuf;
./stdsoap2.c:  { struct soap_xlist **xp = &soap->xlist;
./stdsoap2.c:  if (soap_send3(soap, "\r\n--", soap->mime.boundary, "\r\n"))
./stdsoap2.c:    return soap->error;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  if (!(soap->mode & SOAP_ENC_MIME) || !soap->mime.boundary)
./stdsoap2.c:  for (content = soap->mime.first; content; content = content->next)
./stdsoap2.c:    if (soap->fmimereadopen && ((handle = soap->fmimereadopen(soap, (void*)content->ptr, content->id, content->type, content->description)) != NULL || soap->error))
./stdsoap2.c:        return soap->error;
./stdsoap2.c:        return soap->error;
./stdsoap2.c:      { if ((soap->mode & SOAP_ENC_PLAIN) || (soap->mode & SOAP_IO) == SOAP_IO_CHUNK || (soap->mode & SOAP_IO) == SOAP_IO_STORE)
./stdsoap2.c:          { size = soap->fmimeread(soap, handle, soap->tmpbuf, sizeof(soap->tmpbuf));
./stdsoap2.c:            if (soap_send_raw(soap, soap->tmpbuf, size))
./stdsoap2.c:          if (size < sizeof(soap->tmpbuf))
./stdsoap2.c:            bufsize = sizeof(soap->tmpbuf);
./stdsoap2.c:          bufsize = soap->fmimeread(soap, handle, soap->tmpbuf, bufsize);
./stdsoap2.c:            soap->error = SOAP_EOF;
./stdsoap2.c:          if (soap_send_raw(soap, soap->tmpbuf, bufsize))
./stdsoap2.c:      if (soap->fmimereadclose)
./stdsoap2.c:        soap->fmimereadclose(soap, handle);
./stdsoap2.c:        return soap->error;
./stdsoap2.c:  return soap_send3(soap, "\r\n--", soap->mime.boundary, "--");
./stdsoap2.c:{ soap->omode |= SOAP_ENC_DIME;
./stdsoap2.c:  soap->dime.first = NULL;
./stdsoap2.c:  soap->dime.last = NULL;
./stdsoap2.c:{ soap->omode |= SOAP_ENC_MIME;
./stdsoap2.c:  soap->mime.first = NULL;
./stdsoap2.c:  soap->mime.last = NULL;
./stdsoap2.c:  soap->mime.boundary = soap_strdup(soap, boundary);
./stdsoap2.c:  soap->mime.start = soap_strdup(soap, start);
./stdsoap2.c:{ soap->omode &= ~SOAP_ENC_DIME;
./stdsoap2.c:  soap->dime.first = NULL;
./stdsoap2.c:  soap->dime.last = NULL;
./stdsoap2.c:{ soap->omode &= ~SOAP_ENC_MIME;
./stdsoap2.c:  soap->mime.first = NULL;
./stdsoap2.c:  soap->mime.last = NULL;
./stdsoap2.c:  soap->mime.boundary = NULL;
./stdsoap2.c:  soap->mime.start = NULL;
./stdsoap2.c:{ struct soap_multipart *content = soap_alloc_multipart(soap, &soap->dime.first, &soap->dime.last, ptr, size);
./stdsoap2.c:{ struct soap_multipart *content = soap_alloc_multipart(soap, &soap->mime.first, &soap->mime.last, ptr, size);
./stdsoap2.c:{ while (!soap->mime.boundary || soap_valid_mime_boundary(soap))
./stdsoap2.c:  { char *s = soap->mime.boundary;
./stdsoap2.c:      s = soap->mime.boundary = (char*)soap_malloc(soap, n + 1);
./stdsoap2.c:  if (!soap->mime.start)
./stdsoap2.c:    soap->mime.start = "<SOAP-ENV:Envelope>";
./stdsoap2.c:  if (soap->fmimeread)
./stdsoap2.c:  k = strlen(soap->mime.boundary);
./stdsoap2.c:  for (content = soap->mime.first; content; content = content->next)
./stdsoap2.c:      { if (!strncmp(p, soap->mime.boundary, k))
./stdsoap2.c:      soap->z_dict = 0;
./stdsoap2.c:        return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:    return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:  { soap->error = SOAP_EOF;
./stdsoap2.c:  { if (soap->error < SOAP_STOP)
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Initializing for input from socket=%d/fd=%d\n", (int)soap->socket, soap->recvfd));
./stdsoap2.c:  soap->error = SOAP_OK;
./stdsoap2.c:  soap->recverror = SOAP_OK;
./stdsoap2.c:  soap->version = 0;    /* don't assume we're parsing SOAP content by default */
./stdsoap2.c:  if ((soap->imode & SOAP_IO) == SOAP_IO_CHUNK)
./stdsoap2.c:    soap->omode |= SOAP_IO_CHUNK;
./stdsoap2.c:  soap->imode &= ~(SOAP_IO | SOAP_ENC_MIME);
./stdsoap2.c:  soap->mode = soap->imode;
./stdsoap2.c:  if (!soap->keep_alive)
./stdsoap2.c:  { soap->buflen = 0;
./stdsoap2.c:    soap->bufidx = 0;
./stdsoap2.c:  if (!(soap->mode & SOAP_IO_KEEPALIVE))
./stdsoap2.c:    soap->keep_alive = 0;
./stdsoap2.c:  soap->shaky = 0;
./stdsoap2.c:  soap->ahead = 0;
./stdsoap2.c:  soap->peeked = 0;
./stdsoap2.c:  soap->level = 0;
./stdsoap2.c:  soap->part = SOAP_BEGIN;
./stdsoap2.c:  soap->body = 1;
./stdsoap2.c:  soap->count = 0;
./stdsoap2.c:  soap->length = 0;
./stdsoap2.c:  soap->cdata = 0;
./stdsoap2.c:  *soap->endpoint = '\0';
./stdsoap2.c:  soap->action = NULL;
./stdsoap2.c:  soap->header = NULL;
./stdsoap2.c:  soap->fault = NULL;
./stdsoap2.c:  soap->status = 0;
./stdsoap2.c:  soap->fform = NULL;
./stdsoap2.c:  soap->dom = NULL;
./stdsoap2.c:  soap->dime.chunksize = 0;
./stdsoap2.c:  soap->dime.buflen = 0;
./stdsoap2.c:  soap->dime.list = NULL;
./stdsoap2.c:  soap->dime.first = NULL;
./stdsoap2.c:  soap->dime.last = NULL;
./stdsoap2.c:  soap->mime.list = NULL;
./stdsoap2.c:  soap->mime.first = NULL;
./stdsoap2.c:  soap->mime.last = NULL;
./stdsoap2.c:  soap->mime.boundary = NULL;
./stdsoap2.c:  soap->mime.start = NULL;
./stdsoap2.c:  if (!soap_valid_socket(soap->socket) && !soap->is && soap->recvfd >= 0) /* Set win32 stdin or soap->recvfd to BINARY, e.g. to support DIME */
./stdsoap2.c:    setmode(soap->recvfd, _O_BINARY);
./stdsoap2.c:    _setmode(soap->recvfd, _O_BINARY);
./stdsoap2.c:  soap->mode &= ~SOAP_ENC_ZLIB;
./stdsoap2.c:  soap->zlib_in = SOAP_ZLIB_NONE;
./stdsoap2.c:  soap->zlib_out = SOAP_ZLIB_NONE;
./stdsoap2.c:  if (!soap->d_stream)
./stdsoap2.c:  { soap->d_stream = (z_stream*)SOAP_MALLOC(soap, sizeof(z_stream));
./stdsoap2.c:    soap->d_stream->zalloc = Z_NULL;
./stdsoap2.c:    soap->d_stream->zfree = Z_NULL;
./stdsoap2.c:    soap->d_stream->opaque = Z_NULL;
./stdsoap2.c:    soap->d_stream->next_in = Z_NULL;
./stdsoap2.c:  soap->d_stream->avail_in = 0;
./stdsoap2.c:  soap->d_stream->next_out = (Byte*)soap->buf;
./stdsoap2.c:  soap->d_stream->avail_out = sizeof(soap->buf);
./stdsoap2.c:  soap->z_ratio_in = 1.0;
./stdsoap2.c:  if (soap->ssl)
./stdsoap2.c:  if (soap->fprepareinitrecv && (soap->error = soap->fprepareinitrecv(soap)) != SOAP_OK)
./stdsoap2.c:    return soap->error;
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    if (inflateInit2(soap->d_stream, -MAX_WBITS) != Z_OK)
./stdsoap2.c:      return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:    if (soap->z_dict)
./stdsoap2.c:    { if (inflateSetDictionary(soap->d_stream, (const Bytef*)soap->z_dict, soap->z_dict_len) != Z_OK)
./stdsoap2.c:        return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:    soap->zlib_state = SOAP_ZLIB_INFLATE;
./stdsoap2.c:    soap->mode |= SOAP_ENC_ZLIB;
./stdsoap2.c:    soap->zlib_in = SOAP_ZLIB_GZIP;
./stdsoap2.c:    soap->z_crc = crc32(0L, NULL, 0);
./stdsoap2.c:    if (!soap->z_buf)
./stdsoap2.c:      soap->z_buf = (char*)SOAP_MALLOC(soap, sizeof(soap->buf));
./stdsoap2.c:    soap_memcpy((void*)soap->z_buf, sizeof(soap->buf), (const void*)soap->buf, sizeof(soap->buf));
./stdsoap2.c:    /* if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK) */
./stdsoap2.c:    /*   soap->z_buflen = soap->bufidx; */
./stdsoap2.c:    soap->d_stream->next_in = (Byte*)(soap->z_buf + soap->bufidx);
./stdsoap2.c:    soap->d_stream->avail_in = (unsigned int)(soap->buflen - soap->bufidx);
./stdsoap2.c:    soap->z_buflen = soap->buflen;
./stdsoap2.c:    soap->buflen = soap->bufidx;
./stdsoap2.c:    soap->mode |= SOAP_ENC_MIME;
./stdsoap2.c:    soap->mode |= SOAP_ENC_DIME;
./stdsoap2.c:      { soap->mode &= ~SOAP_ENC_LATIN;
./stdsoap2.c:      return soap->error = SOAP_UTF_ERROR;
./stdsoap2.c:    return soap->error = SOAP_CHK_EOF;
./stdsoap2.c:  if (((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) && !(soap->mode & (SOAP_ENC_MIME | SOAP_ENC_DIME | SOAP_ENC_ZLIB | SOAP_ENC_PLAIN)))
./stdsoap2.c:  { soap_mode m = soap->imode;
./stdsoap2.c:    soap->mode &= ~SOAP_IO;
./stdsoap2.c:    soap->error = soap->fparse(soap);
./stdsoap2.c:    if (soap->error && soap->error < SOAP_STOP)
./stdsoap2.c:    { if (soap->error < 200 || soap->error > 202)
./stdsoap2.c:        soap->keep_alive = 0; /* force close later if error but excluding HTTP codes 200..202 */
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    if (soap->error == SOAP_STOP)
./stdsoap2.c:    { if (soap->fform)
./stdsoap2.c:      { soap->error = soap->fform(soap);
./stdsoap2.c:        if (soap->error == SOAP_OK)
./stdsoap2.c:          soap->error = SOAP_STOP; /* prevents further processing */
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    soap->mode = soap->imode; /* if imode is changed, effectuate */
./stdsoap2.c:    soap->imode = m; /* restore imode */
./stdsoap2.c:    soap->mode &= ~SOAP_ENC_ZLIB;
./stdsoap2.c:    if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK)
./stdsoap2.c:    { soap->chunkbuflen = soap->buflen;
./stdsoap2.c:      soap->buflen = soap->bufidx;
./stdsoap2.c:      soap->chunksize = 0;
./stdsoap2.c:    if (soap->status > 200 && soap->length == 0 && !(soap->http_content && (!soap->keep_alive || soap->recv_timeout)) && (soap->imode & SOAP_IO) != SOAP_IO_CHUNK)
./stdsoap2.c:    if (soap->status && !soap->body)
./stdsoap2.c:      return soap->error = soap->status;
./stdsoap2.c:    if (soap->zlib_in != SOAP_ZLIB_NONE)
./stdsoap2.c:      if (soap->zlib_in != SOAP_ZLIB_DEFLATE)
./stdsoap2.c:          return soap->error = SOAP_EOF;
./stdsoap2.c:            return soap->error;
./stdsoap2.c:          if (inflateInit2(soap->d_stream, -MAX_WBITS) != Z_OK)
./stdsoap2.c:            return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:          soap->z_crc = crc32(0L, NULL, 0);
./stdsoap2.c:          if (inflateInit(soap->d_stream) != Z_OK)
./stdsoap2.c:            return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:          soap->zlib_in = SOAP_ZLIB_DEFLATE;
./stdsoap2.c:      if (inflateInit(soap->d_stream) != Z_OK)
./stdsoap2.c:        return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:      if (soap->z_dict)
./stdsoap2.c:      { if (inflateSetDictionary(soap->d_stream, (const Bytef*)soap->z_dict, soap->z_dict_len) != Z_OK)
./stdsoap2.c:          return soap->error = SOAP_ZLIB_ERROR;
./stdsoap2.c:      soap->zlib_state = SOAP_ZLIB_INFLATE;
./stdsoap2.c:      soap->mode |= SOAP_ENC_ZLIB;
./stdsoap2.c:      if (!soap->z_buf)
./stdsoap2.c:        soap->z_buf = (char*)SOAP_MALLOC(soap, sizeof(soap->buf));
./stdsoap2.c:      soap_memcpy((void*)soap->z_buf, sizeof(soap->buf), (const void*)soap->buf, sizeof(soap->buf));
./stdsoap2.c:      soap->d_stream->next_in = (Byte*)(soap->z_buf + soap->bufidx);
./stdsoap2.c:      soap->d_stream->avail_in = (unsigned int)(soap->buflen - soap->bufidx);
./stdsoap2.c:      soap->z_buflen = soap->buflen;
./stdsoap2.c:      soap->buflen = soap->bufidx;
./stdsoap2.c:    if (soap->fpreparerecv && (soap->mode & SOAP_IO) != SOAP_IO_CHUNK && soap->buflen > soap->bufidx)
./stdsoap2.c:      r = soap->fpreparerecv(soap, soap->buf + soap->bufidx, soap->buflen - soap->bufidx);
./stdsoap2.c:        return soap->error = r;
./stdsoap2.c:    { if (soap->status == 0)
./stdsoap2.c:        return soap->error = SOAP_NO_DATA; /* server side expects data */
./stdsoap2.c:      return soap->error = soap->status; /* client side received HTTP status code */
./stdsoap2.c:    if (soap->error)
./stdsoap2.c:    { if (soap->error != SOAP_FORM || !soap->fform)
./stdsoap2.c:        return soap->error;
./stdsoap2.c:      soap->error = soap->fform(soap);
./stdsoap2.c:      if (soap->error == SOAP_OK)
./stdsoap2.c:        return soap->error = SOAP_STOP; /* prevents further processing */
./stdsoap2.c:      if (soap->error < 300) /* continue only if POST plugin returned HTTP error, e.g. not found */
./stdsoap2.c:        return soap->error;
./stdsoap2.c:      soap->error = SOAP_OK;
./stdsoap2.c:  if (soap->mode & SOAP_ENC_MIME)
./stdsoap2.c:        return soap->error = SOAP_CHK_EOF;
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    if (soap->mime.start)
./stdsoap2.c:      { if (!soap->mime.last->id)
./stdsoap2.c:        if (!soap_match_cid(soap, soap->mime.start, soap->mime.last->id))
./stdsoap2.c:    if (soap_get_header_attribute(soap, soap->mime.first->type, "application/dime"))
./stdsoap2.c:      soap->mode |= SOAP_ENC_DIME;
./stdsoap2.c:  if (soap->mode & SOAP_ENC_DIME)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:    if (soap->dime.flags & SOAP_DIME_CF)
./stdsoap2.c:      soap->dime.chunksize = soap->dime.size;
./stdsoap2.c:      if (soap->buflen - soap->bufidx >= soap->dime.chunksize)
./stdsoap2.c:      { soap->dime.buflen = soap->buflen;
./stdsoap2.c:        soap->buflen = soap->bufidx + soap->dime.chunksize;
./stdsoap2.c:        soap->dime.chunksize -= soap->buflen - soap->bufidx;
./stdsoap2.c:    soap->count = soap->buflen - soap->bufidx;
./stdsoap2.c:  if ((soap->mode & SOAP_ENC_MIME) && soap->mime.boundary && soap->mime.start)
./stdsoap2.c:    if (strlen(soap->mime.boundary) + strlen(soap->mime.start) + 140 > sizeof(soap->tmpbuf))
./stdsoap2.c:      return soap->error = SOAP_EOM;
./stdsoap2.c:    if ((soap->mode & SOAP_ENC_DIME) && !(soap->mode & SOAP_ENC_MTOM))
./stdsoap2.c:    else if (soap->version == 2)
./stdsoap2.c:    { if (soap->mode & SOAP_ENC_MTOM)
./stdsoap2.c:    else if (soap->mode & SOAP_ENC_MTOM)
./stdsoap2.c:    (SOAP_SNPRINTF_SAFE(soap->tmpbuf, sizeof(soap->tmpbuf)), "--%s\r\nContent-Type: %s\r\nContent-Transfer-Encoding: binary\r\nContent-ID: %s\r\n\r\n", soap->mime.boundary, s, soap->mime.start);
./stdsoap2.c:    n = strlen(soap->tmpbuf);
./stdsoap2.c:    if (soap_send_raw(soap, soap->tmpbuf, n))
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  if (soap->mode & SOAP_IO_LENGTH)
./stdsoap2.c:    soap->dime.size = soap->count;      /* DIME in MIME correction */
./stdsoap2.c:  if (!(soap->mode & SOAP_IO_LENGTH) && (soap->mode & SOAP_ENC_DIME))
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  if (soap->version == 0)
./stdsoap2.c:  soap->part = SOAP_IN_ENVELOPE;
./stdsoap2.c:{ if (soap->version == 0)
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  if ((soap->mode & SOAP_IO_LENGTH) && (soap->mode & SOAP_ENC_DIME) && !(soap->mode & SOAP_ENC_MTOM))
./stdsoap2.c:  { soap->dime.size = soap->count - soap->dime.size;    /* DIME in MIME correction */
./stdsoap2.c:    (SOAP_SNPRINTF(soap->id, sizeof(soap->id), strlen(soap->dime_id_format) + 20), soap->dime_id_format, 0);
./stdsoap2.c:    soap->dime.id = soap->id;
./stdsoap2.c:    if (soap->local_namespaces)
./stdsoap2.c:    { if (soap->local_namespaces[0].out)
./stdsoap2.c:        soap->dime.type = (char*)soap->local_namespaces[0].out;
./stdsoap2.c:        soap->dime.type = (char*)soap->local_namespaces[0].ns;
./stdsoap2.c:    soap->dime.options = NULL;
./stdsoap2.c:    soap->dime.flags = SOAP_DIME_MB | SOAP_DIME_ABSURI;
./stdsoap2.c:    if (!soap->dime.first)
./stdsoap2.c:      soap->dime.flags |= SOAP_DIME_ME;
./stdsoap2.c:    soap->count += 12 + ((strlen(soap->dime.id)+3)&(~3)) + (soap->dime.type ? ((strlen(soap->dime.type)+3)&(~3)) : 0);
./stdsoap2.c:  if ((soap->mode & SOAP_ENC_DIME) && !(soap->mode & SOAP_ENC_MTOM))
./stdsoap2.c:    return soap_send_raw(soap, SOAP_STR_PADDING, -(long)soap->dime.size&3);
./stdsoap2.c:  soap->part = SOAP_END_ENVELOPE;
./stdsoap2.c:  if (!(soap->mode & SOAP_ENC_ZLIB) && (soap->mode & SOAP_IO) != SOAP_IO_CHUNK)
./stdsoap2.c:  { n = soap->length;
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Parsing HTTP body (mode=0x%x,len=%lu)\n", soap->mode, (unsigned long)n));
./stdsoap2.c:  soap->labidx = 0;                     /* use look-aside buffer */
./stdsoap2.c:    s = soap->labbuf + soap->labidx;    /* space to populate */
./stdsoap2.c:    k = soap->lablen - soap->labidx;    /* number of bytes available */
./stdsoap2.c:    soap->labidx = soap->lablen;        /* claim this space */
./stdsoap2.c:    soap_memcpy((void*)s, l, (const void*)soap->labbuf, l);
./stdsoap2.c:{ soap->part = SOAP_IN_ENVELOPE;
./stdsoap2.c:  { if (soap->error == SOAP_TAG_MISMATCH)
./stdsoap2.c:        soap->error = SOAP_VERSIONMISMATCH;
./stdsoap2.c:      else if (soap->status == 0 || (soap->status >= 200 && soap->status <= 299))
./stdsoap2.c:      soap->error = soap->status;
./stdsoap2.c:    else if (soap->status)
./stdsoap2.c:      soap->error = soap->status;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:{ if (soap->version == 0)
./stdsoap2.c:  soap->part = SOAP_END_ENVELOPE;
./stdsoap2.c:{ if (soap->version == 1)
./stdsoap2.c:    soap->encoding = 1;
./stdsoap2.c:  if ((soap->mode & SOAP_SEC_WSUID) && soap_set_attr(soap, "wsu:Id", "Body", 1))
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  if (soap->version == 0)
./stdsoap2.c:  soap->part = SOAP_IN_BODY;
./stdsoap2.c:{ if (soap->version == 0)
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  soap->part = SOAP_END_BODY;
./stdsoap2.c:{ if (soap->version == 0)
./stdsoap2.c:  soap->part = SOAP_IN_BODY;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  if (!soap->body)
./stdsoap2.c:    soap->part = SOAP_NO_BODY;
./stdsoap2.c:{ if (soap->version == 0)
./stdsoap2.c:  if (soap->part == SOAP_NO_BODY)
./stdsoap2.c:    return soap->error = SOAP_OK;
./stdsoap2.c:  soap->part = SOAP_END_BODY;
./stdsoap2.c:{ if (soap_getheader(soap) && soap->error == SOAP_TAG_MISMATCH)
./stdsoap2.c:    soap->error = SOAP_OK;
./stdsoap2.c:  if (soap->error == SOAP_OK && soap->fheader)
./stdsoap2.c:    soap->error = soap->fheader(soap);
./stdsoap2.c:  return soap->error;
./stdsoap2.c:  soap->endpoint[0] = '\0';
./stdsoap2.c:  soap->host[0] = '\0';
./stdsoap2.c:  soap->path[0] = '/';
./stdsoap2.c:  soap->path[1] = '\0';
./stdsoap2.c:  soap->port = 80;
./stdsoap2.c:    soap->port = 443;
./stdsoap2.c:  soap_strcpy(soap->endpoint, sizeof(soap->endpoint), endpoint);
./stdsoap2.c:      soap->userid = r;
./stdsoap2.c:      soap->passwd = SOAP_STR_EOS;
./stdsoap2.c:          soap->passwd = r;
./stdsoap2.c:    soap_strcpy(soap->endpoint + n, sizeof(soap->endpoint) - n, s);
./stdsoap2.c:  if (n >= sizeof(soap->host))
./stdsoap2.c:    n = sizeof(soap->host) - 1;
./stdsoap2.c:      soap->host[i] = s[i];
./stdsoap2.c:    { soap->host[i] = s[i];
./stdsoap2.c:  { soap->host[i] = s[i];
./stdsoap2.c:  soap->host[i] = '\0';
./stdsoap2.c:  { soap->port = (int)soap_strtol(s + i + 1, NULL, 10);
./stdsoap2.c:    soap_strcpy(soap->path, sizeof(soap->path), s + i);
./stdsoap2.c:  if (soap->userid && !soap->authrealm)
./stdsoap2.c:    soap->authrealm = soap->host;
./stdsoap2.c:{ soap_mode omode = soap->omode;
./stdsoap2.c:  soap->http_content = type;
./stdsoap2.c:  { soap->omode &= ~SOAP_IO;
./stdsoap2.c:    soap->omode |= SOAP_IO_STORE;
./stdsoap2.c:  soap->omode = omode;
./stdsoap2.c:{ soap_mode omode = soap->omode;
./stdsoap2.c:  soap->http_content = type;
./stdsoap2.c:  { soap->omode &= ~SOAP_IO;
./stdsoap2.c:    soap->omode |= SOAP_IO_STORE;
./stdsoap2.c:  soap->omode = omode;
./stdsoap2.c:        soap->error = SOAP_OK;
./stdsoap2.c:  return soap->error;
./stdsoap2.c:{ char host[sizeof(soap->host)];
./stdsoap2.c:  soap->error = SOAP_OK;
./stdsoap2.c:  soap_strcpy(host, sizeof(soap->host), soap->host); /* save previous host name: if != then reconnect */
./stdsoap2.c:  port = soap->port; /* save previous port to compare */
./stdsoap2.c:  soap->status = http_command;
./stdsoap2.c:  soap->action = soap_strdup(soap, action);
./stdsoap2.c:  if (soap->fconnect)
./stdsoap2.c:  { soap->error = soap->fconnect(soap, endpoint, soap->host, soap->port);
./stdsoap2.c:    if (soap->error)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  if (soap->fopen && *soap->host)
./stdsoap2.c:  { if (!soap->keep_alive || !soap_valid_socket(soap->socket) || strcmp(soap->host, host) || soap->port != port || !soap->fpoll || soap->fpoll(soap))
./stdsoap2.c:    { soap->error = SOAP_OK;
./stdsoap2.c:        soap->omode |= SOAP_IO_UDP;
./stdsoap2.c:      { soap->keep_alive = 0; /* to force close */
./stdsoap2.c:        soap->omode &= ~SOAP_IO_UDP; /* to force close */
./stdsoap2.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Connect/reconnect to '%s' host='%s' path='%s' port=%d\n", endpoint?endpoint:"(null)", soap->host, soap->path, soap->port));
./stdsoap2.c:      if (!soap->keep_alive || !soap_valid_socket(soap->socket))
./stdsoap2.c:      { soap->socket = soap->fopen(soap, endpoint, soap->host, soap->port);
./stdsoap2.c:        if (soap->error)
./stdsoap2.c:          return soap->error;
./stdsoap2.c:        soap->keep_alive = -((soap->omode & SOAP_IO_KEEPALIVE) != 0);
./stdsoap2.c:  if (soap_ntlm_handshake(soap, SOAP_GET, endpoint, soap->host, soap->port))
./stdsoap2.c:    return soap->error;
./stdsoap2.c:    return soap->error;
./stdsoap2.c:  { soap->mode &= ~SOAP_IO;
./stdsoap2.c:    soap->mode |= SOAP_IO_BUFFER;
./stdsoap2.c:  if ((soap->mode & SOAP_IO) != SOAP_IO_STORE && !(soap->mode & SOAP_ENC_PLAIN) && endpoint)
./stdsoap2.c:  { soap_mode k = soap->mode;
./stdsoap2.c:    soap->mode &= ~(SOAP_IO | SOAP_ENC_ZLIB);
./stdsoap2.c:      soap->mode |= SOAP_IO_BUFFER;
./stdsoap2.c:    soap->error = soap->fpost(soap, endpoint, soap->host, soap->port, soap->path, action, count);
./stdsoap2.c:    if (soap->error)
./stdsoap2.c:      return soap->error;
./stdsoap2.c:        return soap->error;
./stdsoap2.c:    soap->mode = k;
./stdsoap2.c:  const char *userid = (soap->proxy_userid ? soap->proxy_userid : soap->userid);
./stdsoap2.c:  const char *passwd = (soap->proxy_passwd ? soap->proxy_passwd : soap->passwd);
./stdsoap2.c:  if (soap->ntlm_challenge && userid && passwd && soap->authrealm)
./stdsoap2.c:    int k = soap->keep_alive;
./stdsoap2.c:    size_t l = soap->length;
./stdsoap2.c:    size_t c = soap->count;
./stdsoap2.c:    soap_mode m = soap->mode, o = soap->omode;
./stdsoap2.c:    int s = soap->status;
./stdsoap2.c:    char *a = soap->action;
./stdsoap2.c:    short v = soap->version;
./stdsoap2.c:    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "NTLM '%s'\n", soap->ntlm_challenge));
./stdsoap2.c:    if (!*soap->ntlm_challenge)
./stdsoap2.c:      buildSmbNtlmAuthRequest(&req, userid, soap->authrealm);
./stdsoap2.c:      soap->ntlm_challenge = soap_s2base64(soap, (unsigned char*)(void*)&req, NULL, SmbLength(&req));
./stdsoap2.c:      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "NTLM C->S Type 2: sending NTLM authorization to server\nAuthorization: NTLM %s\n", soap->ntlm_challenge));
./stdsoap2.c:      soap->omode = SOAP_IO_BUFFER;
./stdsoap2.c:        return soap->error;
./stdsoap2.c:      if (!soap->keep_alive)
./stdsoap2.c:        soap->keep_alive = -1; /* client keep alive */
./stdsoap2.c:      soap->status = command;
./stdsoap2.c:      if (soap->fpost(soap, endpoint, host, port, soap->path, soap->action, 0)
./stdsoap2.c:        return soap->error;
./stdsoap2.c:      soap->mode = m;
./stdsoap2.c:      soap->keep_alive = k;
./stdsoap2.c:      oldheader = soap->header;
./stdsoap2.c:        if (soap->error == SOAP_EOF)
./stdsoap2.c:          return soap->error;
./stdsoap2.c:      soap->header = oldheader;
./stdsoap2.c:      soap->length = l;
./stdsoap2.c:      if (soap->status != 401 && soap->status != 407)
./stdsoap2.c:        return soap->error = SOAP_NTLM_ERROR;
./stdsoap2.c:      soap->error = SOAP_OK;
./stdsoap2.c:    soap_base642s(soap, soap->ntlm_challenge, (char*)&ch, sizeof(tSmbNtlmAuthChallenge), NULL);
./stdsoap2.c:    soap->ntlm_challenge = soap_s2base64(soap, (unsigned char*)(void*)&res, NULL, SmbLength(&res));
./stdsoap2.c:    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "NTLM C->S Type 3: sending NTLM authorization to server\nAuthorization: NTLM %s\n", soap->ntlm_challenge));
./stdsoap2.c:    soap->userid = NULL;
./stdsoap2.c:    soap->passwd = NULL;
./stdsoap2.c:    soap->proxy_userid = NULL;
./stdsoap2.c:    soap->proxy_passwd = NULL;
./stdsoap2.c:    soap->keep_alive = k;
./stdsoap2.c:    soap->length = l;
./stdsoap2.c:    soap->count = c;
./stdsoap2.c:    soap->mode = m;
./stdsoap2.c:    soap->omode = o;
./stdsoap2.c:    soap->status = s;
./stdsoap2.c:    soap->action = a;
./stdsoap2.c:    soap->version = v;
./stdsoap2.c:    if (soap->error)
./stdsoap2.c:        { soap->error = SOAP_TYPE;
./stdsoap2.c:      { soap->error = SOAP_TYPE;
./stdsoap2.c:    if (soap->error)
./stdsoap2.c:  if (soap->status != SOAP_GET && soap->status != SOAP_DEL && soap->status != SOAP_CONNECT)
./stdsoap2.c:    if ((status == SOAP_FILE || soap->status == SOAP_PUT || soap->status == SOAP_POST_FILE) && soap->http_content && !strchr(s, 10) && !strchr(s, 13))
./stdsoap2.c:      s = soap->http_content;
./stdsoap2.c:    else if (count || ((soap->omode & SOAP_IO) == SOAP_IO_CHUNK))
./stdsoap2.c:    { if (soap->version == 2)
./stdsoap2.c:    soap->http_content = NULL; /* use http_content once (assign new value before each call) */
./stdsoap2.c:    if (soap->mode & (SOAP_ENC_DIME | SOAP_ENC_MTOM))
./stdsoap2.c:    { if (soap->mode & SOAP_ENC_MTOM)
./stdsoap2.c:      { if (soap->version == 2)
./stdsoap2.c:    if ((soap->mode & SOAP_ENC_MIME) && soap->mime.boundary)
./stdsoap2.c:      n = strlen(soap->mime.boundary);
./stdsoap2.c:      (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), n + 53), "multipart/related; charset=utf-8; boundary=\"%s\"; type=\"", soap->mime.boundary);
./stdsoap2.c:      l = strlen(soap->tmpbuf);
./stdsoap2.c:      if (sizeof(soap->tmpbuf) - l > n)
./stdsoap2.c:        (void)soap_strncpy(soap->tmpbuf + l, sizeof(soap->tmpbuf) - l, s, n);
./stdsoap2.c:      if (soap->mime.start)
./stdsoap2.c:      { l = strlen(soap->tmpbuf);
./stdsoap2.c:        n = strlen(soap->mime.start);
./stdsoap2.c:        (SOAP_SNPRINTF(soap->tmpbuf + l, sizeof(soap->tmpbuf) - l, n + 10), "\"; start=\"%s", soap->mime.start);
./stdsoap2.c:      { l = strlen(soap->tmpbuf);
./stdsoap2.c:        (SOAP_SNPRINTF(soap->tmpbuf + l, sizeof(soap->tmpbuf) - l, n + 15), "\"; start-info=\"%s", r);
./stdsoap2.c:      l = strlen(soap->tmpbuf);
./stdsoap2.c:      if (sizeof(soap->tmpbuf) - l > 1)
./stdsoap2.c:        (void)soap_strncpy(soap->tmpbuf + l, sizeof(soap->tmpbuf) - l, "\"", 1);
./stdsoap2.c:    { soap_strcpy(soap->tmpbuf, sizeof(soap->tmpbuf), s);
./stdsoap2.c:    if (status == SOAP_OK && soap->version == 2 && soap->action)
./stdsoap2.c:    { size_t l = strlen(soap->tmpbuf);
./stdsoap2.c:      n = strlen(soap->action);
./stdsoap2.c:      (SOAP_SNPRINTF(soap->tmpbuf + l, sizeof(soap->tmpbuf) - l, n + 11), "; action=\"%s\"", soap->action);
./stdsoap2.c:    soap_strcpy(soap->tmpbuf, sizeof(soap->tmpbuf), s);
./stdsoap2.c:    if (soap->http_extra_header)
./stdsoap2.c:    { err = soap_send(soap, soap->http_extra_header);
./stdsoap2.c:      soap->http_extra_header = NULL; /* use http_extra_header once (assign new value before each call) */
./stdsoap2.c:    err = soap->fposthdr(soap, "Content-Type", soap->tmpbuf);
./stdsoap2.c:    if ((soap->omode & SOAP_ENC_ZLIB))
./stdsoap2.c:      err = soap->fposthdr(soap, "Content-Encoding", soap->zlib_out == SOAP_ZLIB_DEFLATE ? "deflate" : "gzip");
./stdsoap2.c:      err = soap->fposthdr(soap, "Content-Encoding", "deflate");
./stdsoap2.c:    if ((soap->omode & SOAP_IO) == SOAP_IO_CHUNK)
./stdsoap2.c:      err = soap->fposthdr(soap, "Transfer-Encoding", "chunked");
./stdsoap2.c:    { (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), 20), SOAP_ULONG_FORMAT, (ULONG64)count);
./stdsoap2.c:      err = soap->fposthdr(soap, "Content-Length", soap->tmpbuf);
./stdsoap2.c:  if (soap->keep_alive)
./stdsoap2.c:  { if (soap->keep_alive > 0 && soap->recv_timeout)
./stdsoap2.c:    { int t = soap->recv_timeout;
./stdsoap2.c:      (SOAP_SNPRINTF(soap->tmpbuf, sizeof(soap->tmpbuf), 20), "timeout=%d, max=%d", soap->recv_timeout, soap->keep_alive);
./stdsoap2.c:      err = soap->fposthdr(soap, "Keep-Alive", soap->tmpbuf);
./stdsoap2.c:    return soap->fposthdr(soap, "Connection", "keep-alive");
./stdsoap2.c:  return soap->fposthdr(soap, "Connection", "close");
./stdsoap2.c:  if (*soap->tag)
./stdsoap2.c:    (SOAP_SNPRINTF(soap->msgbuf, sizeof(soap->msgbuf), strlen(s) + strlen(t) + strlen(soap->tag) + 47), "Validation constraint violation: %s%s in element '%s'", s, t, soap->tag);
./stdsoap2.c:    (SOAP_SNPRINTF(soap->msgbuf, sizeof(soap->msgbuf), strlen(s) + strlen(t) + 33), "Validation constraint violation: %s%s", s, t);
./stdsoap2.c:  return soap->msgbuf;
./stdsoap2.c:  if (soap->fseterror)
./stdsoap2.c:    soap->fseterror(soap, c, s);
./stdsoap2.c:  { if (soap->version == 2)
./stdsoap2.c:    else if (soap->version == 1)
./stdsoap2.c:  switch (soap->error)
./stdsoap2.c:      if (*soap->type)
./stdsoap2.c:        *s = soap_set_validation_fault(soap, "type mismatch ", soap->type);
./stdsoap2.c:      else if (*soap->arrayType)
./stdsoap2.c:      if (soap->version == 0 && soap->level == 0)
./stdsoap2.c:      else if (soap->version != 0 && soap->level < 3)
./stdsoap2.c:      (SOAP_SNPRINTF(soap->msgbuf, sizeof(soap->msgbuf), strlen(soap->tag) + 65), "The data in element '%s' must be understood but cannot be processed", soap->tag);
./stdsoap2.c:      *s = soap->msgbuf;
./stdsoap2.c:      (SOAP_SNPRINTF(soap->msgbuf, sizeof(soap->msgbuf), strlen(soap->tag) + 66), "Method '%s' not implemented: method name or namespace not recognized", soap->tag);
./stdsoap2.c:      *s = soap->msgbuf;
./stdsoap2.c:      *s = soap_set_validation_fault(soap, "multiple elements (use the SOAP_XML_TREE flag) with duplicate id ", soap->id);
./stdsoap2.c:      if (soap->version == 2)
./stdsoap2.c:      *s = soap_set_validation_fault(soap, "missing id for ref ", soap->id);
./stdsoap2.c:      if (soap->version == 2)
./stdsoap2.c:      *s = soap_set_validation_fault(soap, "incompatible object type id-ref ", soap->id);
./stdsoap2.c:      (SOAP_SNPRINTF(soap->msgbuf, sizeof(soap->msgbuf), (soap->d_stream && soap->d_stream->msg ? strlen(soap->d_stream->msg) : 0) + 19), "Zlib/gzip error: '%s'", soap->d_stream && soap->d_stream->msg ? soap->d_stream->msg : SOAP_STR_EOS);
./stdsoap2.c:      *s = soap->msgbuf;
./stdsoap2.c:      *s = soap_strerror(soap); /* *s = soap->msgbuf */
./stdsoap2.c:      if (strlen(soap->msgbuf) + 25 < sizeof(soap->msgbuf))
./stdsoap2.c:      { soap_memmove((void*)(soap->msgbuf + 25), sizeof(soap->tmpbuf) - 25, (const void*)soap->msgbuf, strlen(soap->msgbuf) + 1);
./stdsoap2.c:        if (soap->is)
./stdsoap2.c:          soap_memcpy((void*)soap->msgbuf, sizeof(soap->msgbuf), (const void*)"End or bad std::istream: ", 25);
./stdsoap2.c:          soap_memcpy((void*)soap->msgbuf, sizeof(soap->msgbuf), (const void*)"End at NUL buffer input: ", 25);
./stdsoap2.c:          soap_memcpy((void*)soap->msgbuf, sizeof(soap->msgbuf), (const void*)"End of file or no input: ", 25);
./stdsoap2.c:      if (soap->error >= 200 && soap->error < 600)
./stdsoap2.c:      { const char *t = http_error(soap, soap->error);
./stdsoap2.c:        (SOAP_SNPRINTF(soap->msgbuf, sizeof(soap->msgbuf), strlen(t) + 54), "Error %d: HTTP %d %s", soap->error, soap->error, t);
./stdsoap2.c:        *s = soap->msgbuf;
./stdsoap2.c:      { (SOAP_SNPRINTF(soap->msgbuf, sizeof(soap->msgbuf), 26), "Error %d", soap->error);
./stdsoap2.c:        *s = soap->msgbuf;
./stdsoap2.c:{ int status = soap->error;
./stdsoap2.c:  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Sending back fault struct for error code %d\n", soap->error));
./stdsoap2.c:  soap->keep_alive = 0; /* to terminate connection */
./stdsoap2.c:  if (soap->error < 200 && soap->error != SOAP_FAULT)
./stdsoap2.c:    soap->header = NULL;
./stdsoap2.c:  if (status != SOAP_EOF || (!soap->recv_timeout && !soap->send_timeout))
./stdsoap2.c:    if (soap->fpoll && soap->fpoll(soap))
./stdsoap2.c:    else if (soap_valid_socket(soap->socket))
./stdsoap2.c:    { r = tcp_select(soap, soap->socket, SOAP_TCP_SELECT_RCV | SOAP_TCP_SELECT_SND, 0);
./stdsoap2.c:          && recv(soap->socket, (char*)&t, 1, MSG_PEEK) < 0))
./stdsoap2.c:    { soap->error = SOAP_OK;
./stdsoap2.c:      soap->encodingStyle = NULL; /* no encodingStyle in Faults */
./stdsoap2.c:      if (soap->mode & SOAP_IO_LENGTH)
./stdsoap2.c:  soap->error = status;
./stdsoap2.c:{ int status = soap->status;
./stdsoap2.c:    if (soap->error != SOAP_NO_TAG
./stdsoap2.c:     && (soap->error != SOAP_TAG_MISMATCH || soap->level != 2))
./stdsoap2.c:      return soap->error;
./stdsoap2.c:  else if (soap->version == 0) /* check == 1 but no SOAP: do not parse SOAP Fault */
./stdsoap2.c:  soap->error = SOAP_OK;
./stdsoap2.c:    if (check && ((soap->error == SOAP_TAG_MISMATCH && soap->level == 2) || soap->error == SOAP_NO_TAG))
./stdsoap2.c:      return soap->error = SOAP_OK;
./stdsoap2.c:    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Error: soap_get_soapfault() failed at level %u tag '%s'\n", soap->level, soap->tag));
./stdsoap2.c:    *soap_faultcode(soap) = (soap->version == 2 ? "SOAP-ENV:Sender" : "SOAP-ENV:Client");
./stdsoap2.c:      soap->error = status;
./stdsoap2.c:      soap->error = status = SOAP_NO_DATA;
./stdsoap2.c:  soap->error = status;
./stdsoap2.c:{ soap_mode m = soap->omode;
./stdsoap2.c:  { soap->count = 0;
./stdsoap2.c:      soap->omode = (m & ~SOAP_IO) | SOAP_IO_BUFFER;
./stdsoap2.c:    soap->error = SOAP_STOP; /* stops the server from returning another response */
./stdsoap2.c:    soap->omode = m;
./stdsoap2.c:{ soap->error = SOAP_OK;
./stdsoap2.c:  if (!(soap->omode & SOAP_IO_UDP))
./stdsoap2.c:        soap_set_receiver_error(soap, "HTTP Error", s, soap->status);
./stdsoap2.c:    else if (soap->error == SOAP_NO_DATA || soap->error == 200 || soap->error == 201 || soap->error == 202)
./stdsoap2.c:      soap->error = SOAP_OK;
./stdsoap2.c:{ int err = soap->errnum;
./stdsoap2.c:  *soap->msgbuf = '\0';
./stdsoap2.c:    return strerror_r(err, soap->msgbuf, sizeof(soap->msgbuf)); /* GNU-specific */
./stdsoap2.c:    strerror_r(err, soap->msgbuf, sizeof(soap->msgbuf)); /* XSI-compliant */
./stdsoap2.c:    *soap->msgbuf = '\0';
./stdsoap2.c:    len = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, err, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)soap->msgbuf, (DWORD)sizeof(soap->msgbuf), NULL);
./stdsoap2.c:    *soap->msgbuf = '\0';
./stdsoap2.c:    len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, err, 0, (LPTSTR)soap->msgbuf, (DWORD)(sizeof(soap->msgbuf)/sizeof(TCHAR)), NULL);
./stdsoap2.c:    { if (((TCHAR*)soap->msgbuf)[i] < 0x80)
./stdsoap2.c:        soap->msgbuf[i] = (char)((TCHAR*)soap->msgbuf)[i];
./stdsoap2.c:        soap->msgbuf[i] = '?';
./stdsoap2.c:  { int rt = soap->recv_timeout, st = soap->send_timeout;
./stdsoap2.c:    soap_strcpy(soap->msgbuf, sizeof(soap->msgbuf), "message transfer interrupted");
./stdsoap2.c:      soap_strcpy(soap->msgbuf + 28, sizeof(soap->msgbuf) - 28, " or timed out");
./stdsoap2.c:    { size_t l = strlen(soap->msgbuf);
./stdsoap2.c:      (SOAP_SNPRINTF(soap->msgbuf + l, sizeof(soap->msgbuf) - l, 36), " (%d%cs recv delay)", rt, ru);
./stdsoap2.c:    { size_t l = strlen(soap->msgbuf);
./stdsoap2.c:      (SOAP_SNPRINTF(soap->msgbuf + l, sizeof(soap->msgbuf) - l, 36), " (%d%cs send delay)", st, su);
./stdsoap2.c:  return soap->msgbuf;
./stdsoap2.c:  return soap->error = soaperror;
./stdsoap2.c:{ return soap_set_error(soap, soap->version == 2 ? "SOAP-ENV:Sender" : soap->version == 1 ? "SOAP-ENV:Client" : "at source", NULL, faultstring, faultdetailXML, soaperror);
./stdsoap2.c:{ return soap_set_error(soap, soap->version == 2 ? "SOAP-ENV:Receiver" : soap->version == 1 ? "SOAP-ENV:Server" : "is internal", NULL, faultstring, faultdetailXML, soaperror);
./stdsoap2.c:{ return soap_copy_fault(soap, soap->version == 2 ? "SOAP-ENV:Sender" : soap->version == 1 ? "SOAP-ENV:Client" : "at source", faultsubcodeQName, faultstring, faultdetailXML);
./stdsoap2.c:{ return soap_copy_fault(soap, soap->version == 2 ? "SOAP-ENV:Receiver" : soap->version == 1 ? "SOAP-ENV:Server" : "is internal", faultsubcodeQName, faultstring, faultdetailXML);
./stdsoap2.c:  else if (soap->error)
./stdsoap2.c:    if (soap->version == 2)
./stdsoap2.c:    fprintf(fd, "%s%d fault %s [%s]\n\"%s\"\nDetail: %s\n", soap->version ? "SOAP 1." : "Error ", soap->version ? (int)soap->version : soap->error, *c, v ? v : "no subcode", s ? s : "[no reason]", d ? d : "[no detail]");
./stdsoap2.c:  else if (soap->error)
./stdsoap2.c:    if (soap->version == 2)
./stdsoap2.c:    os << (soap->version ? "SOAP 1." : "Error ")
./stdsoap2.c:       << (soap->version ? (int)soap->version : soap->error)
./stdsoap2.c:  else if (soap->error)
./stdsoap2.c:    if (soap->version == 2)
./stdsoap2.c:    (SOAP_SNPRINTF(buf, len, strlen(*c) + strlen(v) + strlen(s) + strlen(d) + 72), "%s%d fault %s [%s]\n\"%s\"\nDetail: %s\n", soap->version ? "SOAP 1." : "Error ", soap->version ? (int)soap->version : soap->error, *c, v ? v : "no subcode", s ? s : "[no reason]", d ? d : "[no detail]");
./stdsoap2.c:  if (soap->error && soap->error != SOAP_STOP && soap->bufidx <= soap->buflen && soap->buflen > 0 && soap->buflen <= sizeof(soap->buf))
./stdsoap2.c:  { i = (int)soap->bufidx - 1;
./stdsoap2.c:    c1 = soap->buf[i];
./stdsoap2.c:    soap->buf[i] = '\0';
./stdsoap2.c:    if ((int)soap->buflen >= i + 1024)
./stdsoap2.c:      j = (int)soap->buflen - 1;
./stdsoap2.c:    c2 = soap->buf[j];
./stdsoap2.c:    soap->buf[j] = '\0';
./stdsoap2.c:    fprintf(fd, "%s%c\n<!-- ** HERE ** -->\n", soap->buf, c1);
./stdsoap2.c:    if (soap->bufidx < soap->buflen)
./stdsoap2.c:      fprintf(fd, "%s\n", soap->buf + soap->bufidx);
./stdsoap2.c:    soap->buf[i] = (char)c1;
./stdsoap2.c:    soap->buf[j] = (char)c2;
./stdsoap2.c:    return soap->error = SOAP_EOM;
./stdsoap2.c:  { p->next = soap->plugins;
./stdsoap2.c:    soap->plugins = p;
./stdsoap2.c:  for (p = soap->plugins; p; p = p->next)
./stdsoap2.c:{ return soap->fplugin(soap, id);
匹配到二进制文件 ./discoveryclient.o
./stdsoap2.h:# define SOAP_CHK_EOF (soap->error ? soap->error : SOAP_EOF)
./stdsoap2.h:#  define SOAP_MAXDIMS   (16) /* maximum array dimensions (array nestings) must be less than 64 to protect soap->tmpbuf */
./stdsoap2.h:  { if (!soap->fdebug[SOAP_INDEX_##DBGFILE])\
./stdsoap2.h:    if (soap->fdebug[SOAP_INDEX_##DBGFILE])\
./stdsoap2.h:    { FILE *fdebug = soap->fdebug[SOAP_INDEX_##DBGFILE];\
./stdsoap2.h:  { if (!soap->fdebug[SOAP_INDEX_##DBGFILE])\
./stdsoap2.h:    if (soap->fdebug[SOAP_INDEX_##DBGFILE])\
./stdsoap2.h:    { FILE *fdebug = soap->fdebug[SOAP_INDEX_##DBGFILE];\
./stdsoap2.h:  { if (!soap->fdebug[SOAP_INDEX_##DBGFILE])\
./stdsoap2.h:    if (soap->fdebug[SOAP_INDEX_##DBGFILE])\
./stdsoap2.h:    { FILE *fdebug = soap->fdebug[SOAP_INDEX_##DBGFILE];\
./stdsoap2.h:  { if (!soap->fdebug[SOAP_INDEX_##DBGFILE])\
./stdsoap2.h:    if (soap->fdebug[SOAP_INDEX_##DBGFILE])\
./stdsoap2.h:    { fwrite((void*)(MSG), 1, (size_t)(LEN), soap->fdebug[SOAP_INDEX_##DBGFILE]);\
./stdsoap2.h:      fflush(soap->fdebug[SOAP_INDEX_##DBGFILE]);\
./stdsoap2.h:  { if (!soap->fdebug[SOAP_INDEX_##DBGFILE])\
./stdsoap2.h:    if (soap->fdebug[SOAP_INDEX_##DBGFILE])\
./stdsoap2.h:        fprintf(soap->fdebug[SOAP_INDEX_##DBGFILE], "%2.2X  ", (int)*s++&0xFF);\
./stdsoap2.h:      fflush(soap->fdebug[SOAP_INDEX_##DBGFILE]);\
./stdsoap2.h:  const char *is;       /* C only: a const char* to read from (soap->is will advance) */
./stdsoap2.h:      b = soap->blist;
./stdsoap2.h:      b = soap->blist;
./stdsoap2.h:      b = soap->blist;
./stdsoap2.h:      b = soap->blist;
./discoveryclient.c:		soap->recv_timeout = timeout;
./discoveryclient.c:		soap->send_timeout = timeout;
./discoveryclient.c:		soap->connect_timeout = timeout;
./discoveryclient.c:		soap->recv_timeout    = 10;
./discoveryclient.c:		soap->send_timeout    = 10;
./discoveryclient.c:		soap->connect_timeout = 10;
./discoveryclient.c:	//soap->sndbuf = 1024;
./discoveryclient.c:		strncpy(header->wsa__To,  was_To, 1024);//"urn:schemas-xmlsoap-org:ws:2005:04:discovery";	
./discoveryclient.c:	soap->header = header;
./discoveryclient.c:	const char *was_To = "urn:schemas-xmlsoap-org:ws:2005:04:discovery";
./discoveryclient.c:	//soap->header = &header;
./discoveryclient.c:			if (soap->error)
./discoveryclient.c:				DBG_MSG("[%d]: recv soap error :%d, %s, %s\n", __LINE__, soap->error, *soap_faultcode(soap), *soap_faultstring(soap)); 
./discoveryclient.c:				retval = soap->error;
./discoveryclient.c:		else if (soap->error)  
./discoveryclient.c:				DBG_MSG("[%s][%s][Line:%d] Thers Device discovery or soap error: %d, %s, %s \n",__FILE__, __func__, __LINE__, soap->error, *soap_faultcode(soap), *soap_faultstring(soap)); 
./discoveryclient.c:				retval = soap->error;  
./discoveryclient.c:		if (soap->error)  
./discoveryclient.c:			DBG_MSG("[%s][%d]--->>> soap error: %d, %s, %s\n", __func__, __LINE__, soap->error, *soap_faultcode(soap), *soap_faultstring(soap));  
./discoveryclient.c:			retval = soap->error;
./discoveryclient.c:		//DBG_MSG("soap error: %d, %s, %s\n", soap->error, *soap_faultcode(soap), *soap_faultstring(soap)); 
./discoveryclient.c:		result = soap->error; 	 
./discoveryclient.c:		if(soap->error == 12 && flag != 1){
./discoveryclient.c:		//printf("soap error: %d, %s, %s\n", soap->error, *soap_faultcode(soap), *soap_faultstring(soap));  
./discoveryclient.c:	if (soap->error) {  
./discoveryclient.c:		DBG_MSG("soap error: %d, %s, %s\n", soap->error, *soap_faultcode(soap), *soap_faultstring(soap));  
./discoveryclient.c:		result = soap->error;  
./discoveryclient.c:		if(soap->error){
./discoveryclient.c:			DBG_MSG("soap_call___tds__SetSystemDateAndTime faild %d ,%s ,%s\n",soap->error, *soap_faultcode(soap), *soap_faultstring(soap));
./discoveryclient.c:			ret = soap->error;
./discoveryclient.c:	return soap->error;
./discoveryclient.c:	if(soap->error){
./discoveryclient.c:		DBG_MSG("soap_call___tds__GetNetworkInterfaces faild %d ,%s ,%s\n",soap->error, *soap_faultcode(soap), *soap_faultstring(soap));
./discoveryclient.c:		return soap->error;
./discoveryclient.c:	if(soap->error){
./discoveryclient.c:		DBG_MSG("soap_call___trt__SetVideoEncoderConfiguration faild %d ,%s ,%s token %s\n",soap->error, *soap_faultcode(soap), *soap_faultstring(soap),trt__SetVideoEncoderConfiguration->Configuration->token);
./discoveryclient.c:		ret = soap->error;
匹配到二进制文件 ./stdsoap2.o
./test2.c:		soap->recv_timeout = timeout;
./test2.c:		soap->send_timeout = timeout;
./test2.c:		soap->connect_timeout = timeout;
./test2.c:		soap->recv_timeout    = 10;
./test2.c:		soap->send_timeout    = 10;
./test2.c:		soap->connect_timeout = 10;
./test2.c:		strncpy(header->wsa__To,  was_To, 1024);//"urn:schemas-xmlsoap-org:ws:2005:04:discovery";	
./test2.c:	soap->header = header;
./test2.c:	const char *was_To = "urn:schemas-xmlsoap-org:ws:2005:04:discovery";
./test2.c:	soap->header = &header;
./test2.c:            if (soap->error)
./test2.c:                printf("[%d]: recv soap error :%d, %s, %s\n", __LINE__, soap->error, *soap_faultcode(soap), *soap_faultstring(soap)); 
./test2.c:			    retval = soap->error;
./test2.c:		else if (soap->error)  
./test2.c:				printf("[%s][%s][Line:%d] Thers Device discovery or soap error: %d, %s, %s \n",__FILE__, __func__, __LINE__, soap->error, *soap_faultcode(soap), *soap_faultstring(soap)); 
./test2.c:				retval = soap->error;  
./test2.c:            if (soap->error)  
./test2.c:                    printf("[%s][%d]--->>> soap error: %d, %s, %s\n", __func__, __LINE__, soap->error, *soap_faultcode(soap), *soap_faultstring(soap));  
./test2.c:                    retval = soap->error;  
./test2.c:          	 printf("soap error: %d, %s, %s\n", soap->error, *soap_faultcode(soap), *soap_faultstring(soap));  
./test2.c:           	 result = soap->error;  
./test2.c:        if (soap->error) {  
./test2.c:        printf("soap error: %d, %s, %s\n", soap->error, *soap_faultcode(soap), *soap_faultstring(soap));  
./test2.c:        result = soap->error;  
./test2.c:		if(soap->error){
./test2.c:			printf("soap_call___tds__SetSystemDateAndTime faild %d ,%s ,%s\n",soap->error, *soap_faultcode(soap), *soap_faultstring(soap));
./test2.c:			ret = soap->error;
./test2.c:	return soap->error;
匹配到二进制文件 ./wsseapi.o
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./TEST.log:Push namespace binding (level=0) 's'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Push namespace binding (level=0) 'sc'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Attribute 'xmlns:SOAP-ENV'='http://www.w3.org/2003/05/soap-envelope'
./TEST.log:Attribute 'xmlns:SOAP-ENC'='http://www.w3.org/2003/05/soap-encoding'
./TEST.log:Set attribute EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary'
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:dn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:d="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing"><s:Header><a:MessageID>uuid:93c2689d-efde-40ea-bbe0-df38579d0397</a:MessageID><a:To>urn:schemas-xmlsoap-org:ws:2005:04:discovery</a:To><a:Action>http://schemas.xmlsoap.org/ws/2005/04/discovery/ProbeMatches</a:Action><a:RelatesTo>b9335468-079c-4227-97c7-47a68f59fa8f</a:RelatesTo></s:Header><s:Body><d:ProbeMatches><d:ProbeMatch><a:EndpointReference><a:Address>uuid:040a347f-c505-4a91-971c-34deb6f94463</a:Address></a:EndpointReference><d:Types>dn:NetworkVideoTransmitter tds:Device</d:Types><d:Scopes>onvif://www.onvif.org/location/country/china onvif://www.onvif.org/name/Dahua onvif://www.onvif.org/hardware/IPC-HDW1025C onvif://www.onvif.org/Profile/Streaming onvif://www.onvif.org/type/Network_Video_Transmitter onvif://www.onvif.org/extension/unique_identifier  onvif://www.onvif.org/Profile/Q/Operational</d:Scopes><d:XAddrs>http://172.10.11.53/onvif/device_service</d:XAddrs><d:MetadataVersion>1</d:MetadataVersion></d:ProbeMatch></d:ProbeMatches></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><tds:GetCapabilitiesResponse><tds:Capabilities><tt:Analytics><tt:XAddr>http://172.10.11.53/onvif/analytics_service</tt:XAddr><tt:RuleSupport>true</tt:RuleSupport><tt:AnalyticsModuleSupport>true</tt:AnalyticsModuleSupport></tt:Analytics><tt:Device><tt:XAddr>http://172.10.11.53/onvif/device_service</tt:XAddr><tt:Network><tt:IPFilter>false</tt:IPFilter><tt:ZeroConfiguration>true</tt:ZeroConfiguration><tt:IPVersion6>false</tt:IPVersion6><tt:DynDNS>false</tt:DynDNS><tt:Extension><tt:Dot11Configuration>false</tt:Dot11Configuration></tt:Extension></tt:Network><tt:System><tt:DiscoveryResolve>false</tt:DiscoveryResolve><tt:DiscoveryBye>true</tt:DiscoveryBye><tt:RemoteDiscovery>false</tt:RemoteDiscovery><tt:SystemBackup>false</tt:SystemBackup><tt:SystemLogging>true</tt:SystemLogging><tt:FirmwareUpgrade>true</tt:FirmwareUpgrade><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>0</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>10</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>20</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>30</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>40</tt:Minor></tt:SupportedVersions><tt:Extension><tt:HttpFirmwareUpgrade>true</tt:HttpFirmwareUpgrade><tt:HttpSystemBackup>false</tt:HttpSystemBackup><tt:HttpSystemLogging>false</tt:HttpSystemLogging><tt:HttpSupportInformation>false</tt:HttpSupportInformation></tt:Extension></tt:System><tt:IO><tt:InputConnectors>0</tt:InputConnectors><tt:RelayOutputs>0</tt:RelayOutputs><tt:Extension><tt:Auxiliary>false</tt:Auxiliary><tt:Extension></tt:Extension></tt:Extension></tt:IO><tt:Security><tt:TLS1.1>false</tt:TLS1.1><tt:TLS1.2>false</tt:TLS1.2><tt:OnboardKeyGeneration>false</tt:OnboardKeyGeneration><tt:AccessPolicyConfig>false</tt:AccessPolicyConfig><tt:X.509Token>false</tt:X.509Token><tt:SAMLToken>false</tt:SAMLToken><tt:KerberosToken>false</tt:KerberosToken><tt:RELToken>false</tt:RELToken><tt:Extension><tt:TLS1.0>false</tt:TLS1.0><tt:Extension><tt:Dot1X>false</tt:Dot1X><tt:SupportedEAPMethod>0</tt:SupportedEAPMethod><tt:RemoteUserHandling>false</tt:RemoteUserHandling></tt:Extension></tt:Extension></tt:Security></tt:Device><tt:Events><tt:XAddr>http://172.10.11.53/onvif/event_service</tt:XAddr><tt:WSSubscriptionPolicySupport>false</tt:WSSubscriptionPolicySupport><tt:WSPullPointSupport>false</tt:WSPullPointSupport><tt:WSPausableSubscriptionManagerInterfaceSupport>false</tt:WSPausableSubscriptionManagerInterfaceSupport></tt:Events><tt:Imaging><tt:XAddr>http://172.10.11.53/onvif/imaging_service</tt:XAddr></tt:Imaging><tt:Media><tt:XAddr>http://172.10.11.53/onvif/media_service</tt:XAddr><tt:StreamingCapabilities><tt:RTPMulticast>true</tt:RTPMulticast><tt:RTP_TCP>true</tt:RTP_TCP><tt:RTP_RTSP_TCP>true</tt:RTP_RTSP_TCP></tt:StreamingCapabilities><tt:Extension><tt:ProfileCapabilities><tt:MaximumNumberOfProfiles>6</tt:MaximumNumberOfProfiles></tt:ProfileCapabilities></tt:Extension></tt:Media><tt:Extension><tt:DeviceIO><tt:XAddr>http://172.10.11.53/onvif/deviceIO_service</tt:XAddr><tt:VideoSources>1</tt:VideoSources><tt:VideoOutputs>0</tt:VideoOutputs><tt:AudioSources>0</tt:AudioSources><tt:AudioOutputs>0</tt:AudioOutputs><tt:RelayOutputs>0</tt:RelayOutputs></tt:DeviceIO><tt:Extensions><tt:TelexCapabilities><tt:XAddr>http://172.10.11.53/onvif/telecom_service</tt:XAddr><tt:TimeOSDSupport>true</tt:TimeOSDSupport><tt:TitleOSDSupport>true</tt:TitleOSDSupport><tt:PTZ3DZoomSupport>true</tt:PTZ3DZoomSupport><tt:PTZAuxSwitchSupport>true</tt:PTZAuxSwitchSupport><tt:MotionDetectorSupport>true</tt:MotionDetectorSupport><tt:TamperDetectorSupport>true</tt:TamperDetectorSupport></tt:TelexCapabilities></tt:Extensions></tt:Extension></tds:Capabilities></tds:GetCapabilitiesResponse></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><trt:GetProfilesResponse><trt:Profiles token="MediaProfile000" fixed="true"><tt:Name>MediaProfile_Channel1_MainStream</tt:Name><tt:VideoSourceConfiguration token="000"><tt:Name>VideoSourceConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:SourceToken>000</tt:SourceToken><tt:Bounds x="0" y="0" width="2048" height="1536"/></tt:VideoSourceConfiguration><tt:VideoEncoderConfiguration token="000"><tt:Name>VideoEncoderConfig_Channel1_MainStream</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>H264</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4.000000</tt:Quality><tt:RateControl><tt:FrameRateLimit>18</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:H264><tt:GovLength>36</tt:GovLength><tt:H264Profile>High</tt:H264Profile></tt:H264><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.0</tt:IPv4Address></tt:Address><tt:Port>40000</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></tt:VideoEncoderConfiguration><tt:VideoAnalyticsConfiguration token="000"><tt:Name>VideoAnalyticsConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:AnalyticsEngineConfiguration><tt:AnalyticsModule Name="MyCellMotion" Type="tt:CellMotionEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="55"/><tt:ElementItem Name="Layout"><tt:CellLayout Columns="22" Rows="18"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:CellLayout></tt:ElementItem></tt:Parameters></tt:AnalyticsModule><tt:AnalyticsModule Name="MyTamper" Type="tt:TamperEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="48"/><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem><tt:ElementItem Name="Transformation"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:ElementItem></tt:Parameters></tt:AnalyticsModule></tt:AnalyticsEngineConfiguration><tt:RuleEngineConfiguration><tt:Rule Name="Region1" Type="tt:CellMotionDetector"><tt:Parameters><tt:SimpleItem Name="MinCount" Value="4"/><tt:SimpleItem Name="AlarmOnDelay" Value="1000"/><tt:SimpleItem Name="AlarmOffDelay" Value="1000"/><tt:SimpleItem Name="ActiveCells" Value="0P8A8A=="/></tt:Parameters></tt:Rule><tt:Rule Name="MyTamperDetector" Type="tt:TamperDetector"><tt:Parameters><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem></tt:Parameters></tt:Rule></tt:RuleEngineConfiguration></tt:VideoAnalyticsConfiguration><tt:MetadataConfiguration token="000"><tt:Name>MetadataConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:PTZStatus><tt:Status>false</tt:Status><tt:Position>false</tt:Position></tt:PTZStatus><tt:Events><tt:Filter><wsnt:TopicExpression Dialect="http://www.onvif.org/ver10/tev/topicExpression/ConcreteSet" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:tns1="http://www.onvif.org/ver10/topics">tns1:RuleEngine/CellMotionDetector/Motion</wsnt:TopicExpression></tt:Filter></tt:Events><tt:Analytics>true</tt:Analytics><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.2.0.0</tt:IPv4Address></tt:Address><tt:Port>40020</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>false</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT60S</tt:SessionTimeout></tt:MetadataConfiguration></trt:Profiles><trt:Profiles token="MediaProfile001" fixed="true"><tt:Name>MediaProfile_Channel1_SubStream1</tt:Name><tt:VideoSourceConfiguration token="000"><tt:Name>VideoSourceConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:SourceToken>000</tt:SourceToken><tt:Bounds x="0" y="0" width="2048" height="1536"/></tt:VideoSourceConfiguration><tt:VideoEncoderConfiguration token="001"><tt:Name>VideoEncoderConfig_Channel1_SubStream1</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>JPEG</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4.000000</tt:Quality><tt:RateControl><tt:FrameRateLimit>12</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.1</tt:IPv4Address></tt:Address><tt:Port>40008</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></tt:VideoEncoderConfiguration><tt:VideoAnalyticsConfiguration token="000"><tt:Name>VideoAnalyticsConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:AnalyticsEngineConfiguration><tt:AnalyticsModule Name="MyCellMotion" Type="tt:CellMotionEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="55"/><tt:ElementItem Name="Layout"><tt:CellLayout Columns="22" Rows="18"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:CellLayout></tt:ElementItem></tt:Parameters></tt:AnalyticsModule><tt:AnalyticsModule Name="MyTamper" Type="tt:TamperEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="48"/><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem><tt:ElementItem Name="Transformation"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:ElementItem></tt:Parameters></tt:AnalyticsModule></tt:AnalyticsEngineConfiguration><tt:RuleEngineConfiguration><tt:Rule Name="Region1" Type="tt:CellMotionDetector"><tt:Parameters><tt:SimpleItem Name="MinCount" Value="4"/><tt:SimpleItem Name="AlarmOnDelay" Value="1000"/><tt:SimpleItem Name="AlarmOffDelay" Value="1000"/><tt:SimpleItem Name="ActiveCells" Value="0P8A8A=="/></tt:Parameters></tt:Rule><tt:Rule Name="MyTamperDetector" Type="tt:TamperDetector"><tt:Parameters><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem></tt:Parameters></tt:Rule></tt:RuleEngineConfiguration></tt:VideoAnalyticsConfiguration><tt:MetadataConfiguration token="000"><tt:Name>MetadataConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:PTZStatus><tt:Status>false</tt:Status><tt:Position>false</tt:Position></tt:PTZStatus><tt:Events><tt:Filter><wsnt:TopicExpression Dialect="http://www.onvif.org/ver10/tev/topicExpression/ConcreteSet" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:tns1="http://www.onvif.org/ver10/topics">tns1:RuleEngine/CellMotionDetector/Motion</wsnt:TopicExpression></tt:Filter></tt:Events><tt:Analytics>true</tt:Analytics><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.2.0.0</tt:IPv4Address></tt:Address><tt:Port>40020</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>false</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT60S</tt:SessionTimeout></tt:MetadataConfiguration></trt:Profiles></trt:GetProfilesResponse></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:wsrf-bf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:ter="http://www.onvif.org/ver10/error" xmlns:d="http://schemas.xmlsoap.org/ws/2005/04/discovery"><s:Body><s:Fault><s:Code><s:Value>s:Sender</s:Value><s:Subcode><s:Value>ter:InvalidArgVal</s:Value><s:Subcode><s:Value>ter:ConfigModify</s:Value></s:Subcode></s:Subcode></s:Code><s:Reason><s:Text xml:lang="en">Parameters can not be set</s:Text></s:Reason></s:Fault></s:Body></s:Envelope><?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:dn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:d="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing"><s:Header><a:MessageID>uuid:7722e689-c0a0-4f5f-ab2c-78084f06da8f</a:MessageID><a:To>urn:schemas-xmlsoap-org:ws:2005:04:discovery</a:To><a:Action>http://schemas.xmlsoap.org/ws/2005/04/discovery/ProbeMatches</a:Action><a:RelatesTo>404449fb-b604-46f9-8ad0-f33cf94d8133</a:RelatesTo></s:Header><s:Body><d:ProbeMatches><d:ProbeMatch><a:EndpointReference><a:Address>uuid:040a347f-c505-4a91-971c-34deb6f94463</a:Address></a:EndpointReference><d:Types>dn:NetworkVideoTransmitter tds:Device</d:Types><d:Scopes>onvif://www.onvif.org/location/country/china onvif://www.onvif.org/name/Dahua onvif://www.onvif.org/hardware/IPC-HDW1025C onvif://www.onvif.org/Profile/Streaming onvif://www.onvif.org/type/Network_Video_Transmitter onvif://www.onvif.org/extension/unique_identifier  onvif://www.onvif.org/Profile/Q/Operational</d:Scopes><d:XAddrs>http://172.10.11.53/onvif/device_service</d:XAddrs><d:MetadataVersion>1</d:MetadataVersion></d:ProbeMatch></d:ProbeMatches></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><tds:GetCapabilitiesResponse><tds:Capabilities><tt:Analytics><tt:XAddr>http://172.10.11.53/onvif/analytics_service</tt:XAddr><tt:RuleSupport>true</tt:RuleSupport><tt:AnalyticsModuleSupport>true</tt:AnalyticsModuleSupport></tt:Analytics><tt:Device><tt:XAddr>http://172.10.11.53/onvif/device_service</tt:XAddr><tt:Network><tt:IPFilter>false</tt:IPFilter><tt:ZeroConfiguration>true</tt:ZeroConfiguration><tt:IPVersion6>false</tt:IPVersion6><tt:DynDNS>false</tt:DynDNS><tt:Extension><tt:Dot11Configuration>false</tt:Dot11Configuration></tt:Extension></tt:Network><tt:System><tt:DiscoveryResolve>false</tt:DiscoveryResolve><tt:DiscoveryBye>true</tt:DiscoveryBye><tt:RemoteDiscovery>false</tt:RemoteDiscovery><tt:SystemBackup>false</tt:SystemBackup><tt:SystemLogging>true</tt:SystemLogging><tt:FirmwareUpgrade>true</tt:FirmwareUpgrade><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>0</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>10</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>20</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>30</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>40</tt:Minor></tt:SupportedVersions><tt:Extension><tt:HttpFirmwareUpgrade>true</tt:HttpFirmwareUpgrade><tt:HttpSystemBackup>false</tt:HttpSystemBackup><tt:HttpSystemLogging>false</tt:HttpSystemLogging><tt:HttpSupportInformation>false</tt:HttpSupportInformation></tt:Extension></tt:System><tt:IO><tt:InputConnectors>0</tt:InputConnectors><tt:RelayOutputs>0</tt:RelayOutputs><tt:Extension><tt:Auxiliary>false</tt:Auxiliary><tt:Extension></tt:Extension></tt:Extension></tt:IO><tt:Security><tt:TLS1.1>false</tt:TLS1.1><tt:TLS1.2>false</tt:TLS1.2><tt:OnboardKeyGeneration>false</tt:OnboardKeyGeneration><tt:AccessPolicyConfig>false</tt:AccessPolicyConfig><tt:X.509Token>false</tt:X.509Token><tt:SAMLToken>false</tt:SAMLToken><tt:KerberosToken>false</tt:KerberosToken><tt:RELToken>false</tt:RELToken><tt:Extension><tt:TLS1.0>false</tt:TLS1.0><tt:Extension><tt:Dot1X>false</tt:Dot1X><tt:SupportedEAPMethod>0</tt:SupportedEAPMethod><tt:RemoteUserHandling>false</tt:RemoteUserHandling></tt:Extension></tt:Extension></tt:Security></tt:Device><tt:Events><tt:XAddr>http://172.10.11.53/onvif/event_service</tt:XAddr><tt:WSSubscriptionPolicySupport>false</tt:WSSubscriptionPolicySupport><tt:WSPullPointSupport>false</tt:WSPullPointSupport><tt:WSPausableSubscriptionManagerInterfaceSupport>false</tt:WSPausableSubscriptionManagerInterfaceSupport></tt:Events><tt:Imaging><tt:XAddr>http://172.10.11.53/onvif/imaging_service</tt:XAddr></tt:Imaging><tt:Media><tt:XAddr>http://172.10.11.53/onvif/media_service</tt:XAddr><tt:StreamingCapabilities><tt:RTPMulticast>true</tt:RTPMulticast><tt:RTP_TCP>true</tt:RTP_TCP><tt:RTP_RTSP_TCP>true</tt:RTP_RTSP_TCP></tt:StreamingCapabilities><tt:Extension><tt:ProfileCapabilities><tt:MaximumNumberOfProfiles>6</tt:MaximumNumberOfProfiles></tt:ProfileCapabilities></tt:Extension></tt:Media><tt:Extension><tt:DeviceIO><tt:XAddr>http://172.10.11.53/onvif/deviceIO_service</tt:XAddr><tt:VideoSources>1</tt:VideoSources><tt:VideoOutputs>0</tt:VideoOutputs><tt:AudioSources>0</tt:AudioSources><tt:AudioOutputs>0</tt:AudioOutputs><tt:RelayOutputs>0</tt:RelayOutputs></tt:DeviceIO><tt:Extensions><tt:TelexCapabilities><tt:XAddr>http://172.10.11.53/onvif/telecom_service</tt:XAddr><tt:TimeOSDSupport>true</tt:TimeOSDSupport><tt:TitleOSDSupport>true</tt:TitleOSDSupport><tt:PTZ3DZoomSupport>true</tt:PTZ3DZoomSupport><tt:PTZAuxSwitchSupport>true</tt:PTZAuxSwitchSupport><tt:MotionDetectorSupport>true</tt:MotionDetectorSupport><tt:TamperDetectorSupport>true</tt:TamperDetectorSupport></tt:TelexCapabilities></tt:Extensions></tt:Extension></tds:Capabilities></tds:GetCapabilitiesResponse></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><trt:GetProfilesResponse><trt:Profiles token="MediaProfile000" fixed="true"><tt:Name>MediaProfile_Channel1_MainStream</tt:Name><tt:VideoSourceConfiguration token="000"><tt:Name>VideoSourceConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:SourceToken>000</tt:SourceToken><tt:Bounds x="0" y="0" width="2048" height="1536"/></tt:VideoSourceConfiguration><tt:VideoEncoderConfiguration token="000"><tt:Name>VideoEncoderConfig_Channel1_MainStream</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>H264</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4.000000</tt:Quality><tt:RateControl><tt:FrameRateLimit>18</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:H264><tt:GovLength>36</tt:GovLength><tt:H264Profile>High</tt:H264Profile></tt:H264><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.0</tt:IPv4Address></tt:Address><tt:Port>40000</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></tt:VideoEncoderConfiguration><tt:VideoAnalyticsConfiguration token="000"><tt:Name>VideoAnalyticsConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:AnalyticsEngineConfiguration><tt:AnalyticsModule Name="MyCellMotion" Type="tt:CellMotionEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="55"/><tt:ElementItem Name="Layout"><tt:CellLayout Columns="22" Rows="18"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:CellLayout></tt:ElementItem></tt:Parameters></tt:AnalyticsModule><tt:AnalyticsModule Name="MyTamper" Type="tt:TamperEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="48"/><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem><tt:ElementItem Name="Transformation"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:ElementItem></tt:Parameters></tt:AnalyticsModule></tt:AnalyticsEngineConfiguration><tt:RuleEngineConfiguration><tt:Rule Name="Region1" Type="tt:CellMotionDetector"><tt:Parameters><tt:SimpleItem Name="MinCount" Value="4"/><tt:SimpleItem Name="AlarmOnDelay" Value="1000"/><tt:SimpleItem Name="AlarmOffDelay" Value="1000"/><tt:SimpleItem Name="ActiveCells" Value="0P8A8A=="/></tt:Parameters></tt:Rule><tt:Rule Name="MyTamperDetector" Type="tt:TamperDetector"><tt:Parameters><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem></tt:Parameters></tt:Rule></tt:RuleEngineConfiguration></tt:VideoAnalyticsConfiguration><tt:MetadataConfiguration token="000"><tt:Name>MetadataConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:PTZStatus><tt:Status>false</tt:Status><tt:Position>false</tt:Position></tt:PTZStatus><tt:Events><tt:Filter><wsnt:TopicExpression Dialect="http://www.onvif.org/ver10/tev/topicExpression/ConcreteSet" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:tns1="http://www.onvif.org/ver10/topics">tns1:RuleEngine/CellMotionDetector/Motion</wsnt:TopicExpression></tt:Filter></tt:Events><tt:Analytics>true</tt:Analytics><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.2.0.0</tt:IPv4Address></tt:Address><tt:Port>40020</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>false</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT60S</tt:SessionTimeout></tt:MetadataConfiguration></trt:Profiles><trt:Profiles token="MediaProfile001" fixed="true"><tt:Name>MediaProfile_Channel1_SubStream1</tt:Name><tt:VideoSourceConfiguration token="000"><tt:Name>VideoSourceConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:SourceToken>000</tt:SourceToken><tt:Bounds x="0" y="0" width="2048" height="1536"/></tt:VideoSourceConfiguration><tt:VideoEncoderConfiguration token="001"><tt:Name>VideoEncoderConfig_Channel1_SubStream1</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>JPEG</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4.000000</tt:Quality><tt:RateControl><tt:FrameRateLimit>12</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.1</tt:IPv4Address></tt:Address><tt:Port>40008</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></tt:VideoEncoderConfiguration><tt:VideoAnalyticsConfiguration token="000"><tt:Name>VideoAnalyticsConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:AnalyticsEngineConfiguration><tt:AnalyticsModule Name="MyCellMotion" Type="tt:CellMotionEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="55"/><tt:ElementItem Name="Layout"><tt:CellLayout Columns="22" Rows="18"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:CellLayout></tt:ElementItem></tt:Parameters></tt:AnalyticsModule><tt:AnalyticsModule Name="MyTamper" Type="tt:TamperEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="48"/><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem><tt:ElementItem Name="Transformation"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:ElementItem></tt:Parameters></tt:AnalyticsModule></tt:AnalyticsEngineConfiguration><tt:RuleEngineConfiguration><tt:Rule Name="Region1" Type="tt:CellMotionDetector"><tt:Parameters><tt:SimpleItem Name="MinCount" Value="4"/><tt:SimpleItem Name="AlarmOnDelay" Value="1000"/><tt:SimpleItem Name="AlarmOffDelay" Value="1000"/><tt:SimpleItem Name="ActiveCells" Value="0P8A8A=="/></tt:Parameters></tt:Rule><tt:Rule Name="MyTamperDetector" Type="tt:TamperDetector"><tt:Parameters><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem></tt:Parameters></tt:Rule></tt:RuleEngineConfiguration></tt:VideoAnalyticsConfiguration><tt:MetadataConfiguration token="000"><tt:Name>MetadataConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:PTZStatus><tt:Status>false</tt:Status><tt:Position>false</tt:Position></tt:PTZStatus><tt:Events><tt:Filter><wsnt:TopicExpression Dialect="http://www.onvif.org/ver10/tev/topicExpression/ConcreteSet" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:tns1="http://www.onvif.org/ver10/topics">tns1:RuleEngine/CellMotionDetector/Motion</wsnt:TopicExpression></tt:Filter></tt:Events><tt:Analytics>true</tt:Analytics><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.2.0.0</tt:IPv4Address></tt:Address><tt:Port>40020</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>false</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT60S</tt:SessionTimeout></tt:MetadataConfiguration></trt:Profiles></trt:GetProfilesResponse></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:wsrf-bf="http://docs.oasis-open.org/wsrf/bf-2" xmlns:ter="http://www.onvif.org/ver10/error" xmlns:d="http://schemas.xmlsoap.org/ws/2005/04/discovery"><s:Body><s:Fault><s:Code><s:Value>s:Sender</s:Value><s:Subcode><s:Value>ter:InvalidArgVal</s:Value><s:Subcode><s:Value>ter:ConfigModify</s:Value></s:Subcode></s:Subcode></s:Code><s:Reason><s:Text xml:lang="en">Parameters can not be set</s:Text></s:Reason></s:Fault></s:Body></s:Envelope><?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:dn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:d="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing"><s:Header><a:MessageID>uuid:d55156ae-5326-448d-abc5-8bdadd999eab</a:MessageID><a:To>urn:schemas-xmlsoap-org:ws:2005:04:discovery</a:To><a:Action>http://schemas.xmlsoap.org/ws/2005/04/discovery/ProbeMatches</a:Action><a:RelatesTo>00243a88-2277-4738-b151-9a6e8c99c6e3</a:RelatesTo></s:Header><s:Body><d:ProbeMatches><d:ProbeMatch><a:EndpointReference><a:Address>uuid:040a347f-c505-4a91-971c-34deb6f94463</a:Address></a:EndpointReference><d:Types>dn:NetworkVideoTransmitter tds:Device</d:Types><d:Scopes>onvif://www.onvif.org/location/country/china onvif://www.onvif.org/name/Dahua onvif://www.onvif.org/hardware/IPC-HDW1025C onvif://www.onvif.org/Profile/Streaming onvif://www.onvif.org/type/Network_Video_Transmitter onvif://www.onvif.org/extension/unique_identifier  onvif://www.onvif.org/Profile/Q/Operational</d:Scopes><d:XAddrs>http://172.10.11.53/onvif/device_service</d:XAddrs><d:MetadataVersion>1</d:MetadataVersion></d:ProbeMatch></d:ProbeMatches></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><tds:GetCapabilitiesResponse><tds:Capabilities><tt:Analytics><tt:XAddr>http://172.10.11.53/onvif/analytics_service</tt:XAddr><tt:RuleSupport>true</tt:RuleSupport><tt:AnalyticsModuleSupport>true</tt:AnalyticsModuleSupport></tt:Analytics><tt:Device><tt:XAddr>http://172.10.11.53/onvif/device_service</tt:XAddr><tt:Network><tt:IPFilter>false</tt:IPFilter><tt:ZeroConfiguration>true</tt:ZeroConfiguration><tt:IPVersion6>false</tt:IPVersion6><tt:DynDNS>false</tt:DynDNS><tt:Extension><tt:Dot11Configuration>false</tt:Dot11Configuration></tt:Extension></tt:Network><tt:System><tt:DiscoveryResolve>false</tt:DiscoveryResolve><tt:DiscoveryBye>true</tt:DiscoveryBye><tt:RemoteDiscovery>false</tt:RemoteDiscovery><tt:SystemBackup>false</tt:SystemBackup><tt:SystemLogging>true</tt:SystemLogging><tt:FirmwareUpgrade>true</tt:FirmwareUpgrade><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>0</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>10</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>20</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>30</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>40</tt:Minor></tt:SupportedVersions><tt:Extension><tt:HttpFirmwareUpgrade>true</tt:HttpFirmwareUpgrade><tt:HttpSystemBackup>false</tt:HttpSystemBackup><tt:HttpSystemLogging>false</tt:HttpSystemLogging><tt:HttpSupportInformation>false</tt:HttpSupportInformation></tt:Extension></tt:System><tt:IO><tt:InputConnectors>0</tt:InputConnectors><tt:RelayOutputs>0</tt:RelayOutputs><tt:Extension><tt:Auxiliary>false</tt:Auxiliary><tt:Extension></tt:Extension></tt:Extension></tt:IO><tt:Security><tt:TLS1.1>false</tt:TLS1.1><tt:TLS1.2>false</tt:TLS1.2><tt:OnboardKeyGeneration>false</tt:OnboardKeyGeneration><tt:AccessPolicyConfig>false</tt:AccessPolicyConfig><tt:X.509Token>false</tt:X.509Token><tt:SAMLToken>false</tt:SAMLToken><tt:KerberosToken>false</tt:KerberosToken><tt:RELToken>false</tt:RELToken><tt:Extension><tt:TLS1.0>false</tt:TLS1.0><tt:Extension><tt:Dot1X>false</tt:Dot1X><tt:SupportedEAPMethod>0</tt:SupportedEAPMethod><tt:RemoteUserHandling>false</tt:RemoteUserHandling></tt:Extension></tt:Extension></tt:Security></tt:Device><tt:Events><tt:XAddr>http://172.10.11.53/onvif/event_service</tt:XAddr><tt:WSSubscriptionPolicySupport>false</tt:WSSubscriptionPolicySupport><tt:WSPullPointSupport>false</tt:WSPullPointSupport><tt:WSPausableSubscriptionManagerInterfaceSupport>false</tt:WSPausableSubscriptionManagerInterfaceSupport></tt:Events><tt:Imaging><tt:XAddr>http://172.10.11.53/onvif/imaging_service</tt:XAddr></tt:Imaging><tt:Media><tt:XAddr>http://172.10.11.53/onvif/media_service</tt:XAddr><tt:StreamingCapabilities><tt:RTPMulticast>true</tt:RTPMulticast><tt:RTP_TCP>true</tt:RTP_TCP><tt:RTP_RTSP_TCP>true</tt:RTP_RTSP_TCP></tt:StreamingCapabilities><tt:Extension><tt:ProfileCapabilities><tt:MaximumNumberOfProfiles>6</tt:MaximumNumberOfProfiles></tt:ProfileCapabilities></tt:Extension></tt:Media><tt:Extension><tt:DeviceIO><tt:XAddr>http://172.10.11.53/onvif/deviceIO_service</tt:XAddr><tt:VideoSources>1</tt:VideoSources><tt:VideoOutputs>0</tt:VideoOutputs><tt:AudioSources>0</tt:AudioSources><tt:AudioOutputs>0</tt:AudioOutputs><tt:RelayOutputs>0</tt:RelayOutputs></tt:DeviceIO><tt:Extensions><tt:TelexCapabilities><tt:XAddr>http://172.10.11.53/onvif/telecom_service</tt:XAddr><tt:TimeOSDSupport>true</tt:TimeOSDSupport><tt:TitleOSDSupport>true</tt:TitleOSDSupport><tt:PTZ3DZoomSupport>true</tt:PTZ3DZoomSupport><tt:PTZAuxSwitchSupport>true</tt:PTZAuxSwitchSupport><tt:MotionDetectorSupport>true</tt:MotionDetectorSupport><tt:TamperDetectorSupport>true</tt:TamperDetectorSupport></tt:TelexCapabilities></tt:Extensions></tt:Extension></tds:Capabilities></tds:GetCapabilitiesResponse></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><trt:GetProfilesResponse><trt:Profiles token="MediaProfile000" fixed="true"><tt:Name>MediaProfile_Channel1_MainStream</tt:Name><tt:VideoSourceConfiguration token="000"><tt:Name>VideoSourceConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:SourceToken>000</tt:SourceToken><tt:Bounds x="0" y="0" width="2048" height="1536"/></tt:VideoSourceConfiguration><tt:VideoEncoderConfiguration token="000"><tt:Name>VideoEncoderConfig_Channel1_MainStream</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>H264</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4.000000</tt:Quality><tt:RateControl><tt:FrameRateLimit>18</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:H264><tt:GovLength>36</tt:GovLength><tt:H264Profile>High</tt:H264Profile></tt:H264><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.0</tt:IPv4Address></tt:Address><tt:Port>40000</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></tt:VideoEncoderConfiguration><tt:VideoAnalyticsConfiguration token="000"><tt:Name>VideoAnalyticsConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:AnalyticsEngineConfiguration><tt:AnalyticsModule Name="MyCellMotion" Type="tt:CellMotionEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="55"/><tt:ElementItem Name="Layout"><tt:CellLayout Columns="22" Rows="18"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:CellLayout></tt:ElementItem></tt:Parameters></tt:AnalyticsModule><tt:AnalyticsModule Name="MyTamper" Type="tt:TamperEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="48"/><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem><tt:ElementItem Name="Transformation"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:ElementItem></tt:Parameters></tt:AnalyticsModule></tt:AnalyticsEngineConfiguration><tt:RuleEngineConfiguration><tt:Rule Name="Region1" Type="tt:CellMotionDetector"><tt:Parameters><tt:SimpleItem Name="MinCount" Value="4"/><tt:SimpleItem Name="AlarmOnDelay" Value="1000"/><tt:SimpleItem Name="AlarmOffDelay" Value="1000"/><tt:SimpleItem Name="ActiveCells" Value="0P8A8A=="/></tt:Parameters></tt:Rule><tt:Rule Name="MyTamperDetector" Type="tt:TamperDetector"><tt:Parameters><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem></tt:Parameters></tt:Rule></tt:RuleEngineConfiguration></tt:VideoAnalyticsConfiguration><tt:MetadataConfiguration token="000"><tt:Name>MetadataConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:PTZStatus><tt:Status>false</tt:Status><tt:Position>false</tt:Position></tt:PTZStatus><tt:Events><tt:Filter><wsnt:TopicExpression Dialect="http://www.onvif.org/ver10/tev/topicExpression/ConcreteSet" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:tns1="http://www.onvif.org/ver10/topics">tns1:RuleEngine/CellMotionDetector/Motion</wsnt:TopicExpression></tt:Filter></tt:Events><tt:Analytics>true</tt:Analytics><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.2.0.0</tt:IPv4Address></tt:Address><tt:Port>40020</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>false</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT60S</tt:SessionTimeout></tt:MetadataConfiguration></trt:Profiles><trt:Profiles token="MediaProfile001" fixed="true"><tt:Name>MediaProfile_Channel1_SubStream1</tt:Name><tt:VideoSourceConfiguration token="000"><tt:Name>VideoSourceConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:SourceToken>000</tt:SourceToken><tt:Bounds x="0" y="0" width="2048" height="1536"/></tt:VideoSourceConfiguration><tt:VideoEncoderConfiguration token="001"><tt:Name>VideoEncoderConfig_Channel1_SubStream1</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>JPEG</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4.000000</tt:Quality><tt:RateControl><tt:FrameRateLimit>12</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.1</tt:IPv4Address></tt:Address><tt:Port>40008</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></tt:VideoEncoderConfiguration><tt:VideoAnalyticsConfiguration token="000"><tt:Name>VideoAnalyticsConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:AnalyticsEngineConfiguration><tt:AnalyticsModule Name="MyCellMotion" Type="tt:CellMotionEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="55"/><tt:ElementItem Name="Layout"><tt:CellLayout Columns="22" Rows="18"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:CellLayout></tt:ElementItem></tt:Parameters></tt:AnalyticsModule><tt:AnalyticsModule Name="MyTamper" Type="tt:TamperEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="48"/><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem><tt:ElementItem Name="Transformation"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:ElementItem></tt:Parameters></tt:AnalyticsModule></tt:AnalyticsEngineConfiguration><tt:RuleEngineConfiguration><tt:Rule Name="Region1" Type="tt:CellMotionDetector"><tt:Parameters><tt:SimpleItem Name="MinCount" Value="4"/><tt:SimpleItem Name="AlarmOnDelay" Value="1000"/><tt:SimpleItem Name="AlarmOffDelay" Value="1000"/><tt:SimpleItem Name="ActiveCells" Value="0P8A8A=="/></tt:Parameters></tt:Rule><tt:Rule Name="MyTamperDetector" Type="tt:TamperDetector"><tt:Parameters><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem></tt:Parameters></tt:Rule></tt:RuleEngineConfiguration></tt:VideoAnalyticsConfiguration><tt:MetadataConfiguration token="000"><tt:Name>MetadataConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:PTZStatus><tt:Status>false</tt:Status><tt:Position>false</tt:Position></tt:PTZStatus><tt:Events><tt:Filter><wsnt:TopicExpression Dialect="http://www.onvif.org/ver10/tev/topicExpression/ConcreteSet" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:tns1="http://www.onvif.org/ver10/topics">tns1:RuleEngine/CellMotionDetector/Motion</wsnt:TopicExpression></tt:Filter></tt:Events><tt:Analytics>true</tt:Analytics><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.2.0.0</tt:IPv4Address></tt:Address><tt:Port>40020</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>false</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT60S</tt:SessionTimeout></tt:MetadataConfiguration></trt:Profiles></trt:GetProfilesResponse></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><trt:SetVideoEncoderConfigurationResponse/></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><trt:SetVideoEncoderConfigurationResponse/></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><tds:GetNetworkInterfacesResponse><tds:NetworkInterfaces token="eth0"><tt:Enabled>true</tt:Enabled><tt:Info><tt:Name>eth0</tt:Name><tt:HwAddress>e0:50:8b:06:f6:9f</tt:HwAddress><tt:MTU>1500</tt:MTU></tt:Info><tt:Link><tt:AdminSettings><tt:AutoNegotiation>false</tt:AutoNegotiation><tt:Speed>10</tt:Speed><tt:Duplex>Full</tt:Duplex></tt:AdminSettings><tt:OperSettings><tt:AutoNegotiation>false</tt:AutoNegotiation><tt:Speed>10</tt:Speed><tt:Duplex>Full</tt:Duplex></tt:OperSettings><tt:InterfaceType>6</tt:InterfaceType></tt:Link><tt:IPv4><tt:Enabled>true</tt:Enabled><tt:Config><tt:Manual><tt:Address>172.10.11.53</tt:Address><tt:PrefixLength>32</tt:PrefixLength></tt:Manual><tt:DHCP>false</tt:DHCP></tt:Config></tt:IPv4><tt:IPv6><tt:Enabled>true</tt:Enabled><tt:Config><tt:AcceptRouterAdvert>false</tt:AcceptRouterAdvert><tt:DHCP>Off</tt:DHCP><tt:Manual><tt:Address></tt:Address><tt:PrefixLength>0</tt:PrefixLength></tt:Manual><tt:LinkLocal><tt:Address>fe80::e250:8bff:fe06:f69f</tt:Address><tt:PrefixLength>64</tt:PrefixLength></tt:LinkLocal><tt:FromRA><tt:Address>2001:250:3000:3ca0:215:f2ff:fe5d:2301</tt:Address><tt:PrefixLength>64</tt:PrefixLength></tt:FromRA></tt:Config></tt:IPv6></tds:NetworkInterfaces></tds:GetNetworkInterfacesResponse></s:Body></s:Envelope><?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:dn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:d="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing"><s:Header><a:MessageID>uuid:5ddc378c-49a4-4ac0-a3e4-1631388df7ea</a:MessageID><a:To>urn:schemas-xmlsoap-org:ws:2005:04:discovery</a:To><a:Action>http://schemas.xmlsoap.org/ws/2005/04/discovery/ProbeMatches</a:Action><a:RelatesTo>2e3ece47-602e-42ce-8908-04831e1a13a0</a:RelatesTo></s:Header><s:Body><d:ProbeMatches><d:ProbeMatch><a:EndpointReference><a:Address>uuid:040a347f-c505-4a91-971c-34deb6f94463</a:Address></a:EndpointReference><d:Types>dn:NetworkVideoTransmitter tds:Device</d:Types><d:Scopes>onvif://www.onvif.org/location/country/china onvif://www.onvif.org/name/Dahua onvif://www.onvif.org/hardware/IPC-HDW1025C onvif://www.onvif.org/Profile/Streaming onvif://www.onvif.org/type/Network_Video_Transmitter onvif://www.onvif.org/extension/unique_identifier  onvif://www.onvif.org/Profile/Q/Operational</d:Scopes><d:XAddrs>http://172.10.11.53/onvif/device_service</d:XAddrs><d:MetadataVersion>1</d:MetadataVersion></d:ProbeMatch></d:ProbeMatches></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><tds:GetCapabilitiesResponse><tds:Capabilities><tt:Analytics><tt:XAddr>http://172.10.11.53/onvif/analytics_service</tt:XAddr><tt:RuleSupport>true</tt:RuleSupport><tt:AnalyticsModuleSupport>true</tt:AnalyticsModuleSupport></tt:Analytics><tt:Device><tt:XAddr>http://172.10.11.53/onvif/device_service</tt:XAddr><tt:Network><tt:IPFilter>false</tt:IPFilter><tt:ZeroConfiguration>true</tt:ZeroConfiguration><tt:IPVersion6>false</tt:IPVersion6><tt:DynDNS>false</tt:DynDNS><tt:Extension><tt:Dot11Configuration>false</tt:Dot11Configuration></tt:Extension></tt:Network><tt:System><tt:DiscoveryResolve>false</tt:DiscoveryResolve><tt:DiscoveryBye>true</tt:DiscoveryBye><tt:RemoteDiscovery>false</tt:RemoteDiscovery><tt:SystemBackup>false</tt:SystemBackup><tt:SystemLogging>true</tt:SystemLogging><tt:FirmwareUpgrade>true</tt:FirmwareUpgrade><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>0</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>10</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>20</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>30</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>40</tt:Minor></tt:SupportedVersions><tt:Extension><tt:HttpFirmwareUpgrade>true</tt:HttpFirmwareUpgrade><tt:HttpSystemBackup>false</tt:HttpSystemBackup><tt:HttpSystemLogging>false</tt:HttpSystemLogging><tt:HttpSupportInformation>false</tt:HttpSupportInformation></tt:Extension></tt:System><tt:IO><tt:InputConnectors>0</tt:InputConnectors><tt:RelayOutputs>0</tt:RelayOutputs><tt:Extension><tt:Auxiliary>false</tt:Auxiliary><tt:Extension></tt:Extension></tt:Extension></tt:IO><tt:Security><tt:TLS1.1>false</tt:TLS1.1><tt:TLS1.2>false</tt:TLS1.2><tt:OnboardKeyGeneration>false</tt:OnboardKeyGeneration><tt:AccessPolicyConfig>false</tt:AccessPolicyConfig><tt:X.509Token>false</tt:X.509Token><tt:SAMLToken>false</tt:SAMLToken><tt:KerberosToken>false</tt:KerberosToken><tt:RELToken>false</tt:RELToken><tt:Extension><tt:TLS1.0>false</tt:TLS1.0><tt:Extension><tt:Dot1X>false</tt:Dot1X><tt:SupportedEAPMethod>0</tt:SupportedEAPMethod><tt:RemoteUserHandling>false</tt:RemoteUserHandling></tt:Extension></tt:Extension></tt:Security></tt:Device><tt:Events><tt:XAddr>http://172.10.11.53/onvif/event_service</tt:XAddr><tt:WSSubscriptionPolicySupport>false</tt:WSSubscriptionPolicySupport><tt:WSPullPointSupport>false</tt:WSPullPointSupport><tt:WSPausableSubscriptionManagerInterfaceSupport>false</tt:WSPausableSubscriptionManagerInterfaceSupport></tt:Events><tt:Imaging><tt:XAddr>http://172.10.11.53/onvif/imaging_service</tt:XAddr></tt:Imaging><tt:Media><tt:XAddr>http://172.10.11.53/onvif/media_service</tt:XAddr><tt:StreamingCapabilities><tt:RTPMulticast>true</tt:RTPMulticast><tt:RTP_TCP>true</tt:RTP_TCP><tt:RTP_RTSP_TCP>true</tt:RTP_RTSP_TCP></tt:StreamingCapabilities><tt:Extension><tt:ProfileCapabilities><tt:MaximumNumberOfProfiles>6</tt:MaximumNumberOfProfiles></tt:ProfileCapabilities></tt:Extension></tt:Media><tt:Extension><tt:DeviceIO><tt:XAddr>http://172.10.11.53/onvif/deviceIO_service</tt:XAddr><tt:VideoSources>1</tt:VideoSources><tt:VideoOutputs>0</tt:VideoOutputs><tt:AudioSources>0</tt:AudioSources><tt:AudioOutputs>0</tt:AudioOutputs><tt:RelayOutputs>0</tt:RelayOutputs></tt:DeviceIO><tt:Extensions><tt:TelexCapabilities><tt:XAddr>http://172.10.11.53/onvif/telecom_service</tt:XAddr><tt:TimeOSDSupport>true</tt:TimeOSDSupport><tt:TitleOSDSupport>true</tt:TitleOSDSupport><tt:PTZ3DZoomSupport>true</tt:PTZ3DZoomSupport><tt:PTZAuxSwitchSupport>true</tt:PTZAuxSwitchSupport><tt:MotionDetectorSupport>true</tt:MotionDetectorSupport><tt:TamperDetectorSupport>true</tt:TamperDetectorSupport></tt:TelexCapabilities></tt:Extensions></tt:Extension></tds:Capabilities></tds:GetCapabilitiesResponse></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><trt:GetProfilesResponse><trt:Profiles token="MediaProfile000" fixed="true"><tt:Name>MediaProfile_Channel1_MainStream</tt:Name><tt:VideoSourceConfiguration token="000"><tt:Name>VideoSourceConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:SourceToken>000</tt:SourceToken><tt:Bounds x="0" y="0" width="2048" height="1536"/></tt:VideoSourceConfiguration><tt:VideoEncoderConfiguration token="000"><tt:Name>VideoEncoderConfig_Channel1_MainStream</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>H264</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4.000000</tt:Quality><tt:RateControl><tt:FrameRateLimit>18</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:H264><tt:GovLength>36</tt:GovLength><tt:H264Profile>High</tt:H264Profile></tt:H264><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.0</tt:IPv4Address></tt:Address><tt:Port>40000</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></tt:VideoEncoderConfiguration><tt:VideoAnalyticsConfiguration token="000"><tt:Name>VideoAnalyticsConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:AnalyticsEngineConfiguration><tt:AnalyticsModule Name="MyCellMotion" Type="tt:CellMotionEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="55"/><tt:ElementItem Name="Layout"><tt:CellLayout Columns="22" Rows="18"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:CellLayout></tt:ElementItem></tt:Parameters></tt:AnalyticsModule><tt:AnalyticsModule Name="MyTamper" Type="tt:TamperEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="48"/><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem><tt:ElementItem Name="Transformation"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:ElementItem></tt:Parameters></tt:AnalyticsModule></tt:AnalyticsEngineConfiguration><tt:RuleEngineConfiguration><tt:Rule Name="Region1" Type="tt:CellMotionDetector"><tt:Parameters><tt:SimpleItem Name="MinCount" Value="4"/><tt:SimpleItem Name="AlarmOnDelay" Value="1000"/><tt:SimpleItem Name="AlarmOffDelay" Value="1000"/><tt:SimpleItem Name="ActiveCells" Value="0P8A8A=="/></tt:Parameters></tt:Rule><tt:Rule Name="MyTamperDetector" Type="tt:TamperDetector"><tt:Parameters><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem></tt:Parameters></tt:Rule></tt:RuleEngineConfiguration></tt:VideoAnalyticsConfiguration><tt:MetadataConfiguration token="000"><tt:Name>MetadataConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:PTZStatus><tt:Status>false</tt:Status><tt:Position>false</tt:Position></tt:PTZStatus><tt:Events><tt:Filter><wsnt:TopicExpression Dialect="http://www.onvif.org/ver10/tev/topicExpression/ConcreteSet" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:tns1="http://www.onvif.org/ver10/topics">tns1:RuleEngine/CellMotionDetector/Motion</wsnt:TopicExpression></tt:Filter></tt:Events><tt:Analytics>true</tt:Analytics><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.2.0.0</tt:IPv4Address></tt:Address><tt:Port>40020</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>false</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT60S</tt:SessionTimeout></tt:MetadataConfiguration></trt:Profiles><trt:Profiles token="MediaProfile001" fixed="true"><tt:Name>MediaProfile_Channel1_SubStream1</tt:Name><tt:VideoSourceConfiguration token="000"><tt:Name>VideoSourceConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:SourceToken>000</tt:SourceToken><tt:Bounds x="0" y="0" width="2048" height="1536"/></tt:VideoSourceConfiguration><tt:VideoEncoderConfiguration token="001"><tt:Name>VideoEncoderConfig_Channel1_SubStream1</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>JPEG</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4.000000</tt:Quality><tt:RateControl><tt:FrameRateLimit>12</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.1</tt:IPv4Address></tt:Address><tt:Port>40008</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></tt:VideoEncoderConfiguration><tt:VideoAnalyticsConfiguration token="000"><tt:Name>VideoAnalyticsConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:AnalyticsEngineConfiguration><tt:AnalyticsModule Name="MyCellMotion" Type="tt:CellMotionEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="55"/><tt:ElementItem Name="Layout"><tt:CellLayout Columns="22" Rows="18"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:CellLayout></tt:ElementItem></tt:Parameters></tt:AnalyticsModule><tt:AnalyticsModule Name="MyTamper" Type="tt:TamperEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="48"/><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem><tt:ElementItem Name="Transformation"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:ElementItem></tt:Parameters></tt:AnalyticsModule></tt:AnalyticsEngineConfiguration><tt:RuleEngineConfiguration><tt:Rule Name="Region1" Type="tt:CellMotionDetector"><tt:Parameters><tt:SimpleItem Name="MinCount" Value="4"/><tt:SimpleItem Name="AlarmOnDelay" Value="1000"/><tt:SimpleItem Name="AlarmOffDelay" Value="1000"/><tt:SimpleItem Name="ActiveCells" Value="0P8A8A=="/></tt:Parameters></tt:Rule><tt:Rule Name="MyTamperDetector" Type="tt:TamperDetector"><tt:Parameters><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem></tt:Parameters></tt:Rule></tt:RuleEngineConfiguration></tt:VideoAnalyticsConfiguration><tt:MetadataConfiguration token="000"><tt:Name>MetadataConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:PTZStatus><tt:Status>false</tt:Status><tt:Position>false</tt:Position></tt:PTZStatus><tt:Events><tt:Filter><wsnt:TopicExpression Dialect="http://www.onvif.org/ver10/tev/topicExpression/ConcreteSet" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:tns1="http://www.onvif.org/ver10/topics">tns1:RuleEngine/CellMotionDetector/Motion</wsnt:TopicExpression></tt:Filter></tt:Events><tt:Analytics>true</tt:Analytics><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.2.0.0</tt:IPv4Address></tt:Address><tt:Port>40020</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>false</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT60S</tt:SessionTimeout></tt:MetadataConfiguration></trt:Profiles></trt:GetProfilesResponse></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><trt:SetVideoEncoderConfigurationResponse/></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><trt:SetVideoEncoderConfigurationResponse/></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><tds:GetNetworkInterfacesResponse><tds:NetworkInterfaces token="eth0"><tt:Enabled>true</tt:Enabled><tt:Info><tt:Name>eth0</tt:Name><tt:HwAddress>e0:50:8b:06:f6:9f</tt:HwAddress><tt:MTU>1500</tt:MTU></tt:Info><tt:Link><tt:AdminSettings><tt:AutoNegotiation>false</tt:AutoNegotiation><tt:Speed>10</tt:Speed><tt:Duplex>Full</tt:Duplex></tt:AdminSettings><tt:OperSettings><tt:AutoNegotiation>false</tt:AutoNegotiation><tt:Speed>10</tt:Speed><tt:Duplex>Full</tt:Duplex></tt:OperSettings><tt:InterfaceType>6</tt:InterfaceType></tt:Link><tt:IPv4><tt:Enabled>true</tt:Enabled><tt:Config><tt:Manual><tt:Address>172.10.11.53</tt:Address><tt:PrefixLength>32</tt:PrefixLength></tt:Manual><tt:DHCP>false</tt:DHCP></tt:Config></tt:IPv4><tt:IPv6><tt:Enabled>true</tt:Enabled><tt:Config><tt:AcceptRouterAdvert>false</tt:AcceptRouterAdvert><tt:DHCP>Off</tt:DHCP><tt:Manual><tt:Address></tt:Address><tt:PrefixLength>0</tt:PrefixLength></tt:Manual><tt:LinkLocal><tt:Address>fe80::e250:8bff:fe06:f69f</tt:Address><tt:PrefixLength>64</tt:PrefixLength></tt:LinkLocal><tt:FromRA><tt:Address>2001:250:3000:3ca0:215:f2ff:fe5d:2301</tt:Address><tt:PrefixLength>64</tt:PrefixLength></tt:FromRA></tt:Config></tt:IPv6></tds:NetworkInterfaces></tds:GetNetworkInterfacesResponse></s:Body></s:Envelope><?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:dn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:d="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing"><s:Header><a:MessageID>uuid:f5636c41-d6fb-49da-aac1-6a1f3f4f1d66</a:MessageID><a:To>urn:schemas-xmlsoap-org:ws:2005:04:discovery</a:To><a:Action>http://schemas.xmlsoap.org/ws/2005/04/discovery/ProbeMatches</a:Action><a:RelatesTo>18c13a1a-520a-4f32-9344-0b4a5d110d76</a:RelatesTo></s:Header><s:Body><d:ProbeMatches><d:ProbeMatch><a:EndpointReference><a:Address>uuid:040a347f-c505-4a91-971c-34deb6f94463</a:Address></a:EndpointReference><d:Types>dn:NetworkVideoTransmitter tds:Device</d:Types><d:Scopes>onvif://www.onvif.org/location/country/china onvif://www.onvif.org/name/Dahua onvif://www.onvif.org/hardware/IPC-HDW1025C onvif://www.onvif.org/Profile/Streaming onvif://www.onvif.org/type/Network_Video_Transmitter onvif://www.onvif.org/extension/unique_identifier  onvif://www.onvif.org/Profile/Q/Operational</d:Scopes><d:XAddrs>http://172.10.11.53/onvif/device_service</d:XAddrs><d:MetadataVersion>1</d:MetadataVersion></d:ProbeMatch></d:ProbeMatches></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><tds:GetCapabilitiesResponse><tds:Capabilities><tt:Analytics><tt:XAddr>http://172.10.11.53/onvif/analytics_service</tt:XAddr><tt:RuleSupport>true</tt:RuleSupport><tt:AnalyticsModuleSupport>true</tt:AnalyticsModuleSupport></tt:Analytics><tt:Device><tt:XAddr>http://172.10.11.53/onvif/device_service</tt:XAddr><tt:Network><tt:IPFilter>false</tt:IPFilter><tt:ZeroConfiguration>true</tt:ZeroConfiguration><tt:IPVersion6>false</tt:IPVersion6><tt:DynDNS>false</tt:DynDNS><tt:Extension><tt:Dot11Configuration>false</tt:Dot11Configuration></tt:Extension></tt:Network><tt:System><tt:DiscoveryResolve>false</tt:DiscoveryResolve><tt:DiscoveryBye>true</tt:DiscoveryBye><tt:RemoteDiscovery>false</tt:RemoteDiscovery><tt:SystemBackup>false</tt:SystemBackup><tt:SystemLogging>true</tt:SystemLogging><tt:FirmwareUpgrade>true</tt:FirmwareUpgrade><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>0</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>10</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>20</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>30</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>40</tt:Minor></tt:SupportedVersions><tt:Extension><tt:HttpFirmwareUpgrade>true</tt:HttpFirmwareUpgrade><tt:HttpSystemBackup>false</tt:HttpSystemBackup><tt:HttpSystemLogging>false</tt:HttpSystemLogging><tt:HttpSupportInformation>false</tt:HttpSupportInformation></tt:Extension></tt:System><tt:IO><tt:InputConnectors>0</tt:InputConnectors><tt:RelayOutputs>0</tt:RelayOutputs><tt:Extension><tt:Auxiliary>false</tt:Auxiliary><tt:Extension></tt:Extension></tt:Extension></tt:IO><tt:Security><tt:TLS1.1>false</tt:TLS1.1><tt:TLS1.2>false</tt:TLS1.2><tt:OnboardKeyGeneration>false</tt:OnboardKeyGeneration><tt:AccessPolicyConfig>false</tt:AccessPolicyConfig><tt:X.509Token>false</tt:X.509Token><tt:SAMLToken>false</tt:SAMLToken><tt:KerberosToken>false</tt:KerberosToken><tt:RELToken>false</tt:RELToken><tt:Extension><tt:TLS1.0>false</tt:TLS1.0><tt:Extension><tt:Dot1X>false</tt:Dot1X><tt:SupportedEAPMethod>0</tt:SupportedEAPMethod><tt:RemoteUserHandling>false</tt:RemoteUserHandling></tt:Extension></tt:Extension></tt:Security></tt:Device><tt:Events><tt:XAddr>http://172.10.11.53/onvif/event_service</tt:XAddr><tt:WSSubscriptionPolicySupport>false</tt:WSSubscriptionPolicySupport><tt:WSPullPointSupport>false</tt:WSPullPointSupport><tt:WSPausableSubscriptionManagerInterfaceSupport>false</tt:WSPausableSubscriptionManagerInterfaceSupport></tt:Events><tt:Imaging><tt:XAddr>http://172.10.11.53/onvif/imaging_service</tt:XAddr></tt:Imaging><tt:Media><tt:XAddr>http://172.10.11.53/onvif/media_service</tt:XAddr><tt:StreamingCapabilities><tt:RTPMulticast>true</tt:RTPMulticast><tt:RTP_TCP>true</tt:RTP_TCP><tt:RTP_RTSP_TCP>true</tt:RTP_RTSP_TCP></tt:StreamingCapabilities><tt:Extension><tt:ProfileCapabilities><tt:MaximumNumberOfProfiles>6</tt:MaximumNumberOfProfiles></tt:ProfileCapabilities></tt:Extension></tt:Media><tt:Extension><tt:DeviceIO><tt:XAddr>http://172.10.11.53/onvif/deviceIO_service</tt:XAddr><tt:VideoSources>1</tt:VideoSources><tt:VideoOutputs>0</tt:VideoOutputs><tt:AudioSources>0</tt:AudioSources><tt:AudioOutputs>0</tt:AudioOutputs><tt:RelayOutputs>0</tt:RelayOutputs></tt:DeviceIO><tt:Extensions><tt:TelexCapabilities><tt:XAddr>http://172.10.11.53/onvif/telecom_service</tt:XAddr><tt:TimeOSDSupport>true</tt:TimeOSDSupport><tt:TitleOSDSupport>true</tt:TitleOSDSupport><tt:PTZ3DZoomSupport>true</tt:PTZ3DZoomSupport><tt:PTZAuxSwitchSupport>true</tt:PTZAuxSwitchSupport><tt:MotionDetectorSupport>true</tt:MotionDetectorSupport><tt:TamperDetectorSupport>true</tt:TamperDetectorSupport></tt:TelexCapabilities></tt:Extensions></tt:Extension></tds:Capabilities></tds:GetCapabilitiesResponse></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><trt:GetProfilesResponse><trt:Profiles token="MediaProfile000" fixed="true"><tt:Name>MediaProfile_Channel1_MainStream</tt:Name><tt:VideoSourceConfiguration token="000"><tt:Name>VideoSourceConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:SourceToken>000</tt:SourceToken><tt:Bounds x="0" y="0" width="2048" height="1536"/></tt:VideoSourceConfiguration><tt:VideoEncoderConfiguration token="000"><tt:Name>VideoEncoderConfig_Channel1_MainStream</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>H264</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4.000000</tt:Quality><tt:RateControl><tt:FrameRateLimit>18</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:H264><tt:GovLength>36</tt:GovLength><tt:H264Profile>High</tt:H264Profile></tt:H264><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.0</tt:IPv4Address></tt:Address><tt:Port>40000</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></tt:VideoEncoderConfiguration><tt:VideoAnalyticsConfiguration token="000"><tt:Name>VideoAnalyticsConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:AnalyticsEngineConfiguration><tt:AnalyticsModule Name="MyCellMotion" Type="tt:CellMotionEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="55"/><tt:ElementItem Name="Layout"><tt:CellLayout Columns="22" Rows="18"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:CellLayout></tt:ElementItem></tt:Parameters></tt:AnalyticsModule><tt:AnalyticsModule Name="MyTamper" Type="tt:TamperEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="48"/><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem><tt:ElementItem Name="Transformation"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:ElementItem></tt:Parameters></tt:AnalyticsModule></tt:AnalyticsEngineConfiguration><tt:RuleEngineConfiguration><tt:Rule Name="Region1" Type="tt:CellMotionDetector"><tt:Parameters><tt:SimpleItem Name="MinCount" Value="4"/><tt:SimpleItem Name="AlarmOnDelay" Value="1000"/><tt:SimpleItem Name="AlarmOffDelay" Value="1000"/><tt:SimpleItem Name="ActiveCells" Value="0P8A8A=="/></tt:Parameters></tt:Rule><tt:Rule Name="MyTamperDetector" Type="tt:TamperDetector"><tt:Parameters><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem></tt:Parameters></tt:Rule></tt:RuleEngineConfiguration></tt:VideoAnalyticsConfiguration><tt:MetadataConfiguration token="000"><tt:Name>MetadataConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:PTZStatus><tt:Status>false</tt:Status><tt:Position>false</tt:Position></tt:PTZStatus><tt:Events><tt:Filter><wsnt:TopicExpression Dialect="http://www.onvif.org/ver10/tev/topicExpression/ConcreteSet" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:tns1="http://www.onvif.org/ver10/topics">tns1:RuleEngine/CellMotionDetector/Motion</wsnt:TopicExpression></tt:Filter></tt:Events><tt:Analytics>true</tt:Analytics><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.2.0.0</tt:IPv4Address></tt:Address><tt:Port>40020</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>false</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT60S</tt:SessionTimeout></tt:MetadataConfiguration></trt:Profiles><trt:Profiles token="MediaProfile001" fixed="true"><tt:Name>MediaProfile_Channel1_SubStream1</tt:Name><tt:VideoSourceConfiguration token="000"><tt:Name>VideoSourceConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:SourceToken>000</tt:SourceToken><tt:Bounds x="0" y="0" width="2048" height="1536"/></tt:VideoSourceConfiguration><tt:VideoEncoderConfiguration token="001"><tt:Name>VideoEncoderConfig_Channel1_SubStream1</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>JPEG</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4.000000</tt:Quality><tt:RateControl><tt:FrameRateLimit>12</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.1</tt:IPv4Address></tt:Address><tt:Port>40008</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></tt:VideoEncoderConfiguration><tt:VideoAnalyticsConfiguration token="000"><tt:Name>VideoAnalyticsConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:AnalyticsEngineConfiguration><tt:AnalyticsModule Name="MyCellMotion" Type="tt:CellMotionEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="55"/><tt:ElementItem Name="Layout"><tt:CellLayout Columns="22" Rows="18"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:CellLayout></tt:ElementItem></tt:Parameters></tt:AnalyticsModule><tt:AnalyticsModule Name="MyTamper" Type="tt:TamperEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="48"/><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem><tt:ElementItem Name="Transformation"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:ElementItem></tt:Parameters></tt:AnalyticsModule></tt:AnalyticsEngineConfiguration><tt:RuleEngineConfiguration><tt:Rule Name="Region1" Type="tt:CellMotionDetector"><tt:Parameters><tt:SimpleItem Name="MinCount" Value="4"/><tt:SimpleItem Name="AlarmOnDelay" Value="1000"/><tt:SimpleItem Name="AlarmOffDelay" Value="1000"/><tt:SimpleItem Name="ActiveCells" Value="0P8A8A=="/></tt:Parameters></tt:Rule><tt:Rule Name="MyTamperDetector" Type="tt:TamperDetector"><tt:Parameters><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem></tt:Parameters></tt:Rule></tt:RuleEngineConfiguration></tt:VideoAnalyticsConfiguration><tt:MetadataConfiguration token="000"><tt:Name>MetadataConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:PTZStatus><tt:Status>false</tt:Status><tt:Position>false</tt:Position></tt:PTZStatus><tt:Events><tt:Filter><wsnt:TopicExpression Dialect="http://www.onvif.org/ver10/tev/topicExpression/ConcreteSet" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:tns1="http://www.onvif.org/ver10/topics">tns1:RuleEngine/CellMotionDetector/Motion</wsnt:TopicExpression></tt:Filter></tt:Events><tt:Analytics>true</tt:Analytics><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.2.0.0</tt:IPv4Address></tt:Address><tt:Port>40020</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>false</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT60S</tt:SessionTimeout></tt:MetadataConfiguration></trt:Profiles></trt:GetProfilesResponse></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><trt:SetVideoEncoderConfigurationResponse/></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><trt:GetStreamUriResponse><trt:MediaUri><tt:Uri>rtsp://172.10.11.53:554/cam/realmonitor?channel=1&amp;subtype=0&amp;unicast=true&amp;proto=Onvif</tt:Uri><tt:InvalidAfterConnect>true</tt:InvalidAfterConnect><tt:InvalidAfterReboot>true</tt:InvalidAfterReboot><tt:Timeout>PT0S</tt:Timeout></trt:MediaUri></trt:GetStreamUriResponse></s:Body></s:Envelope><?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:dn="http://www.onvif.org/ver10/network/wsdl" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:d="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing"><s:Header><a:MessageID>uuid:8dc3f112-de55-43ef-87c0-140e57629bee</a:MessageID><a:To>urn:schemas-xmlsoap-org:ws:2005:04:discovery</a:To><a:Action>http://schemas.xmlsoap.org/ws/2005/04/discovery/ProbeMatches</a:Action><a:RelatesTo>50a35cc4-fafc-41f5-972c-e67efe7211c5</a:RelatesTo></s:Header><s:Body><d:ProbeMatches><d:ProbeMatch><a:EndpointReference><a:Address>uuid:040a347f-c505-4a91-971c-34deb6f94463</a:Address></a:EndpointReference><d:Types>dn:NetworkVideoTransmitter tds:Device</d:Types><d:Scopes>onvif://www.onvif.org/location/country/china onvif://www.onvif.org/name/Dahua onvif://www.onvif.org/hardware/IPC-HDW1025C onvif://www.onvif.org/Profile/Streaming onvif://www.onvif.org/type/Network_Video_Transmitter onvif://www.onvif.org/extension/unique_identifier  onvif://www.onvif.org/Profile/Q/Operational</d:Scopes><d:XAddrs>http://172.10.11.53/onvif/device_service</d:XAddrs><d:MetadataVersion>1</d:MetadataVersion></d:ProbeMatch></d:ProbeMatches></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><tds:GetCapabilitiesResponse><tds:Capabilities><tt:Analytics><tt:XAddr>http://172.10.11.53/onvif/analytics_service</tt:XAddr><tt:RuleSupport>true</tt:RuleSupport><tt:AnalyticsModuleSupport>true</tt:AnalyticsModuleSupport></tt:Analytics><tt:Device><tt:XAddr>http://172.10.11.53/onvif/device_service</tt:XAddr><tt:Network><tt:IPFilter>false</tt:IPFilter><tt:ZeroConfiguration>true</tt:ZeroConfiguration><tt:IPVersion6>false</tt:IPVersion6><tt:DynDNS>false</tt:DynDNS><tt:Extension><tt:Dot11Configuration>false</tt:Dot11Configuration></tt:Extension></tt:Network><tt:System><tt:DiscoveryResolve>false</tt:DiscoveryResolve><tt:DiscoveryBye>true</tt:DiscoveryBye><tt:RemoteDiscovery>false</tt:RemoteDiscovery><tt:SystemBackup>false</tt:SystemBackup><tt:SystemLogging>true</tt:SystemLogging><tt:FirmwareUpgrade>true</tt:FirmwareUpgrade><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>0</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>10</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>20</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>30</tt:Minor></tt:SupportedVersions><tt:SupportedVersions><tt:Major>2</tt:Major><tt:Minor>40</tt:Minor></tt:SupportedVersions><tt:Extension><tt:HttpFirmwareUpgrade>true</tt:HttpFirmwareUpgrade><tt:HttpSystemBackup>false</tt:HttpSystemBackup><tt:HttpSystemLogging>false</tt:HttpSystemLogging><tt:HttpSupportInformation>false</tt:HttpSupportInformation></tt:Extension></tt:System><tt:IO><tt:InputConnectors>0</tt:InputConnectors><tt:RelayOutputs>0</tt:RelayOutputs><tt:Extension><tt:Auxiliary>false</tt:Auxiliary><tt:Extension></tt:Extension></tt:Extension></tt:IO><tt:Security><tt:TLS1.1>false</tt:TLS1.1><tt:TLS1.2>false</tt:TLS1.2><tt:OnboardKeyGeneration>false</tt:OnboardKeyGeneration><tt:AccessPolicyConfig>false</tt:AccessPolicyConfig><tt:X.509Token>false</tt:X.509Token><tt:SAMLToken>false</tt:SAMLToken><tt:KerberosToken>false</tt:KerberosToken><tt:RELToken>false</tt:RELToken><tt:Extension><tt:TLS1.0>false</tt:TLS1.0><tt:Extension><tt:Dot1X>false</tt:Dot1X><tt:SupportedEAPMethod>0</tt:SupportedEAPMethod><tt:RemoteUserHandling>false</tt:RemoteUserHandling></tt:Extension></tt:Extension></tt:Security></tt:Device><tt:Events><tt:XAddr>http://172.10.11.53/onvif/event_service</tt:XAddr><tt:WSSubscriptionPolicySupport>false</tt:WSSubscriptionPolicySupport><tt:WSPullPointSupport>false</tt:WSPullPointSupport><tt:WSPausableSubscriptionManagerInterfaceSupport>false</tt:WSPausableSubscriptionManagerInterfaceSupport></tt:Events><tt:Imaging><tt:XAddr>http://172.10.11.53/onvif/imaging_service</tt:XAddr></tt:Imaging><tt:Media><tt:XAddr>http://172.10.11.53/onvif/media_service</tt:XAddr><tt:StreamingCapabilities><tt:RTPMulticast>true</tt:RTPMulticast><tt:RTP_TCP>true</tt:RTP_TCP><tt:RTP_RTSP_TCP>true</tt:RTP_RTSP_TCP></tt:StreamingCapabilities><tt:Extension><tt:ProfileCapabilities><tt:MaximumNumberOfProfiles>6</tt:MaximumNumberOfProfiles></tt:ProfileCapabilities></tt:Extension></tt:Media><tt:Extension><tt:DeviceIO><tt:XAddr>http://172.10.11.53/onvif/deviceIO_service</tt:XAddr><tt:VideoSources>1</tt:VideoSources><tt:VideoOutputs>0</tt:VideoOutputs><tt:AudioSources>0</tt:AudioSources><tt:AudioOutputs>0</tt:AudioOutputs><tt:RelayOutputs>0</tt:RelayOutputs></tt:DeviceIO><tt:Extensions><tt:TelexCapabilities><tt:XAddr>http://172.10.11.53/onvif/telecom_service</tt:XAddr><tt:TimeOSDSupport>true</tt:TimeOSDSupport><tt:TitleOSDSupport>true</tt:TitleOSDSupport><tt:PTZ3DZoomSupport>true</tt:PTZ3DZoomSupport><tt:PTZAuxSwitchSupport>true</tt:PTZAuxSwitchSupport><tt:MotionDetectorSupport>true</tt:MotionDetectorSupport><tt:TamperDetectorSupport>true</tt:TamperDetectorSupport></tt:TelexCapabilities></tt:Extensions></tt:Extension></tds:Capabilities></tds:GetCapabilitiesResponse></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><trt:GetProfilesResponse><trt:Profiles token="MediaProfile000" fixed="true"><tt:Name>MediaProfile_Channel1_MainStream</tt:Name><tt:VideoSourceConfiguration token="000"><tt:Name>VideoSourceConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:SourceToken>000</tt:SourceToken><tt:Bounds x="0" y="0" width="2048" height="1536"/></tt:VideoSourceConfiguration><tt:VideoEncoderConfiguration token="000"><tt:Name>VideoEncoderConfig_Channel1_MainStream</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>H264</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4.000000</tt:Quality><tt:RateControl><tt:FrameRateLimit>18</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:H264><tt:GovLength>36</tt:GovLength><tt:H264Profile>High</tt:H264Profile></tt:H264><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.0</tt:IPv4Address></tt:Address><tt:Port>40000</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></tt:VideoEncoderConfiguration><tt:VideoAnalyticsConfiguration token="000"><tt:Name>VideoAnalyticsConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:AnalyticsEngineConfiguration><tt:AnalyticsModule Name="MyCellMotion" Type="tt:CellMotionEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="55"/><tt:ElementItem Name="Layout"><tt:CellLayout Columns="22" Rows="18"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:CellLayout></tt:ElementItem></tt:Parameters></tt:AnalyticsModule><tt:AnalyticsModule Name="MyTamper" Type="tt:TamperEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="48"/><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem><tt:ElementItem Name="Transformation"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:ElementItem></tt:Parameters></tt:AnalyticsModule></tt:AnalyticsEngineConfiguration><tt:RuleEngineConfiguration><tt:Rule Name="Region1" Type="tt:CellMotionDetector"><tt:Parameters><tt:SimpleItem Name="MinCount" Value="4"/><tt:SimpleItem Name="AlarmOnDelay" Value="1000"/><tt:SimpleItem Name="AlarmOffDelay" Value="1000"/><tt:SimpleItem Name="ActiveCells" Value="0P8A8A=="/></tt:Parameters></tt:Rule><tt:Rule Name="MyTamperDetector" Type="tt:TamperDetector"><tt:Parameters><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem></tt:Parameters></tt:Rule></tt:RuleEngineConfiguration></tt:VideoAnalyticsConfiguration><tt:MetadataConfiguration token="000"><tt:Name>MetadataConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:PTZStatus><tt:Status>false</tt:Status><tt:Position>false</tt:Position></tt:PTZStatus><tt:Events><tt:Filter><wsnt:TopicExpression Dialect="http://www.onvif.org/ver10/tev/topicExpression/ConcreteSet" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:tns1="http://www.onvif.org/ver10/topics">tns1:RuleEngine/CellMotionDetector/Motion</wsnt:TopicExpression></tt:Filter></tt:Events><tt:Analytics>true</tt:Analytics><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.2.0.0</tt:IPv4Address></tt:Address><tt:Port>40020</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>false</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT60S</tt:SessionTimeout></tt:MetadataConfiguration></trt:Profiles><trt:Profiles token="MediaProfile001" fixed="true"><tt:Name>MediaProfile_Channel1_SubStream1</tt:Name><tt:VideoSourceConfiguration token="000"><tt:Name>VideoSourceConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:SourceToken>000</tt:SourceToken><tt:Bounds x="0" y="0" width="2048" height="1536"/></tt:VideoSourceConfiguration><tt:VideoEncoderConfiguration token="001"><tt:Name>VideoEncoderConfig_Channel1_SubStream1</tt:Name><tt:UseCount>1</tt:UseCount><tt:Encoding>JPEG</tt:Encoding><tt:Resolution><tt:Width>704</tt:Width><tt:Height>576</tt:Height></tt:Resolution><tt:Quality>4.000000</tt:Quality><tt:RateControl><tt:FrameRateLimit>12</tt:FrameRateLimit><tt:EncodingInterval>1</tt:EncodingInterval><tt:BitrateLimit>1024</tt:BitrateLimit></tt:RateControl><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.1.0.1</tt:IPv4Address></tt:Address><tt:Port>40008</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>true</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT00H01M00S</tt:SessionTimeout></tt:VideoEncoderConfiguration><tt:VideoAnalyticsConfiguration token="000"><tt:Name>VideoAnalyticsConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:AnalyticsEngineConfiguration><tt:AnalyticsModule Name="MyCellMotion" Type="tt:CellMotionEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="55"/><tt:ElementItem Name="Layout"><tt:CellLayout Columns="22" Rows="18"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:CellLayout></tt:ElementItem></tt:Parameters></tt:AnalyticsModule><tt:AnalyticsModule Name="MyTamper" Type="tt:TamperEngine"><tt:Parameters><tt:SimpleItem Name="Sensitivity" Value="48"/><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem><tt:ElementItem Name="Transformation"><tt:Transformation><tt:Translate x="-1.000000" y="-1.000000"/><tt:Scale x="0.006250" y="0.008340"/></tt:Transformation></tt:ElementItem></tt:Parameters></tt:AnalyticsModule></tt:AnalyticsEngineConfiguration><tt:RuleEngineConfiguration><tt:Rule Name="Region1" Type="tt:CellMotionDetector"><tt:Parameters><tt:SimpleItem Name="MinCount" Value="4"/><tt:SimpleItem Name="AlarmOnDelay" Value="1000"/><tt:SimpleItem Name="AlarmOffDelay" Value="1000"/><tt:SimpleItem Name="ActiveCells" Value="0P8A8A=="/></tt:Parameters></tt:Rule><tt:Rule Name="MyTamperDetector" Type="tt:TamperDetector"><tt:Parameters><tt:ElementItem Name="Field"><tt:PolygonConfiguration><tt:Polygon><tt:Point x="0" y="240"/><tt:Point x="0" y="0"/><tt:Point x="320" y="0"/><tt:Point x="320" y="240"/></tt:Polygon></tt:PolygonConfiguration></tt:ElementItem></tt:Parameters></tt:Rule></tt:RuleEngineConfiguration></tt:VideoAnalyticsConfiguration><tt:MetadataConfiguration token="000"><tt:Name>MetadataConfig_Channel1</tt:Name><tt:UseCount>2</tt:UseCount><tt:PTZStatus><tt:Status>false</tt:Status><tt:Position>false</tt:Position></tt:PTZStatus><tt:Events><tt:Filter><wsnt:TopicExpression Dialect="http://www.onvif.org/ver10/tev/topicExpression/ConcreteSet" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:tns1="http://www.onvif.org/ver10/topics">tns1:RuleEngine/CellMotionDetector/Motion</wsnt:TopicExpression></tt:Filter></tt:Events><tt:Analytics>true</tt:Analytics><tt:Multicast><tt:Address><tt:Type>IPv4</tt:Type><tt:IPv4Address>224.2.0.0</tt:IPv4Address></tt:Address><tt:Port>40020</tt:Port><tt:TTL>64</tt:TTL><tt:AutoStart>false</tt:AutoStart></tt:Multicast><tt:SessionTimeout>PT60S</tt:SessionTimeout></tt:MetadataConfiguration></trt:Profiles></trt:GetProfilesResponse></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><trt:SetVideoEncoderConfigurationResponse/></s:Body></s:Envelope>HTTP/1.1 200 OK
./RECV.log:<?xml version="1.0" encoding="utf-8" standalone="yes" ?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:sc="http://www.w3.org/2003/05/soap-encoding" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema"><s:Header/><s:Body><trt:GetStreamUriResponse><trt:MediaUri><tt:Uri>rtsp://172.10.11.53:554/cam/realmonitor?channel=1&amp;subtype=0&amp;unicast=true&amp;proto=Onvif</tt:Uri><tt:InvalidAfterConnect>true</tt:InvalidAfterConnect><tt:InvalidAfterReboot>true</tt:InvalidAfterReboot><tt:Timeout>PT0S</tt:Timeout></trt:MediaUri></trt:GetStreamUriResponse></s:Body></s:Envelope>
